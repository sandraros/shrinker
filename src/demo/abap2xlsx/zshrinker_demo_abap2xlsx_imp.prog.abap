********************************************************************************
*
* LICENSE and NOTICE
*
* See include program ZSHRINKER_DEMO_ABAP2XLSX_LICEN
*
********************************************************************************
*>>>>>>> LCL_EXCEL_THEME_ECLRSCHEMELST <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme_eclrschemelst=ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme_eclrschemelst=ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_THEME_ECLRSCHEMELST implementation.
*"* method's implementations
*include methods.
  METHOD build_xml.
    DATA: lo_theme TYPE REF TO if_ixml_element.
    DATA: lo_theme_objdef TYPE REF TO if_ixml_element.
    CHECK io_document IS BOUND.
    lo_theme ?= io_document->get_root_element( ).
    CHECK lo_theme IS BOUND.
    IF extracolor IS INITIAL.
      lo_theme_objdef ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix
                                                                name   = Lcl_excel_theme=>c_theme_extra_color
                                                                parent = lo_theme ).

    ELSE.
      lo_theme->append_child( new_child = extracolor ).
    ENDIF.

  ENDMETHOD.                    "build_xml
  METHOD load.
    extracolor = Lcl_excel_common=>clone_ixml_with_namespaces( io_extra_color ).
  ENDMETHOD.                    "load
endclass. "LCL_EXCEL_THEME_ECLRSCHEMELST implementation

*>>>>>>> LCL_EXCEL_THEME_ELEMENTS <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme_elements======ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme_elements======ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_THEME_ELEMENTS implementation.
*"* method's implementations
*include methods.
  METHOD build_xml.
    DATA: lo_theme_element TYPE REF TO if_ixml_element.
    DATA: lo_theme TYPE REF TO if_ixml_element.
    CHECK io_document IS BOUND.
    lo_theme ?= io_document->get_root_element( ).
    IF lo_theme IS BOUND.
      lo_theme_element ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix
                                                                 name   = c_theme_elements
                                                              parent = lo_theme ).

      color_scheme->build_xml( io_document = io_document ).
      font_scheme->build_xml( io_document = io_document ).
      fmt_scheme->build_xml( io_document = io_document ).
    ENDIF.
  ENDMETHOD.
  METHOD constructor.
    CREATE OBJECT color_scheme.
    CREATE OBJECT font_scheme.
    CREATE OBJECT fmt_scheme.
  ENDMETHOD.                    "constructor
  METHOD load.
    DATA: lo_elements_children TYPE REF TO if_ixml_node_list.
    DATA: lo_elements_iterator TYPE REF TO if_ixml_node_iterator.
    DATA: lo_elements_element TYPE REF TO if_ixml_element.
    CHECK io_elements IS NOT INITIAL.

    lo_elements_children = io_elements->get_children( ).
    lo_elements_iterator = lo_elements_children->create_iterator( ).
    lo_elements_element ?= lo_elements_iterator->get_next( ).
    WHILE lo_elements_element IS BOUND.
      CASE lo_elements_element->get_name( ).
        WHEN c_color_scheme.
          color_scheme->load( io_color_scheme = lo_elements_element ).
        WHEN c_font_scheme.
          font_scheme->load( io_font_scheme = lo_elements_element ).
        WHEN c_fmt_scheme.
          fmt_scheme->load( io_fmt_scheme = lo_elements_element ).
      ENDCASE.
      lo_elements_element ?= lo_elements_iterator->get_next( ).
    ENDWHILE.
  ENDMETHOD.                    "load
endclass. "LCL_EXCEL_THEME_ELEMENTS implementation

*>>>>>>> LCL_EXCEL_THEME_EXTLST <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme_extlst========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme_extlst========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_THEME_EXTLST implementation.
*"* method's implementations
*include methods.
  METHOD build_xml.
    DATA: lo_theme TYPE REF TO if_ixml_element.
    DATA: lo_theme_objdef TYPE REF TO if_ixml_element.
    CHECK io_document IS BOUND.

    lo_theme ?= io_document->get_root_element( ).
    CHECK lo_theme IS BOUND.
    IF extlst IS INITIAL.
      lo_theme_objdef ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix
                                                                name   = Lcl_excel_theme=>c_theme_extlst
                                                                parent = lo_theme ).

    ELSE.
      lo_theme->append_child( new_child = extlst ).
    ENDIF.
  ENDMETHOD.                    "build_xml
  METHOD load.
    extlst = Lcl_excel_common=>clone_ixml_with_namespaces( io_extlst ).
  ENDMETHOD.                    "load
endclass. "LCL_EXCEL_THEME_EXTLST implementation

*>>>>>>> LCL_EXCEL_THEME_FONT_SCHEME <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme_font_scheme===ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme_font_scheme===ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_THEME_FONT_SCHEME implementation.
*"* method's implementations
*include methods.
  METHOD build_xml.
    DATA: lo_scheme_element TYPE REF TO if_ixml_element.
    DATA: lo_font TYPE REF TO if_ixml_element.
    DATA: lo_latin TYPE REF TO if_ixml_element.
    DATA: lo_ea TYPE REF TO if_ixml_element.
    DATA: lo_cs TYPE REF TO if_ixml_element.
    DATA: lo_major TYPE REF TO if_ixml_element.
    DATA: lo_minor TYPE REF TO if_ixml_element.
    DATA: lo_elements TYPE REF TO if_ixml_element.
    FIELD-SYMBOLS: <font> TYPE t_font.
    CHECK io_document IS BOUND.
    lo_elements ?= io_document->find_from_name_ns( name = Lcl_excel_theme=>c_theme_elements ).
    IF lo_elements IS BOUND.
      lo_scheme_element ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = Lcl_excel_theme_elements=>c_font_scheme
                                                               parent = lo_elements ).
      lo_scheme_element->set_attribute( name = c_name value = font_scheme-name ).

      lo_major ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_major
                                                      parent = lo_scheme_element ).
      IF lo_major IS BOUND.
        lo_latin ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_latin
                                                         parent = lo_major ).
        lo_latin->set_attribute( name = c_typeface value = font_scheme-major-latin-typeface ).
        IF font_scheme-major-latin-panose IS NOT INITIAL.
          lo_latin->set_attribute( name = c_panose value = font_scheme-major-latin-panose ).
        ENDIF.
        IF font_scheme-major-latin-pitchfamily IS NOT INITIAL.
          lo_latin->set_attribute( name = c_pitchfamily value = font_scheme-major-latin-pitchfamily ).
        ENDIF.
        IF font_scheme-major-latin-charset IS NOT INITIAL.
          lo_latin->set_attribute( name = c_charset value = font_scheme-major-latin-charset ).
        ENDIF.

        lo_ea ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_ea
                                                         parent = lo_major ).
        lo_ea->set_attribute( name = c_typeface value = font_scheme-major-ea-typeface ).
        IF font_scheme-major-ea-panose IS NOT INITIAL.
          lo_ea->set_attribute( name = c_panose value = font_scheme-major-ea-panose ).
        ENDIF.
        IF font_scheme-major-ea-pitchfamily IS NOT INITIAL.
          lo_ea->set_attribute( name = c_pitchfamily value = font_scheme-major-ea-pitchfamily ).
        ENDIF.
        IF font_scheme-major-ea-charset IS NOT INITIAL.
          lo_ea->set_attribute( name = c_charset value = font_scheme-major-ea-charset ).
        ENDIF.

        lo_cs ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_cs
                                                      parent = lo_major ).
        lo_cs->set_attribute( name = c_typeface value = font_scheme-major-cs-typeface ).
        IF font_scheme-major-cs-panose IS NOT INITIAL.
          lo_cs->set_attribute( name = c_panose value = font_scheme-major-cs-panose ).
        ENDIF.
        IF font_scheme-major-cs-pitchfamily IS NOT INITIAL.
          lo_cs->set_attribute( name = c_pitchfamily value = font_scheme-major-cs-pitchfamily ).
        ENDIF.
        IF font_scheme-major-cs-charset IS NOT INITIAL.
          lo_cs->set_attribute( name = c_charset value = font_scheme-major-cs-charset ).
        ENDIF.

        LOOP AT font_scheme-major-fonts ASSIGNING <font>.
          IF <font>-script IS NOT INITIAL AND <font>-typeface IS NOT INITIAL.
            CLEAR lo_font.
            lo_font ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_font
                                                           parent = lo_major ).
            lo_font->set_attribute( name = c_script value = <font>-script ).
            lo_font->set_attribute( name = c_typeface value = <font>-typeface ).
          ENDIF.
        ENDLOOP.
        CLEAR: lo_latin, lo_ea, lo_cs, lo_font.
      ENDIF.

      lo_minor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_minor
                                                      parent = lo_scheme_element ).
      IF lo_minor IS BOUND.
        lo_latin ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_latin
                                                         parent = lo_minor ).
        lo_latin->set_attribute( name = c_typeface value = font_scheme-minor-latin-typeface ).
        IF font_scheme-minor-latin-panose IS NOT INITIAL.
          lo_latin->set_attribute( name = c_panose value = font_scheme-minor-latin-panose ).
        ENDIF.
        IF font_scheme-minor-latin-pitchfamily IS NOT INITIAL.
          lo_latin->set_attribute( name = c_pitchfamily value = font_scheme-minor-latin-pitchfamily ).
        ENDIF.
        IF font_scheme-minor-latin-charset IS NOT INITIAL.
          lo_latin->set_attribute( name = c_charset value = font_scheme-minor-latin-charset ).
        ENDIF.

        lo_ea ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_ea
                                                         parent = lo_minor ).
        lo_ea->set_attribute( name = c_typeface value = font_scheme-minor-ea-typeface ).
        IF font_scheme-minor-ea-panose IS NOT INITIAL.
          lo_ea->set_attribute( name = c_panose value = font_scheme-minor-ea-panose ).
        ENDIF.
        IF font_scheme-minor-ea-pitchfamily IS NOT INITIAL.
          lo_ea->set_attribute( name = c_pitchfamily value = font_scheme-minor-ea-pitchfamily ).
        ENDIF.
        IF font_scheme-minor-ea-charset IS NOT INITIAL.
          lo_ea->set_attribute( name = c_charset value = font_scheme-minor-ea-charset ).
        ENDIF.

        lo_cs ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_cs
                                                      parent = lo_minor ).
        lo_cs->set_attribute( name = c_typeface value = font_scheme-minor-cs-typeface ).
        IF font_scheme-minor-cs-panose IS NOT INITIAL.
          lo_cs->set_attribute( name = c_panose value = font_scheme-minor-cs-panose ).
        ENDIF.
        IF font_scheme-minor-cs-pitchfamily IS NOT INITIAL.
          lo_cs->set_attribute( name = c_pitchfamily value = font_scheme-minor-cs-pitchfamily ).
        ENDIF.
        IF font_scheme-minor-cs-charset IS NOT INITIAL.
          lo_cs->set_attribute( name = c_charset value = font_scheme-minor-cs-charset ).
        ENDIF.

        LOOP AT font_scheme-minor-fonts ASSIGNING <font>.
          IF <font>-script IS NOT INITIAL AND <font>-typeface IS NOT INITIAL.
            CLEAR lo_font.
            lo_font ?=  io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_font
                                                           parent = lo_minor ).
            lo_font->set_attribute( name = c_script value = <font>-script ).
            lo_font->set_attribute( name = c_typeface value = <font>-typeface ).
          ENDIF.
        ENDLOOP.
      ENDIF.


    ENDIF.
  ENDMETHOD.                    "build_xml
  METHOD constructor.
    set_defaults( ).
  ENDMETHOD.                    "constructor
  METHOD load.
    DATA: lo_scheme_children TYPE REF TO if_ixml_node_list.
    DATA: lo_scheme_iterator TYPE REF TO if_ixml_node_iterator.
    DATA: lo_scheme_element TYPE REF TO if_ixml_element.
    DATA: lo_major_children TYPE REF TO if_ixml_node_list.
    DATA: lo_major_iterator TYPE REF TO if_ixml_node_iterator.
    DATA: lo_major_element TYPE REF TO if_ixml_element.
    DATA: lo_minor_children TYPE REF TO if_ixml_node_list.
    DATA: lo_minor_iterator TYPE REF TO if_ixml_node_iterator.
    DATA: lo_minor_element TYPE REF TO if_ixml_element.
    DATA: ls_font TYPE t_font.
    CHECK io_font_scheme IS NOT INITIAL.
    CLEAR font_scheme.
    font_scheme-name =  io_font_scheme->get_attribute( name = c_name ).
    lo_scheme_children = io_font_scheme->get_children( ).
    lo_scheme_iterator = lo_scheme_children->create_iterator( ).
    lo_scheme_element ?= lo_scheme_iterator->get_next( ).
    WHILE lo_scheme_element IS BOUND.
      CASE lo_scheme_element->get_name( ).
        WHEN c_major.
          lo_major_children = lo_scheme_element->get_children( ).
          lo_major_iterator = lo_major_children->create_iterator( ).
          lo_major_element ?= lo_major_iterator->get_next( ).
          WHILE lo_major_element IS BOUND.
            CASE lo_major_element->get_name( ).
              WHEN c_latin.
                font_scheme-major-latin-typeface = lo_major_element->get_attribute(  name = c_typeface ).
                font_scheme-major-latin-panose = lo_major_element->get_attribute(  name = c_panose ).
                font_scheme-major-latin-pitchfamily = lo_major_element->get_attribute(  name = c_pitchfamily ).
                font_scheme-major-latin-charset = lo_major_element->get_attribute(  name = c_charset ).
              WHEN c_ea.
                font_scheme-major-ea-typeface = lo_major_element->get_attribute(  name = c_typeface ).
                font_scheme-major-ea-panose = lo_major_element->get_attribute(  name = c_panose ).
                font_scheme-major-ea-pitchfamily = lo_major_element->get_attribute(  name = c_pitchfamily ).
                font_scheme-major-ea-charset = lo_major_element->get_attribute(  name = c_charset ).
              WHEN c_cs.
                font_scheme-major-cs-typeface = lo_major_element->get_attribute(  name = c_typeface ).
                font_scheme-major-cs-panose = lo_major_element->get_attribute(  name = c_panose ).
                font_scheme-major-cs-pitchfamily = lo_major_element->get_attribute(  name = c_pitchfamily ).
                font_scheme-major-cs-charset = lo_major_element->get_attribute(  name = c_charset ).
              WHEN c_font.
                CLEAR ls_font.
                ls_font-script = lo_major_element->get_attribute(  name = c_script ).
                ls_font-typeface = lo_major_element->get_attribute(  name = c_typeface ).
                TRY.
                    INSERT ls_font INTO TABLE font_scheme-major-fonts.
                  CATCH cx_root. "not the best but just to avoid duplicate lines dump

                ENDTRY.
            ENDCASE.
            lo_major_element ?= lo_major_iterator->get_next( ).
          ENDWHILE.
        WHEN c_minor.
          lo_minor_children = lo_scheme_element->get_children( ).
          lo_minor_iterator = lo_minor_children->create_iterator( ).
          lo_minor_element ?= lo_minor_iterator->get_next( ).
          WHILE lo_minor_element IS BOUND.
            CASE lo_minor_element->get_name( ).
              WHEN c_latin.
                font_scheme-minor-latin-typeface = lo_minor_element->get_attribute(  name = c_typeface ).
                font_scheme-minor-latin-panose = lo_minor_element->get_attribute(  name = c_panose ).
                font_scheme-minor-latin-pitchfamily = lo_minor_element->get_attribute(  name = c_pitchfamily ).
                font_scheme-minor-latin-charset = lo_minor_element->get_attribute(  name = c_charset ).
              WHEN c_ea.
                font_scheme-minor-ea-typeface = lo_minor_element->get_attribute(  name = c_typeface ).
                font_scheme-minor-ea-panose = lo_minor_element->get_attribute(  name = c_panose ).
                font_scheme-minor-ea-pitchfamily = lo_minor_element->get_attribute(  name = c_pitchfamily ).
                font_scheme-minor-ea-charset = lo_minor_element->get_attribute(  name = c_charset ).
              WHEN c_cs.
                font_scheme-minor-cs-typeface = lo_minor_element->get_attribute(  name = c_typeface ).
                font_scheme-minor-cs-panose = lo_minor_element->get_attribute(  name = c_panose ).
                font_scheme-minor-cs-pitchfamily = lo_minor_element->get_attribute(  name = c_pitchfamily ).
                font_scheme-minor-cs-charset = lo_minor_element->get_attribute(  name = c_charset ).
              WHEN c_font.
                CLEAR ls_font.
                ls_font-script = lo_minor_element->get_attribute(  name = c_script ).
                ls_font-typeface = lo_minor_element->get_attribute(  name = c_typeface ).
                TRY.
                    INSERT ls_font INTO TABLE font_scheme-minor-fonts.
                  CATCH cx_root. "not the best but just to avoid duplicate lines dump

                ENDTRY.
            ENDCASE.
            lo_minor_element ?= lo_minor_iterator->get_next( ).
          ENDWHILE.
      ENDCASE.
      lo_scheme_element ?= lo_scheme_iterator->get_next( ).
    ENDWHILE.
  ENDMETHOD.                    "load
  METHOD modify_cs_font.
    modify_lec_fonts(
      EXPORTING
        iv_type        = iv_type
        iv_font_type   = c_cs
        iv_typeface    = iv_typeface
        iv_panose      = iv_panose
        iv_pitchfamily = iv_pitchfamily
        iv_charset     = iv_charset
    ).
  ENDMETHOD.                    "modify_latin_font
  METHOD modify_ea_font.
    modify_lec_fonts(
      EXPORTING
        iv_type        = iv_type
        iv_font_type   = c_ea
        iv_typeface    = iv_typeface
        iv_panose      = iv_panose
        iv_pitchfamily = iv_pitchfamily
        iv_charset     = iv_charset
    ).
  ENDMETHOD.                    "modify_latin_font
  METHOD modify_font.
    DATA: ls_font TYPE t_font.
    FIELD-SYMBOLS: <font> TYPE t_font.
    ls_font-script = iv_script.
    ls_font-typeface = iv_typeface.
    TRY.
        CASE iv_type.
          WHEN c_major.
            READ TABLE font_scheme-major-fonts WITH KEY script = iv_script ASSIGNING <font>.
            IF sy-subrc EQ 0.
              <font> = ls_font.
            ELSE.
              INSERT ls_font INTO TABLE font_scheme-major-fonts.
            ENDIF.
          WHEN c_minor.
            READ TABLE font_scheme-minor-fonts WITH KEY script = iv_script ASSIGNING <font>.
            IF sy-subrc EQ 0.
              <font> = ls_font.
            ELSE.
              INSERT ls_font INTO TABLE font_scheme-minor-fonts.
            ENDIF.
        ENDCASE.
      CATCH cx_root. "not the best but just to avoid duplicate lines dump
    ENDTRY.
  ENDMETHOD.                    "add_font
  METHOD modify_latin_font.
    modify_lec_fonts(
      EXPORTING
        iv_type        = iv_type
        iv_font_type   = c_latin
        iv_typeface    = iv_typeface
        iv_panose      = iv_panose
        iv_pitchfamily = iv_pitchfamily
        iv_charset     = iv_charset
    ).
  ENDMETHOD.                    "modify_latin_font
  METHOD modify_lec_fonts.
    FIELD-SYMBOLS: <type> TYPE t_fonts,
                   <font> TYPE t_fonttype.
    CASE iv_type.
      WHEN c_minor.
        ASSIGN font_scheme-minor TO <type>.
      WHEN c_major.
        ASSIGN font_scheme-major TO <type>.
      WHEN OTHERS.
        RETURN.
    ENDCASE.
    CHECK <type> IS ASSIGNED.
    CASE iv_font_type.
      WHEN c_latin.
        ASSIGN <type>-latin TO <font>.
      WHEN c_ea.
        ASSIGN <type>-ea TO <font>.
      WHEN c_cs.
        ASSIGN <type>-cs TO <font>.
      WHEN OTHERS.
        RETURN.
    ENDCASE.
    CHECK <font> IS ASSIGNED.
    <font>-typeface = iv_typeface.
    <font>-panose = iv_panose.
    <font>-pitchfamily = iv_pitchfamily.
    <font>-charset = iv_charset.
  ENDMETHOD.                    "modify_lec_fonts
  METHOD set_defaults.
    CLEAR font_scheme.
    font_scheme-name = 'Office'.
    font_scheme-major-latin-typeface = 'Calibri Light'.
    font_scheme-major-latin-panose = '020F0302020204030204'.
    modify_font( iv_type = c_major iv_script = 'Jpan' iv_typeface = 'ＭＳ Ｐゴシック' ).
    modify_font( iv_type = c_major iv_script = 'Hang' iv_typeface = '맑은 고딕' ).
    modify_font( iv_type = c_major iv_script = 'Hans' iv_typeface = '宋体' ).
    modify_font( iv_type = c_major iv_script = 'Hant' iv_typeface = '新細明體' ).
    modify_font( iv_type = c_major iv_script = 'Arab' iv_typeface = 'Times New Roman' ).
    modify_font( iv_type = c_major iv_script = 'Hebr' iv_typeface = 'Times New Roman' ).
    modify_font( iv_type = c_major iv_script = 'Thai' iv_typeface = 'Tahoma' ).
    modify_font( iv_type = c_major iv_script = 'Ethi' iv_typeface = 'Nyala' ).
    modify_font( iv_type = c_major iv_script = 'Beng' iv_typeface = 'Vrinda' ).
    modify_font( iv_type = c_major iv_script = 'Gujr' iv_typeface = 'Shruti' ).
    modify_font( iv_type = c_major iv_script = 'Khmr' iv_typeface = 'MoolBoran' ).
    modify_font( iv_type = c_major iv_script = 'Knda' iv_typeface = 'Tunga' ).
    modify_font( iv_type = c_major iv_script = 'Guru' iv_typeface = 'Raavi' ).
    modify_font( iv_type = c_major iv_script = 'Cans' iv_typeface = 'Euphemia' ).
    modify_font( iv_type = c_major iv_script = 'Cher' iv_typeface = 'Plantagenet Cherokee' ).
    modify_font( iv_type = c_major iv_script = 'Yiii' iv_typeface = 'Microsoft Yi Baiti' ).
    modify_font( iv_type = c_major iv_script = 'Tibt' iv_typeface = 'Microsoft Himalaya' ).
    modify_font( iv_type = c_major iv_script = 'Thaa' iv_typeface = 'MV Boli' ).
    modify_font( iv_type = c_major iv_script = 'Deva' iv_typeface = 'Mangal' ).
    modify_font( iv_type = c_major iv_script = 'Telu' iv_typeface = 'Gautami' ).
    modify_font( iv_type = c_major iv_script = 'Taml' iv_typeface = 'Latha' ).
    modify_font( iv_type = c_major iv_script = 'Syrc' iv_typeface = 'Estrangelo Edessa' ).
    modify_font( iv_type = c_major iv_script = 'Orya' iv_typeface = 'Kalinga' ).
    modify_font( iv_type = c_major iv_script = 'Mlym' iv_typeface = 'Kartika' ).
    modify_font( iv_type = c_major iv_script = 'Laoo' iv_typeface = 'DokChampa' ).
    modify_font( iv_type = c_major iv_script = 'Sinh' iv_typeface = 'Iskoola Pota' ).
    modify_font( iv_type = c_major iv_script = 'Mong' iv_typeface = 'Mongolian Baiti' ).
    modify_font( iv_type = c_major iv_script = 'Viet' iv_typeface = 'Times New Roman' ).
    modify_font( iv_type = c_major iv_script = 'Uigh' iv_typeface = 'Microsoft Uighur' ).
    modify_font( iv_type = c_major iv_script = 'Geor' iv_typeface = 'Sylfaen' ).

    font_scheme-minor-latin-typeface = 'Calibri'.
    font_scheme-minor-latin-panose = '020F0502020204030204'.
    modify_font( iv_type = c_minor iv_script = 'Jpan' iv_typeface = 'ＭＳ Ｐゴシック' ).
    modify_font( iv_type = c_minor iv_script = 'Hang' iv_typeface = '맑은 고딕' ).
    modify_font( iv_type = c_minor iv_script = 'Hans' iv_typeface = '宋体' ).
    modify_font( iv_type = c_minor iv_script = 'Hant' iv_typeface = '新細明體' ).
    modify_font( iv_type = c_minor iv_script = 'Arab' iv_typeface = 'Arial' ).
    modify_font( iv_type = c_minor iv_script = 'Hebr' iv_typeface = 'Arial' ).
    modify_font( iv_type = c_minor iv_script = 'Thai' iv_typeface = 'Tahoma' ).
    modify_font( iv_type = c_minor iv_script = 'Ethi' iv_typeface = 'Nyala' ).
    modify_font( iv_type = c_minor iv_script = 'Beng' iv_typeface = 'Vrinda' ).
    modify_font( iv_type = c_minor iv_script = 'Gujr' iv_typeface = 'Shruti' ).
    modify_font( iv_type = c_minor iv_script = 'Khmr' iv_typeface = 'DaunPenh' ).
    modify_font( iv_type = c_minor iv_script = 'Knda' iv_typeface = 'Tunga' ).
    modify_font( iv_type = c_minor iv_script = 'Guru' iv_typeface = 'Raavi' ).
    modify_font( iv_type = c_minor iv_script = 'Cans' iv_typeface = 'Euphemia' ).
    modify_font( iv_type = c_minor iv_script = 'Cher' iv_typeface = 'Plantagenet Cherokee' ).
    modify_font( iv_type = c_minor iv_script = 'Yiii' iv_typeface = 'Microsoft Yi Baiti' ).
    modify_font( iv_type = c_minor iv_script = 'Tibt' iv_typeface = 'Microsoft Himalaya' ).
    modify_font( iv_type = c_minor iv_script = 'Thaa' iv_typeface = 'MV Boli' ).
    modify_font( iv_type = c_minor iv_script = 'Deva' iv_typeface = 'Mangal' ).
    modify_font( iv_type = c_minor iv_script = 'Telu' iv_typeface = 'Gautami' ).
    modify_font( iv_type = c_minor iv_script = 'Taml' iv_typeface = 'Latha' ).
    modify_font( iv_type = c_minor iv_script = 'Syrc' iv_typeface = 'Estrangelo Edessa' ).
    modify_font( iv_type = c_minor iv_script = 'Orya' iv_typeface = 'Kalinga' ).
    modify_font( iv_type = c_minor iv_script = 'Mlym' iv_typeface = 'Kartika' ).
    modify_font( iv_type = c_minor iv_script = 'Laoo' iv_typeface = 'DokChampa' ).
    modify_font( iv_type = c_minor iv_script = 'Sinh' iv_typeface = 'Iskoola Pota' ).
    modify_font( iv_type = c_minor iv_script = 'Mong' iv_typeface = 'Mongolian Baiti' ).
    modify_font( iv_type = c_minor iv_script = 'Viet' iv_typeface = 'Arial' ).
    modify_font( iv_type = c_minor iv_script = 'Uigh' iv_typeface = 'Microsoft Uighur' ).
    modify_font( iv_type = c_minor iv_script = 'Geor' iv_typeface = 'Sylfaen' ).

  ENDMETHOD.                    "set_defaults
  METHOD set_name.
    font_scheme-name = iv_name.
  ENDMETHOD.                    "set_name
endclass. "LCL_EXCEL_THEME_FONT_SCHEME implementation

*>>>>>>> LCL_EXCEL_THEME_OBJECTDEFAULTS <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme_objectdefaultsccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme_objectdefaultsccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_THEME_OBJECTDEFAULTS implementation.
*"* method's implementations
*include methods.
  METHOD build_xml.
    DATA: lo_theme TYPE REF TO if_ixml_element.
    DATA: lo_theme_objdef TYPE REF TO if_ixml_element.
    CHECK io_document IS BOUND.
    lo_theme ?= io_document->get_root_element( ).
    CHECK lo_theme IS BOUND.
    IF objectdefaults IS INITIAL.
      lo_theme_objdef ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix
                                                                name   = Lcl_excel_theme=>c_theme_object_def
                                                                parent = lo_theme ).
    ELSE.
      lo_theme->append_child( new_child = objectdefaults ).
    ENDIF.
  ENDMETHOD.                    "build_xml
  METHOD load.
    objectdefaults = Lcl_excel_common=>clone_ixml_with_namespaces( io_object_def ).
  ENDMETHOD.                    "load
endclass. "LCL_EXCEL_THEME_OBJECTDEFAULTS implementation

*>>>>>>> LCL_EXCEL_WORKSHEETS <<<<<<<*

*"* macro definitions
*include Lcl_excel_worksheets==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_worksheets==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_WORKSHEETS implementation.
*"* method's implementations
*include methods.
  METHOD add.

    worksheets->add( ip_worksheet ).

  ENDMETHOD.
  METHOD clear.

    worksheets->clear( ).

  ENDMETHOD.
  METHOD constructor.

    CREATE OBJECT worksheets.

  ENDMETHOD.
  METHOD get.

    DATA lv_index TYPE i.
    lv_index = ip_index.
    eo_worksheet ?= worksheets->get( lv_index ).

  ENDMETHOD.
  METHOD get_iterator.

    eo_iterator ?= worksheets->get_iterator( ).

  ENDMETHOD.
  METHOD is_empty.

    is_empty = worksheets->is_empty( ).

  ENDMETHOD.
  METHOD remove.

    worksheets->remove( ip_worksheet ).

  ENDMETHOD.
  METHOD size.

    ep_size = worksheets->size( ).

  ENDMETHOD.
endclass. "LCL_EXCEL_WORKSHEETS implementation

*>>>>>>> LCL_EXCEL_WORKSHEET_PAGEBREAKS <<<<<<<*

*"* macro definitions
*include Lcl_excel_worksheet_pagebreaksccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_worksheet_pagebreaksccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_WORKSHEET_PAGEBREAKS implementation.
*"* method's implementations
*include methods.
  METHOD add_pagebreak.
    DATA: ls_pagebreak      LIKE LINE OF me->mt_pagebreaks.

    ls_pagebreak-cell_row    = ip_row.
    ls_pagebreak-cell_column = Lcl_excel_common=>convert_column2int( ip_column ).

    INSERT ls_pagebreak INTO TABLE me->mt_pagebreaks.


  ENDMETHOD.
  METHOD get_all_pagebreaks.
    rt_pagebreaks = me->mt_pagebreaks.
  ENDMETHOD.
endclass. "LCL_EXCEL_WORKSHEET_PAGEBREAKS implementation

*>>>>>>> LCL_EXCEL_WRITER_2007 <<<<<<<*

*"* macro definitions
*include Lcl_excel_writer_2007=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_writer_2007=========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations
*CLASS SHRITEFUH64VYIPN5I4UIDBJAALSE4 DEFINITION DEFERRED.
*CLASS Lcl_excel_writer_2007 DEFINITION LOCAL FRIENDS SHRITEFUH64VYIPN5I4UIDBJAALSE4.
CLASS SHRITEFUH64VYIPN5I4UIDBJAALSE4 DEFINITION CREATE PUBLIC .

  PUBLIC SECTION.
    METHODS create IMPORTING io_worksheet         TYPE REF TO Lcl_excel_worksheet
                             iv_active            TYPE flag DEFAULT ''
                             io_document          TYPE REF TO if_ixml_document
                             io_excel_writer_2007 TYPE REF TO Lcl_excel_writer_2007
                   RAISING   Lcx_excel.
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES: BEGIN OF colors,
             colorrgb TYPE zexcel_color,
           END OF colors,
           BEGIN OF cfvo,
             value TYPE zexcel_conditional_value,
             type  TYPE zexcel_conditional_type,
           END OF cfvo,
           BEGIN OF ty_condformating_range,
             dimension_range     TYPE string,
             condformatting_node TYPE REF TO if_ixml_element,
           END OF ty_condformating_range,
           ty_condformating_ranges TYPE STANDARD TABLE OF ty_condformating_range.
    CONSTANTS:
      lc_xml_node_sheetpr           TYPE string VALUE 'sheetPr',
      lc_xml_node_tabcolor          TYPE string VALUE 'tabColor',
      lc_xml_node_outlinepr         TYPE string VALUE 'outlinePr',
      lc_xml_node_pagesetuppr       TYPE string VALUE 'pageSetUpPr',
      lc_xml_node_dimension         TYPE string VALUE 'dimension',
      lc_xml_node_sheetviews        TYPE string VALUE 'sheetViews',
      lc_xml_node_sheetview         TYPE string VALUE 'sheetView',
      lc_xml_node_selection         TYPE string VALUE 'selection',
      lc_xml_node_pane              TYPE string VALUE 'pane',
      lc_xml_node_sheetformatpr     TYPE string VALUE 'sheetFormatPr',
      lc_xml_node_cols              TYPE string VALUE 'cols',
      lc_xml_node_col               TYPE string VALUE 'col',
      lc_xml_node_sheetprotection   TYPE string VALUE 'sheetProtection',
      lc_xml_node_autofilter        TYPE string VALUE 'autoFilter',
      lc_xml_node_filtercolumn      TYPE string VALUE 'filterColumn',
      lc_xml_node_filters           TYPE string VALUE 'filters',
      lc_xml_node_filter            TYPE string VALUE 'filter',
      lc_xml_node_mergecell         TYPE string VALUE 'mergeCell',
      lc_xml_node_mergecells        TYPE string VALUE 'mergeCells',
      lc_xml_node_condformatting    TYPE string VALUE 'conditionalFormatting',
      lc_xml_node_cfrule            TYPE string VALUE 'cfRule',
      lc_xml_node_color             TYPE string VALUE 'color',      " Databar by Albert Lladanosa
      lc_xml_node_databar           TYPE string VALUE 'dataBar',    " Databar by Albert Lladanosa
      lc_xml_node_colorscale        TYPE string VALUE 'colorScale',
      lc_xml_node_iconset           TYPE string VALUE 'iconSet',
      lc_xml_node_cfvo              TYPE string VALUE 'cfvo',
      lc_xml_node_formula           TYPE string VALUE 'formula',
      lc_xml_node_datavalidations   TYPE string VALUE 'dataValidations',
      lc_xml_node_datavalidation    TYPE string VALUE 'dataValidation',
      lc_xml_node_formula1          TYPE string VALUE 'formula1',
      lc_xml_node_formula2          TYPE string VALUE 'formula2',
      lc_xml_node_pagemargins       TYPE string VALUE 'pageMargins',
      lc_xml_node_pagesetup         TYPE string VALUE 'pageSetup',
      lc_xml_node_headerfooter      TYPE string VALUE 'headerFooter',
      lc_xml_node_oddheader         TYPE string VALUE 'oddHeader',
      lc_xml_node_oddfooter         TYPE string VALUE 'oddFooter',
      lc_xml_node_evenheader        TYPE string VALUE 'evenHeader',
      lc_xml_node_evenfooter        TYPE string VALUE 'evenFooter',
      lc_xml_node_drawing           TYPE string VALUE 'drawing',
      lc_xml_node_drawing_for_cmt   TYPE string VALUE 'legacyDrawing',
      lc_xml_node_drawing_for_hd_ft TYPE string VALUE 'legacyDrawingHF'.
    CONSTANTS:
      lc_xml_attr_summarybelow       TYPE string VALUE 'summaryBelow',
      lc_xml_attr_summaryright       TYPE string VALUE 'summaryRight',
      lc_xml_attr_fittopage          TYPE string VALUE 'fitToPage',
      lc_xml_attr_tabcolor_rgb       TYPE string VALUE 'rgb',
      lc_xml_attr_ref                TYPE string VALUE 'ref',
      lc_xml_attr_tabselected        TYPE string VALUE 'tabSelected',
      lc_xml_attr_showzeros          TYPE string VALUE 'showZeros',
      lc_xml_attr_zoomscale          TYPE string VALUE 'zoomScale',
      lc_xml_attr_zoomscalenormal    TYPE string VALUE 'zoomScaleNormal',
      lc_xml_attr_zoomscalepageview  TYPE string VALUE 'zoomScalePageLayoutView',
      lc_xml_attr_zoomscalesheetview TYPE string VALUE 'zoomScaleSheetLayoutView',
      lc_xml_attr_workbookviewid     TYPE string VALUE 'workbookViewId',
      lc_xml_attr_showgridlines      TYPE string VALUE 'showGridLines',
      lc_xml_attr_showrowcolheaders  TYPE string VALUE 'showRowColHeaders',
      lc_xml_attr_activecell         TYPE string VALUE 'activeCell',
      lc_xml_attr_sqref              TYPE string VALUE 'sqref',
      lc_xml_attr_true               TYPE string VALUE 'true',
      lc_xml_attr_customheight       TYPE string VALUE 'customHeight',
      lc_xml_attr_defaultrowheight   TYPE string VALUE 'defaultRowHeight',
      lc_xml_attr_defaultcolwidth    TYPE string VALUE 'defaultColWidth',
      lc_xml_attr_outlinelevelcol    TYPE string VALUE 'x14ac:outlineLevelCol',
      lc_xml_attr_min                TYPE string VALUE 'min',
      lc_xml_attr_max                TYPE string VALUE 'max',
      lc_xml_attr_hidden             TYPE string VALUE 'hidden',
      lc_xml_attr_width              TYPE string VALUE 'width',
      lc_xml_attr_defaultwidth       TYPE string VALUE '9.10',
      lc_xml_attr_style              TYPE string VALUE 'style',
      lc_xml_attr_bestfit            TYPE string VALUE 'bestFit',
      lc_xml_attr_customwidth        TYPE string VALUE 'customWidth',
      lc_xml_attr_collapsed          TYPE string VALUE 'collapsed',
      lc_xml_attr_outlinelevel       TYPE string VALUE 'outlineLevel',
      lc_xml_attr_password           TYPE string VALUE 'password',
      lc_xml_attr_sheet              TYPE string VALUE 'sheet',
      lc_xml_attr_objects            TYPE string VALUE 'objects',
      lc_xml_attr_scenarios          TYPE string VALUE 'scenarios',
      lc_xml_attr_autofilter         TYPE string VALUE 'autoFilter',
      lc_xml_attr_deletecolumns      TYPE string VALUE 'deleteColumns',
      lc_xml_attr_deleterows         TYPE string VALUE 'deleteRows',
      lc_xml_attr_formatcells        TYPE string VALUE 'formatCells',
      lc_xml_attr_formatcolumns      TYPE string VALUE 'formatColumns',
      lc_xml_attr_formatrows         TYPE string VALUE 'formatRows',
      lc_xml_attr_insertcolumns      TYPE string VALUE 'insertColumns',
      lc_xml_attr_inserthyperlinks   TYPE string VALUE 'insertHyperlinks',
      lc_xml_attr_insertrows         TYPE string VALUE 'insertRows',
      lc_xml_attr_pivottables        TYPE string VALUE 'pivotTables',
      lc_xml_attr_selectlockedcells  TYPE string VALUE 'selectLockedCells',
      lc_xml_attr_selectunlockedcell TYPE string VALUE 'selectUnlockedCells',
      lc_xml_attr_sort               TYPE string VALUE 'sort',
      lc_xml_attr_val                TYPE string VALUE 'val',
      lc_xml_attr_colid              TYPE string VALUE 'colId',
      lc_xml_attr_filtermode         TYPE string VALUE 'filterMode',
      lc_xml_attr_count              TYPE string VALUE 'count',
      lc_xml_attr_type               TYPE string VALUE 'type',
      lc_xml_attr_operator           TYPE string VALUE 'operator',
      lc_xml_attr_allowblank         TYPE string VALUE 'allowBlank',
      lc_xml_attr_showinputmessage   TYPE string VALUE 'showInputMessage',
      lc_xml_attr_showerrormessage   TYPE string VALUE 'showErrorMessage',
      lc_xml_attr_showdropdown       TYPE string VALUE 'ShowDropDown', " 'showDropDown' does not work
      lc_xml_attr_errortitle         TYPE string VALUE 'errorTitle',
      lc_xml_attr_error              TYPE string VALUE 'error',
      lc_xml_attr_errorstyle         TYPE string VALUE 'errorStyle',
      lc_xml_attr_prompttitle        TYPE string VALUE 'promptTitle',
      lc_xml_attr_prompt             TYPE string VALUE 'prompt',
      lc_xml_attr_gridlines          TYPE string VALUE 'gridLines',
      lc_xml_attr_left               TYPE string VALUE 'left',
      lc_xml_attr_right              TYPE string VALUE 'right',
      lc_xml_attr_top                TYPE string VALUE 'top',
      lc_xml_attr_bottom             TYPE string VALUE 'bottom',
      lc_xml_attr_header             TYPE string VALUE 'header',
      lc_xml_attr_footer             TYPE string VALUE 'footer',
      lc_xml_attr_blackandwhite      TYPE string VALUE 'blackAndWhite',
      lc_xml_attr_cellcomments       TYPE string VALUE 'cellComments',
      lc_xml_attr_copies             TYPE string VALUE 'copies',
      lc_xml_attr_draft              TYPE string VALUE 'draft',
      lc_xml_attr_errors             TYPE string VALUE 'errors',
      lc_xml_attr_firstpagenumber    TYPE string VALUE 'firstPageNumber',
      lc_xml_attr_fittoheight        TYPE string VALUE 'fitToHeight',
      lc_xml_attr_fittowidth         TYPE string VALUE 'fitToWidth',
      lc_xml_attr_horizontaldpi      TYPE string VALUE 'horizontalDpi',
      lc_xml_attr_orientation        TYPE string VALUE 'orientation',
      lc_xml_attr_pageorder          TYPE string VALUE 'pageOrder',
      lc_xml_attr_paperheight        TYPE string VALUE 'paperHeight',
      lc_xml_attr_papersize          TYPE string VALUE 'paperSize',
      lc_xml_attr_paperwidth         TYPE string VALUE 'paperWidth',
      lc_xml_attr_scale              TYPE string VALUE 'scale',
      lc_xml_attr_usefirstpagenumber TYPE string VALUE 'useFirstPageNumber',
      lc_xml_attr_useprinterdefaults TYPE string VALUE 'usePrinterDefaults',
      lc_xml_attr_verticaldpi        TYPE string VALUE 'verticalDpi',
      lc_xml_attr_differentoddeven   TYPE string VALUE 'differentOddEven',
      lc_xml_attr_iconset            TYPE string VALUE 'iconSet',
      lc_xml_attr_showvalue          TYPE string VALUE 'showValue',
      lc_xml_attr_dxfid              TYPE string VALUE 'dxfId',
      lc_xml_attr_priority           TYPE string VALUE 'priority',
      lc_xml_attr_text               TYPE string VALUE 'text'.
    DATA:
      o_excel_ref    TYPE REF TO Lcl_excel_writer_2007,
      o_worksheet    TYPE REF TO Lcl_excel_worksheet,
      o_document     TYPE REF TO if_ixml_document,
      o_element_root TYPE REF TO if_ixml_element,
      v_active       TYPE flag,
      v_relation_id  TYPE i VALUE 0.
    METHODS:
      add_sheetpr,
      add_dimension                   RAISING Lcx_excel,
      add_sheet_views                 RAISING Lcx_excel,
      add_sheetformatpr               RAISING Lcx_excel,
      add_cols                        RAISING Lcx_excel,
      add_sheet_protection,
      add_autofilter                  RAISING Lcx_excel,
      add_merge_cells                 RAISING Lcx_excel,
      add_conditional_formatting      RAISING Lcx_excel,
      add_data_validations,
      add_hyperlinks,
      add_print_options,
      add_page_margins,
      add_page_setup,
      add_header_footer,
      add_drawing,
      add_drawing_for_comments,
      add_drawing_for_header_footer,
      add_table_parts,
      add_sheet_data                  RAISING Lcx_excel,
      add_page_breaks,
      add_ignored_errors.
ENDCLASS.

CLASS SHRITEFUH64VYIPN5I4UIDBJAALSE4 IMPLEMENTATION.
  METHOD create.
    o_excel_ref    = io_excel_writer_2007.
    o_worksheet    = io_worksheet.
    o_document     = io_document.
    v_active       = iv_active.
    o_element_root = o_document->get_root_element( ).

    add_sheetpr( ).
    " dimension node
    add_dimension( ).
    " sheetViews node
    add_sheet_views( ).
    add_sheetformatpr( ).
    add_cols( ).
*--------------------------------------------------------------------*
* Sheet content - use own method to create this
*--------------------------------------------------------------------*
    add_sheet_data( ).
    add_sheet_protection( ).
    add_autofilter( ).
    " Merged cells
    add_merge_cells(  ).
    " Conditional formatting node
    add_conditional_formatting( ).
    add_data_validations( ).
    " Hyperlinks
    add_hyperlinks( ).
    " PrintOptions
    add_print_options( ).
    " pageMargins node
    add_page_margins( ).
* pageSetup node
    add_page_setup( ).
* { headerFooter necessary?   >
    add_header_footer( ).
    add_page_breaks( ).
* drawing
    add_drawing( ).
    add_drawing_for_comments( ).
    add_drawing_for_header_footer( ).
* ignoredErrors
    add_ignored_errors( ).
    add_table_parts( ).
  ENDMETHOD.
  METHOD add_sheetpr.

    DATA:
      lo_element   TYPE REF TO if_ixml_element,
      lo_element_2 TYPE REF TO if_ixml_element,
      lv_value     TYPE string.

    " sheetPr
    lo_element = o_document->create_simple_element( name   = lc_xml_node_sheetpr
                                                    parent = o_document ).
    " TODO tabColor
    IF o_worksheet->tabcolor IS NOT INITIAL.
      lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_tabcolor
                                                        parent = lo_element ).
* Theme not supported yet - start with RGB
      lv_value = o_worksheet->tabcolor-rgb.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_tabcolor_rgb
                                      value = lv_value ).
    ENDIF.

    " outlinePr
    lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_outlinepr
                                                      parent = o_document ).

    lv_value = o_worksheet->Lif_excel_sheet_properties~summarybelow.
    CONDENSE lv_value.
    lo_element_2->set_attribute_ns( name  = lc_xml_attr_summarybelow
                                    value = lv_value ).

    lv_value = o_worksheet->Lif_excel_sheet_properties~summaryright.
    CONDENSE lv_value.
    lo_element_2->set_attribute_ns( name  = lc_xml_attr_summaryright
                                    value = lv_value ).

    lo_element->append_child( new_child = lo_element_2 ).

    IF o_worksheet->sheet_setup->fit_to_page IS NOT INITIAL.
      lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_pagesetuppr
                                                        parent = o_document ).
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_fittopage
                                      value = `1` ).
      lo_element->append_child( new_child = lo_element_2 ). " pageSetupPr node
    ENDIF.

    o_element_root->append_child( new_child = lo_element ).
  ENDMETHOD.
  METHOD add_dimension.
    DATA:
      lo_element TYPE REF TO if_ixml_element,
      lv_value   TYPE string.

    lo_element = o_document->create_simple_element( name   = lc_xml_node_dimension
                                                    parent = o_document ).
    lv_value = o_worksheet->get_dimension_range( ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_ref
                                  value = lv_value ).
    o_element_root->append_child( new_child = lo_element ).
  ENDMETHOD.
  METHOD add_sheet_views.
    DATA:
      lo_element   TYPE REF TO if_ixml_element,
      lo_element_2 TYPE REF TO if_ixml_element,
      lo_element_3 TYPE REF TO if_ixml_element.

    DATA: lv_value                    TYPE string,
          lv_freeze_cell_row          TYPE zexcel_cell_row,
          lv_freeze_cell_column       TYPE zexcel_cell_column,
          lv_freeze_cell_column_alpha TYPE zexcel_cell_column_alpha.


    lo_element = o_document->create_simple_element( name   = lc_xml_node_sheetviews
                                                    parent = o_document ).
    " sheetView node
    lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_sheetview
                                                      parent = o_document ).
    IF o_worksheet->Lif_excel_sheet_properties~show_zeros EQ abap_false.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_showzeros
                                      value = '0' ).
    ENDIF.
    IF   v_active = abap_true
      OR o_worksheet->Lif_excel_sheet_properties~selected EQ abap_true.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_tabselected
                                      value = '1' ).
    ELSE.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_tabselected
                                      value = '0' ).
    ENDIF.
    " Zoom scale
    IF o_worksheet->Lif_excel_sheet_properties~zoomscale GT 400.
      o_worksheet->Lif_excel_sheet_properties~zoomscale = 400.
    ELSEIF o_worksheet->Lif_excel_sheet_properties~zoomscale LT 10.
      o_worksheet->Lif_excel_sheet_properties~zoomscale = 10.
    ENDIF.
    lv_value = o_worksheet->Lif_excel_sheet_properties~zoomscale.
    CONDENSE lv_value.
    lo_element_2->set_attribute_ns( name  = lc_xml_attr_zoomscale
                                    value = lv_value ).
    IF o_worksheet->Lif_excel_sheet_properties~zoomscale_normal NE 0.
      IF o_worksheet->Lif_excel_sheet_properties~zoomscale_normal GT 400.
        o_worksheet->Lif_excel_sheet_properties~zoomscale_normal = 400.
      ELSEIF o_worksheet->Lif_excel_sheet_properties~zoomscale_normal LT 10.
        o_worksheet->Lif_excel_sheet_properties~zoomscale_normal = 10.
      ENDIF.
      lv_value = o_worksheet->Lif_excel_sheet_properties~zoomscale_normal.
      CONDENSE lv_value.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_zoomscalenormal
                                      value = lv_value ).
    ENDIF.
    IF o_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview NE 0.
      IF o_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview GT 400.
        o_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview = 400.
      ELSEIF o_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview LT 10.
        o_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview = 10.
      ENDIF.
      lv_value = o_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview.
      CONDENSE lv_value.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_zoomscalepageview
                                      value = lv_value ).
    ENDIF.
    IF o_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview NE 0.
      IF o_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview GT 400.
        o_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview = 400.
      ELSEIF o_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview LT 10.
        o_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview = 10.
      ENDIF.
      lv_value = o_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview.
      CONDENSE lv_value.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_zoomscalesheetview
                                      value = lv_value ).
    ENDIF.
    IF o_worksheet->Lif_excel_sheet_properties~get_right_to_left( ) EQ abap_true.
      lo_element_2->set_attribute_ns( name  = 'rightToLeft'
                                      value = '1' ).
    ENDIF.
    lo_element_2->set_attribute_ns( name  = lc_xml_attr_workbookviewid
                                    value = '0' ).
    " showGridLines attribute
    IF o_worksheet->show_gridlines = abap_true.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_showgridlines
                                      value = '1' ).
    ELSE.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_showgridlines
                                      value = '0' ).
    ENDIF.

    " showRowColHeaders attribute
    IF o_worksheet->show_rowcolheaders = abap_true.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_showrowcolheaders
                                      value = '1' ).
    ELSE.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_showrowcolheaders
                                      value = '0' ).
    ENDIF.

    " freeze panes
    o_worksheet->get_freeze_cell( IMPORTING ep_row    = lv_freeze_cell_row
                                            ep_column = lv_freeze_cell_column ).

    IF lv_freeze_cell_row IS NOT INITIAL AND lv_freeze_cell_column IS NOT INITIAL.
      lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_pane
                                                        parent = lo_element_2 ).

      IF lv_freeze_cell_row > 1.
        lv_value = lv_freeze_cell_row - 1.
        CONDENSE lv_value.
        lo_element_3->set_attribute_ns( name  = 'ySplit'
                                        value = lv_value ).
      ENDIF.

      IF lv_freeze_cell_column > 1.
        lv_value = lv_freeze_cell_column - 1.
        CONDENSE lv_value.
        lo_element_3->set_attribute_ns( name  = 'xSplit'
                                        value = lv_value ).
      ENDIF.

      lv_freeze_cell_column_alpha = Lcl_excel_common=>convert_column2alpha( ip_column = lv_freeze_cell_column ).
      lv_value = Lcl_excel_common=>number_to_excel_string( ip_value = lv_freeze_cell_row ).
      CONCATENATE lv_freeze_cell_column_alpha lv_value INTO lv_value.
      lo_element_3->set_attribute_ns( name  = 'topLeftCell'
                                      value = lv_value ).

      lo_element_3->set_attribute_ns( name  = 'activePane'
                                      value = 'bottomRight' ).

      lo_element_3->set_attribute_ns( name  = 'state'
                                      value = 'frozen' ).

      lo_element_2->append_child( new_child = lo_element_3 ).
    ENDIF.
    " selection node
    lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_selection
                                                      parent = o_document ).
    lv_value = o_worksheet->get_active_cell( ).
    lo_element_3->set_attribute_ns( name  = lc_xml_attr_activecell
                                    value = lv_value ).

    lo_element_3->set_attribute_ns( name  = lc_xml_attr_sqref
                                    value = lv_value ).

    lo_element_2->append_child( new_child = lo_element_3 ). " sheetView node

    lo_element->append_child( new_child = lo_element_2 ). " sheetView node

    o_element_root->append_child( new_child = lo_element ). " sheetViews node
  ENDMETHOD.

  METHOD add_sheetformatpr.
    DATA: lo_element         TYPE REF TO if_ixml_element,
          lo_column_default  TYPE REF TO Lcl_excel_column,
          lo_row_default     TYPE REF TO Lcl_excel_row,lv_value           TYPE string,
          lo_column_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_column          TYPE REF TO Lcl_excel_column,
          lo_row_iterator    TYPE REF TO Lcl_excel_collection_iterator,
          outline_level_col  TYPE i VALUE 0.

    lo_column_iterator = o_worksheet->get_columns_iterator( ).
    lo_row_iterator = o_worksheet->get_rows_iterator( ).
    " Calculate col
    IF NOT lo_column_iterator IS BOUND.
      o_worksheet->calculate_column_widths( ).
      lo_column_iterator = o_worksheet->get_columns_iterator( ).
    ENDIF.

    " sheetFormatPr node
    lo_element = o_document->create_simple_element( name   = lc_xml_node_sheetformatpr
                                                    parent = o_document ).
    " defaultRowHeight
    lo_row_default = o_worksheet->get_default_row( ).
    IF lo_row_default IS BOUND.
      IF lo_row_default->get_row_height( ) >= 0.
        lo_element->set_attribute_ns( name  = lc_xml_attr_customheight
                                      value = lc_xml_attr_true ).
        lv_value = lo_row_default->get_row_height( ).
      ELSE.
        lv_value = '12.75'.
      ENDIF.
    ELSE.
      lv_value = '12.75'.
    ENDIF.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_element->set_attribute_ns( name  = lc_xml_attr_defaultrowheight
                                  value = lv_value ).
    " defaultColWidth
    lo_column_default = o_worksheet->get_default_column( ).
    IF lo_column_default IS BOUND AND lo_column_default->get_width( ) >= 0.
      lv_value = lo_column_default->get_width( ).
      SHIFT lv_value RIGHT DELETING TRAILING space.
      SHIFT lv_value LEFT DELETING LEADING space.
      lo_element->set_attribute_ns( name  = lc_xml_attr_defaultcolwidth
                                    value = lv_value ).
    ENDIF.

    " outlineLevelCol
    WHILE lo_column_iterator->has_next( ) = abap_true.
      lo_column ?= lo_column_iterator->get_next( ).
      IF lo_column->get_outline_level( ) > outline_level_col.
        outline_level_col = lo_column->get_outline_level( ).
      ENDIF.
    ENDWHILE.

    lv_value = outline_level_col.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_element->set_attribute_ns( name  = lc_xml_attr_outlinelevelcol
                                  value = lv_value ).

    o_element_root->append_child( new_child = lo_element ). " sheetFormatPr node
  ENDMETHOD.

  METHOD add_cols.
    DATA: lo_element         TYPE REF TO if_ixml_element,
          lo_element_2       TYPE REF TO if_ixml_element,
          lo_column_default  TYPE REF TO Lcl_excel_column,
          lv_value           TYPE string,
          lv_column          TYPE zexcel_cell_column,
          lv_style_guid      TYPE zexcel_cell_style,
          ls_style_mapping   TYPE zexcel_s_styles_mapping,
          lo_column_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_column          TYPE REF TO Lcl_excel_column.

* Reset column iterator
    lo_column_iterator = o_worksheet->get_columns_iterator( ).
    lo_column_default = o_worksheet->get_default_column( ).
    IF o_worksheet->Lif_excel_sheet_properties~get_style( ) IS NOT INITIAL OR lo_column_iterator->has_next( ) = abap_true.
      " cols node
      lo_element = o_document->create_simple_element( name   = lc_xml_node_cols
                                                      parent = o_document ).
      " This code have to be enhanced in order to manage also column style properties
      " Now it is an out/out
      IF lo_column_iterator->has_next( ) = abap_true.
        WHILE lo_column_iterator->has_next( ) = abap_true.
          lo_column ?= lo_column_iterator->get_next( ).
          " col node
          lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_col
                                                            parent = o_document ).
          lv_value = lo_column->get_column_index( ).
          SHIFT lv_value RIGHT DELETING TRAILING space.
          SHIFT lv_value LEFT DELETING LEADING space.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_min
                                          value = lv_value ).
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_max
                                          value = lv_value ).
          " Width
          IF lo_column->get_width( ) < 0.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_width
                                            value = lc_xml_attr_defaultwidth ).
          ELSE.
            lv_value = lo_column->get_width( ).
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_width
                                            value = lv_value ).
          ENDIF.
          " Column visibility
          IF lo_column->get_visible( ) = abap_false.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_hidden
                                            value = lc_xml_attr_true ).
          ENDIF.
          "  Auto size?
          IF lo_column->get_auto_size( ) = abap_true.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_bestfit
                                            value = lc_xml_attr_true ).
          ENDIF.
          " Custom width?
          IF lo_column_default IS BOUND.
            IF lo_column->get_width( ) <> lo_column_default->get_width( ).
              lo_element_2->set_attribute_ns( name  = lc_xml_attr_customwidth
                                              value = lc_xml_attr_true ).

            ENDIF.
          ELSE.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_customwidth
                                            value = lc_xml_attr_true ).
          ENDIF.
          " Collapsed
          IF lo_column->get_collapsed( ) = abap_true.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_collapsed
                                            value = lc_xml_attr_true ).
          ENDIF.
          " outlineLevel
          IF lo_column->get_outline_level( ) > 0.
            lv_value = lo_column->get_outline_level( ).

            SHIFT lv_value RIGHT DELETING TRAILING space.
            SHIFT lv_value LEFT DELETING LEADING space.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_outlinelevel
                                            value = lv_value ).
          ENDIF.
          " Style
          lv_style_guid = lo_column->get_column_style_guid( ).                      "ins issue #157 -  set column style
          CLEAR ls_style_mapping.
          READ TABLE o_excel_ref->styles_mapping INTO ls_style_mapping WITH KEY guid = lv_style_guid.
          IF sy-subrc = 0.                                                                                     "ins issue #295
            lv_value = ls_style_mapping-style.                                                                 "ins issue #295
            SHIFT lv_value RIGHT DELETING TRAILING space.
            SHIFT lv_value LEFT DELETING LEADING space.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_style
                                            value = lv_value ).
          ENDIF.                                                                                              "ins issue #237

          lo_element->append_child( new_child = lo_element_2 ). " col node
        ENDWHILE.

      ENDIF.
* Always pass through this coding
      IF o_worksheet->Lif_excel_sheet_properties~get_style( ) IS NOT INITIAL.
        DATA: lts_sorted_columns TYPE SORTED TABLE OF zexcel_cell_column WITH UNIQUE KEY table_line.
        TYPES: BEGIN OF ty_missing_columns,
                 first_column TYPE zexcel_cell_column,
                 last_column  TYPE zexcel_cell_column,
               END OF ty_missing_columns.
        DATA: t_missing_columns TYPE STANDARD TABLE OF ty_missing_columns WITH NON-UNIQUE DEFAULT KEY,
              missing_column    LIKE LINE OF t_missing_columns.

* First collect columns that were already handled before.  The rest has to be inserted now
        lo_column_iterator = o_worksheet->get_columns_iterator( ).
        WHILE lo_column_iterator->has_next( ) = abap_true.
          lo_column ?= lo_column_iterator->get_next( ).
          lv_column = Lcl_excel_common=>convert_column2int( lo_column->get_column_index( ) ).
          INSERT lv_column INTO TABLE lts_sorted_columns.
        ENDWHILE.

* Now find all columns that were missing so far
        missing_column-first_column = 1.
        LOOP AT lts_sorted_columns INTO lv_column.
          IF lv_column > missing_column-first_column.
            missing_column-last_column = lv_column - 1.
            APPEND missing_column TO t_missing_columns.
          ENDIF.
          missing_column-first_column = lv_column + 1.
        ENDLOOP.
        missing_column-last_column = Lcl_excel_common=>c_excel_sheet_max_col.
        APPEND missing_column TO t_missing_columns.
* Now apply stylesetting ( and other defaults - I copy it from above.  Whoever programmed that seems to know what to do  :o)
        LOOP AT t_missing_columns INTO missing_column.
* End of insertion issue #157 -  set column style
          lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_col
                                                            parent = o_document ).
          lv_value = missing_column-first_column.             "ins issue #157  -  set sheet style ( add missing columns
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_min
                                          value = lv_value ).
*        lv_value = Lcl_excel_common=>c_excel_sheet_max_col."del issue #157  -  set sheet style ( add missing columns
          lv_value = missing_column-last_column.              "ins issue #157  -  set sheet style ( add missing columns
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_max
                                          value = lv_value ).
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_width
                                          value = lc_xml_attr_defaultwidth ).
          lv_style_guid = o_worksheet->Lif_excel_sheet_properties~get_style( ).
          READ TABLE o_excel_ref->styles_mapping INTO ls_style_mapping WITH KEY guid = lv_style_guid.
          lv_value = ls_style_mapping-style.
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_style
                                          value = lv_value ).
          lo_element->append_child( new_child = lo_element_2 ). " col node
        ENDLOOP.      "ins issue #157  -  set sheet style ( add missing columns

      ENDIF.
*--------------------------------------------------------------------*
* issue #367 add feature hide columns from
*--------------------------------------------------------------------*
      IF o_worksheet->Lif_excel_sheet_properties~hide_columns_from IS NOT INITIAL.
        lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_col
                                                          parent = o_document ).
        lv_value = Lcl_excel_common=>convert_column2int( o_worksheet->Lif_excel_sheet_properties~hide_columns_from ).
        CONDENSE lv_value NO-GAPS.
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_min
                                        value = lv_value ).
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_max
                                        value = '16384' ).
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_hidden
                                        value = '1' ).
        lo_element->append_child( new_child = lo_element_2 ). " col node
      ENDIF.

      o_element_root->append_child( new_child = lo_element ). " cols node
    ENDIF.
  ENDMETHOD.

  METHOD add_sheet_protection.
    DATA:
      lo_element TYPE REF TO if_ixml_element,
      lv_value   TYPE string.

*< Begin of insertion Issue #572 - Protect sheet with filter caused Excel error
* Autofilter must be set AFTER sheet protection in XML
    IF o_worksheet->Lif_excel_sheet_protection~protected EQ abap_true.
      " sheetProtection node
      lo_element = o_document->create_simple_element( name   = lc_xml_node_sheetprotection
                                                      parent = o_document ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~password.
      IF lv_value IS NOT INITIAL.
        lo_element->set_attribute_ns( name  = lc_xml_attr_password
                                      value = lv_value ).
      ENDIF.
      lv_value = o_worksheet->Lif_excel_sheet_protection~auto_filter.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_autofilter
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~delete_columns.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_deletecolumns
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~delete_rows.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_deleterows
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~format_cells.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_formatcells
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~format_columns.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_formatcolumns
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~format_rows.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_formatrows
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~insert_columns.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_insertcolumns
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~insert_hyperlinks.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_inserthyperlinks
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~insert_rows.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_insertrows
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~objects.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_objects
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~pivot_tables.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_pivottables
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~scenarios.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_scenarios
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~select_locked_cells.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_selectlockedcells
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~select_unlocked_cells.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_selectunlockedcell
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~sheet.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_sheet
                                    value = lv_value ).
      lv_value = o_worksheet->Lif_excel_sheet_protection~sort.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_sort
                                    value = lv_value ).

      o_element_root->append_child( new_child = lo_element ).
    ENDIF.
*> End of insertion Issue #572 - Protect sheet with filter caused Excel error
  ENDMETHOD.

  METHOD add_autofilter.
    DATA:
      lo_element     TYPE REF TO if_ixml_element,
      lo_element_2   TYPE REF TO if_ixml_element,
      lo_element_3   TYPE REF TO if_ixml_element,
      lo_element_4   TYPE REF TO if_ixml_element,
      lv_value       TYPE string,
      lv_column      TYPE zexcel_cell_column,
      lt_values      TYPE zexcel_t_autofilter_values,
      ls_values      TYPE zexcel_s_autofilter_values,
      lo_autofilters TYPE REF TO Lcl_excel_autofilters,
      lo_autofilter  TYPE REF TO Lcl_excel_autofilter,
      lv_ref         TYPE string.

    lo_autofilters = o_excel_ref->excel->get_autofilters_reference( ).
    lo_autofilter = lo_autofilters->get( io_worksheet = o_worksheet ) .

    IF lo_autofilter IS BOUND.
* Create node autofilter
      lo_element = o_document->create_simple_element( name   = lc_xml_node_autofilter
                                                      parent = o_document ).
      lv_ref = lo_autofilter->get_filter_range( ) .
      CONDENSE lv_ref NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_ref
                                    value = lv_ref ).
      lt_values = lo_autofilter->get_values( ) .
      IF lt_values IS NOT INITIAL.
* If we filter we need to set the filter mode to 1.
        lo_element_2 = o_document->find_from_name( name = lc_xml_node_sheetpr ).
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_filtermode
                                        value = '1' ).
* Create node filtercolumn
        CLEAR lv_column.
        LOOP AT lt_values INTO ls_values.
          IF ls_values-column <> lv_column.
            IF lv_column IS NOT INITIAL.
              lo_element_2->append_child( new_child = lo_element_3 ).
              lo_element->append_child( new_child = lo_element_2 ).
            ENDIF.
            lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_filtercolumn
                                                              parent = lo_element ).
            lv_column   = ls_values-column - lo_autofilter->filter_area-col_start.
            lv_value = lv_column.
            CONDENSE lv_value NO-GAPS.
            lo_element_2->set_attribute_ns( name  = lc_xml_attr_colid
                                            value = lv_value ).
            lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_filters
                                                              parent = lo_element_2 ).
            lv_column = ls_values-column.
          ENDIF.
          lo_element_4 = o_document->create_simple_element( name   = lc_xml_node_filter
                                                            parent = lo_element_3 ).
          lo_element_4->set_attribute_ns( name  = lc_xml_attr_val
                                          value = ls_values-value ).
          lo_element_3->append_child( new_child = lo_element_4 ). " value node
        ENDLOOP.
        lo_element_2->append_child( new_child = lo_element_3 ).
        lo_element->append_child( new_child = lo_element_2 ).
      ENDIF.
      o_element_root->append_child( new_child = lo_element ).
    ENDIF.
  ENDMETHOD.

  METHOD add_merge_cells.
    DATA:
      lo_element     TYPE REF TO if_ixml_element,
      lo_element_2   TYPE REF TO if_ixml_element,
      lv_value       TYPE string,
      lt_range_merge TYPE string_table,
      merge_count    TYPE int4.

    FIELD-SYMBOLS: <fs_range_merge>         LIKE LINE OF lt_range_merge.

    lt_range_merge = o_worksheet->get_merge( ).
    IF lt_range_merge IS NOT INITIAL.
      lo_element = o_document->create_simple_element( name   = lc_xml_node_mergecells
                                                      parent = o_document ).
      DESCRIBE TABLE lt_range_merge LINES merge_count.
      lv_value = merge_count.
      CONDENSE lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_count
                                    value = lv_value ).
      LOOP AT lt_range_merge ASSIGNING <fs_range_merge>.
        lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_mergecell
                                                          parent = o_document ).

        lo_element_2->set_attribute_ns( name  = lc_xml_attr_ref
                                        value = <fs_range_merge> ).
        lo_element->append_child( new_child = lo_element_2 ).
        o_element_root->append_child( new_child = lo_element ).
        o_worksheet->delete_merge( ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.

  METHOD add_conditional_formatting.
    DATA: lo_element               TYPE REF TO if_ixml_element,
          lo_element_2             TYPE REF TO if_ixml_element,
          lo_element_3             TYPE REF TO if_ixml_element,
          lo_element_4             TYPE REF TO if_ixml_element,
          lo_iterator              TYPE REF TO Lcl_excel_collection_iterator,
          lo_style_cond            TYPE REF TO Lcl_excel_style_cond,
          lv_value                 TYPE string,
          ls_databar               TYPE zexcel_conditional_databar,      " Databar by Albert Lladanosa
          ls_colorscale            TYPE zexcel_conditional_colorscale,
          ls_iconset               TYPE zexcel_conditional_iconset,
          ls_cellis                TYPE zexcel_conditional_cellis,
          ls_textfunction          TYPE Lcl_excel_style_cond=>ts_conditional_textfunction,
          lv_column_start          TYPE zexcel_cell_column_alpha,
          lv_row_start             TYPE zexcel_cell_row,
          lv_cell_coords           TYPE zexcel_cell_coords,
          ls_expression            TYPE zexcel_conditional_expression,
          ls_conditional_top10     TYPE zexcel_conditional_top10,
          ls_conditional_above_avg TYPE zexcel_conditional_above_avg,
          lt_cfvo                  TYPE TABLE OF cfvo,
          ls_cfvo                  TYPE cfvo,
          lt_colors                TYPE TABLE OF colors,
          ls_colors                TYPE colors,
          ls_style_cond_mapping    TYPE zexcel_s_styles_cond_mapping,
          lt_condformating_ranges  TYPE ty_condformating_ranges,
          ls_condformating_range   TYPE ty_condformating_range.

    FIELD-SYMBOLS: <ls_condformating_range> TYPE ty_condformating_range.

    lo_iterator = o_worksheet->get_style_cond_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_style_cond ?= lo_iterator->get_next( ).
      IF lo_style_cond->rule IS INITIAL.
        CONTINUE.
      ENDIF.

      lv_value = lo_style_cond->get_dimension_range( ).

      READ TABLE lt_condformating_ranges WITH KEY dimension_range = lv_value ASSIGNING <ls_condformating_range>.
      IF sy-subrc = 0.
        lo_element = <ls_condformating_range>-condformatting_node.
      ELSE.
        lo_element = o_document->create_simple_element( name   = lc_xml_node_condformatting
                                                        parent = o_document ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_sqref
                                      value = lv_value ).

        ls_condformating_range-dimension_range = lv_value.
        ls_condformating_range-condformatting_node = lo_element.
        INSERT ls_condformating_range INTO TABLE lt_condformating_ranges.

      ENDIF.

      " cfRule node
      lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_cfrule
                                                        parent = o_document ).
      IF lo_style_cond->rule = Lcl_excel_style_cond=>c_rule_textfunction.
        IF lo_style_cond->mode_textfunction-textfunction = Lcl_excel_style_cond=>c_textfunction_notcontains.
          lv_value = `notContainsText`.
        ELSE.
          lv_value = lo_style_cond->mode_textfunction-textfunction.
        ENDIF.
      ELSE.
        lv_value = lo_style_cond->rule.
      ENDIF.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_type
                                      value = lv_value ).
      lv_value = lo_style_cond->priority.
      SHIFT lv_value RIGHT DELETING TRAILING space.
      SHIFT lv_value LEFT DELETING LEADING space.
      lo_element_2->set_attribute_ns( name  = lc_xml_attr_priority
                                      value = lv_value ).

      CASE lo_style_cond->rule.
          " Start >> Databar by Albert Lladanosa
        WHEN Lcl_excel_style_cond=>c_rule_databar.

          ls_databar = lo_style_cond->mode_databar.

          CLEAR lt_cfvo.
          lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_databar
                                                            parent = o_document ).

          ls_cfvo-value = ls_databar-cfvo1_value.
          ls_cfvo-type = ls_databar-cfvo1_type.
          APPEND ls_cfvo TO lt_cfvo.

          ls_cfvo-value = ls_databar-cfvo2_value.
          ls_cfvo-type = ls_databar-cfvo2_type.
          APPEND ls_cfvo TO lt_cfvo.

          LOOP AT lt_cfvo INTO ls_cfvo.
            " cfvo node
            lo_element_4 = o_document->create_simple_element( name   = lc_xml_node_cfvo
                                                              parent = o_document ).
            lv_value = ls_cfvo-type.
            lo_element_4->set_attribute_ns( name  = lc_xml_attr_type
                                            value = lv_value ).
            lv_value = ls_cfvo-value.
            lo_element_4->set_attribute_ns( name  = lc_xml_attr_val
                                            value = lv_value ).
            lo_element_3->append_child( new_child = lo_element_4 ). " cfvo node
          ENDLOOP.

          lo_element_4 = o_document->create_simple_element( name   = lc_xml_node_color
                                                            parent = o_document ).
          lv_value = ls_databar-colorrgb.
          lo_element_4->set_attribute_ns( name  = lc_xml_attr_tabcolor_rgb
                                          value = lv_value ).

          lo_element_3->append_child( new_child = lo_element_4 ). " color node

          lo_element_2->append_child( new_child = lo_element_3 ). " databar node
          " End << Databar by Albert Lladanosa

        WHEN Lcl_excel_style_cond=>c_rule_colorscale.

          ls_colorscale = lo_style_cond->mode_colorscale.

          CLEAR: lt_cfvo, lt_colors.
          lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_colorscale
                                                            parent = o_document ).

          ls_cfvo-value = ls_colorscale-cfvo1_value.
          ls_cfvo-type = ls_colorscale-cfvo1_type.
          APPEND ls_cfvo TO lt_cfvo.

          ls_cfvo-value = ls_colorscale-cfvo2_value.
          ls_cfvo-type = ls_colorscale-cfvo2_type.
          APPEND ls_cfvo TO lt_cfvo.

          ls_cfvo-value = ls_colorscale-cfvo3_value.
          ls_cfvo-type = ls_colorscale-cfvo3_type.
          APPEND ls_cfvo TO lt_cfvo.

          APPEND ls_colorscale-colorrgb1 TO lt_colors.
          APPEND ls_colorscale-colorrgb2 TO lt_colors.
          APPEND ls_colorscale-colorrgb3 TO lt_colors.

          LOOP AT lt_cfvo INTO ls_cfvo.

            IF ls_cfvo IS INITIAL.
              CONTINUE.
            ENDIF.

            " cfvo node
            lo_element_4 = o_document->create_simple_element( name   = lc_xml_node_cfvo
                                                              parent = o_document ).
            lv_value = ls_cfvo-type.
            lo_element_4->set_attribute_ns( name  = lc_xml_attr_type
                                            value = lv_value ).
            lv_value = ls_cfvo-value.
            lo_element_4->set_attribute_ns( name  = lc_xml_attr_val
                                            value = lv_value ).
            lo_element_3->append_child( new_child = lo_element_4 ). " cfvo node
          ENDLOOP.
          LOOP AT lt_colors INTO ls_colors.

            IF ls_colors IS INITIAL.
              CONTINUE.
            ENDIF.

            lo_element_4 = o_document->create_simple_element( name   = lc_xml_node_color
                                                              parent = o_document ).
            lv_value = ls_colors-colorrgb.
            lo_element_4->set_attribute_ns( name  = lc_xml_attr_tabcolor_rgb
                                            value = lv_value ).

            lo_element_3->append_child( new_child = lo_element_4 ). " color node
          ENDLOOP.

          lo_element_2->append_child( new_child = lo_element_3 ). " databar node

        WHEN Lcl_excel_style_cond=>c_rule_iconset.

          ls_iconset = lo_style_cond->mode_iconset.

          CLEAR lt_cfvo.
          " iconset node
          lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_iconset
                                                            parent = o_document ).
          IF ls_iconset-iconset NE Lcl_excel_style_cond=>c_iconset_3trafficlights.
            lv_value = ls_iconset-iconset.
            lo_element_3->set_attribute_ns( name  = lc_xml_attr_iconset
                                            value = lv_value ).
          ENDIF.

          " Set the showValue attribute
          lv_value = ls_iconset-showvalue.
          lo_element_3->set_attribute_ns( name  = lc_xml_attr_showvalue
                                          value = lv_value ).

          CASE ls_iconset-iconset.
            WHEN Lcl_excel_style_cond=>c_iconset_3trafficlights2 OR
                 Lcl_excel_style_cond=>c_iconset_3arrows OR
                 Lcl_excel_style_cond=>c_iconset_3arrowsgray OR
                 Lcl_excel_style_cond=>c_iconset_3flags OR
                 Lcl_excel_style_cond=>c_iconset_3signs OR
                 Lcl_excel_style_cond=>c_iconset_3symbols OR
                 Lcl_excel_style_cond=>c_iconset_3symbols2 OR
                 Lcl_excel_style_cond=>c_iconset_3trafficlights OR
                 Lcl_excel_style_cond=>c_iconset_3trafficlights2.
              ls_cfvo-value = ls_iconset-cfvo1_value.
              ls_cfvo-type = ls_iconset-cfvo1_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo2_value.
              ls_cfvo-type = ls_iconset-cfvo2_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo3_value.
              ls_cfvo-type = ls_iconset-cfvo3_type.
              APPEND ls_cfvo TO lt_cfvo.
            WHEN Lcl_excel_style_cond=>c_iconset_4arrows OR
                 Lcl_excel_style_cond=>c_iconset_4arrowsgray OR
                 Lcl_excel_style_cond=>c_iconset_4rating OR
                 Lcl_excel_style_cond=>c_iconset_4redtoblack OR
                 Lcl_excel_style_cond=>c_iconset_4trafficlights.
              ls_cfvo-value = ls_iconset-cfvo1_value.
              ls_cfvo-type = ls_iconset-cfvo1_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo2_value.
              ls_cfvo-type = ls_iconset-cfvo2_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo3_value.
              ls_cfvo-type = ls_iconset-cfvo3_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo4_value.
              ls_cfvo-type = ls_iconset-cfvo4_type.
              APPEND ls_cfvo TO lt_cfvo.
            WHEN Lcl_excel_style_cond=>c_iconset_5arrows OR
                 Lcl_excel_style_cond=>c_iconset_5arrowsgray OR
                 Lcl_excel_style_cond=>c_iconset_5quarters OR
                 Lcl_excel_style_cond=>c_iconset_5rating.
              ls_cfvo-value = ls_iconset-cfvo1_value.
              ls_cfvo-type = ls_iconset-cfvo1_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo2_value.
              ls_cfvo-type = ls_iconset-cfvo2_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo3_value.
              ls_cfvo-type = ls_iconset-cfvo3_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo4_value.
              ls_cfvo-type = ls_iconset-cfvo4_type.
              APPEND ls_cfvo TO lt_cfvo.
              ls_cfvo-value = ls_iconset-cfvo5_value.
              ls_cfvo-type = ls_iconset-cfvo5_type.
              APPEND ls_cfvo TO lt_cfvo.
            WHEN OTHERS.
              CLEAR lt_cfvo.
          ENDCASE.

          LOOP AT lt_cfvo INTO ls_cfvo.
            " cfvo node
            lo_element_4 = o_document->create_simple_element( name   = lc_xml_node_cfvo
                                                              parent = o_document ).
            lv_value = ls_cfvo-type.
            lo_element_4->set_attribute_ns( name  = lc_xml_attr_type
                                            value = lv_value ).
            lv_value = ls_cfvo-value.
            lo_element_4->set_attribute_ns( name  = lc_xml_attr_val
                                            value = lv_value ).
            lo_element_3->append_child( new_child = lo_element_4 ). " cfvo node
          ENDLOOP.


          lo_element_2->append_child( new_child = lo_element_3 ). " iconset node

        WHEN Lcl_excel_style_cond=>c_rule_cellis.
          ls_cellis = lo_style_cond->mode_cellis.
          READ TABLE o_excel_ref->styles_cond_mapping INTO ls_style_cond_mapping WITH KEY guid = ls_cellis-cell_style.
          lv_value = ls_style_cond_mapping-dxf.
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_dxfid
                                          value = lv_value ).
          lv_value = ls_cellis-operator.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_operator
                                          value = lv_value ).
          " formula node
          lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_formula
                                                            parent = o_document ).
          lv_value = ls_cellis-formula.
          lo_element_3->set_value( value = lv_value ).
          lo_element_2->append_child( new_child = lo_element_3 ). " formula node
          IF ls_cellis-formula2 IS NOT INITIAL.
            lv_value = ls_cellis-formula2.
            lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_formula
                                                              parent = o_document ).
            lo_element_3->set_value( value = lv_value ).
            lo_element_2->append_child( new_child = lo_element_3 ). " 2nd formula node
          ENDIF.
*--------------------------------------------------------------------------------------*
* The below code creates an EXM structure in the following format:
* -<conditionalFormatting sqref="G6:G12">-
*   <cfRule operator="beginsWith" priority="4" dxfId="4" type="beginsWith" text="1">
*     <formula>LEFT(G6,LEN("1"))="1"</formula>
*   </cfRule>
* </conditionalFormatting>
*--------------------------------------------------------------------------------------*
        WHEN Lcl_excel_style_cond=>c_rule_textfunction.
          ls_textfunction = lo_style_cond->mode_textfunction.
          READ TABLE o_excel_ref->styles_cond_mapping INTO ls_style_cond_mapping WITH KEY guid = ls_cellis-cell_style.
          lv_value = ls_style_cond_mapping-dxf.
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_dxfid
                                          value = lv_value ).
          lv_value = ls_textfunction-textfunction.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_operator
                                          value = lv_value ).

          " text
          lv_value = ls_textfunction-text.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_text
                                          value = lv_value ).

          " formula node
          Lcl_excel_common=>convert_range2column_a_row(
            EXPORTING
              i_range        = lo_style_cond->get_dimension_range( )
            IMPORTING
              e_column_start = lv_column_start
              e_row_start    = lv_row_start ).
          lv_cell_coords = |{ lv_column_start }{ lv_row_start }|.
          CASE ls_textfunction-textfunction.
            WHEN Lcl_excel_style_cond=>c_textfunction_beginswith.
              lv_value = |LEFT({ lv_cell_coords },LEN("{ escape( val = ls_textfunction-text format = cl_abap_format=>e_html_text ) }"))=|
                      && |"{ escape( val = ls_textfunction-text format = cl_abap_format=>e_html_text ) }"|.
            WHEN Lcl_excel_style_cond=>c_textfunction_containstext.
              lv_value = |NOT(ISERROR(SEARCH("{ escape( val = ls_textfunction-text format = cl_abap_format=>e_html_text ) }",{ lv_cell_coords })))|.
            WHEN Lcl_excel_style_cond=>c_textfunction_endswith.
              lv_value = |RIGHT({ lv_cell_coords },LEN("{ escape( val = ls_textfunction-text format = cl_abap_format=>e_html_text ) }"))=|
                      && |"{ escape( val = ls_textfunction-text format = cl_abap_format=>e_html_text ) }"|.
            WHEN Lcl_excel_style_cond=>c_textfunction_notcontains.
              lv_value = |ISERROR(SEARCH("{ escape( val = ls_textfunction-text format = cl_abap_format=>e_html_text ) }",{ lv_cell_coords }))|.
            WHEN OTHERS.
          ENDCASE.
          lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_formula
                                                            parent = o_document ).
          lo_element_3->set_value( value = lv_value ).
          lo_element_2->append_child( new_child = lo_element_3 ). " formula node

        WHEN Lcl_excel_style_cond=>c_rule_expression.
          ls_expression = lo_style_cond->mode_expression.
          READ TABLE o_excel_ref->styles_cond_mapping INTO ls_style_cond_mapping WITH KEY guid = ls_expression-cell_style.
          lv_value = ls_style_cond_mapping-dxf.
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_dxfid
                                          value = lv_value ).
          " formula node
          lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_formula
                                                            parent = o_document ).
          lv_value = ls_expression-formula.
          lo_element_3->set_value( value = lv_value ).
          lo_element_2->append_child( new_child = lo_element_3 ). " formula node

* begin of ins issue #366 - missing conditional rules: top10
        WHEN Lcl_excel_style_cond=>c_rule_top10.
          ls_conditional_top10 = lo_style_cond->mode_top10.
          READ TABLE o_excel_ref->styles_cond_mapping INTO ls_style_cond_mapping WITH KEY guid = ls_conditional_top10-cell_style.
          lv_value = ls_style_cond_mapping-dxf.
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_dxfid
                                          value = lv_value ).
          lv_value = ls_conditional_top10-topxx_count.
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = 'rank'
                                          value = lv_value ).
          IF ls_conditional_top10-bottom = 'X'.
            lo_element_2->set_attribute_ns( name  = 'bottom'
                                            value = '1' ).
          ENDIF.
          IF ls_conditional_top10-percent = 'X'.
            lo_element_2->set_attribute_ns( name  = 'percent'
                                            value = '1' ).
          ENDIF.

        WHEN Lcl_excel_style_cond=>c_rule_above_average.
          ls_conditional_above_avg = lo_style_cond->mode_above_average.
          READ TABLE o_excel_ref->styles_cond_mapping INTO ls_style_cond_mapping WITH KEY guid = ls_conditional_above_avg-cell_style.
          lv_value = ls_style_cond_mapping-dxf.
          CONDENSE lv_value.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_dxfid
                                          value = lv_value ).

          IF ls_conditional_above_avg-above_average IS INITIAL. " = below average
            lo_element_2->set_attribute_ns( name  = 'aboveAverage'
                                            value = '0' ).
          ENDIF.
          IF ls_conditional_above_avg-equal_average = 'X'. " = equal average also
            lo_element_2->set_attribute_ns( name  = 'equalAverage'
                                            value = '1' ).
          ENDIF.
          IF ls_conditional_above_avg-standard_deviation <> 0. " standard deviation instead of value
            lv_value = ls_conditional_above_avg-standard_deviation.
            lo_element_2->set_attribute_ns( name  = 'stdDev'
                                            value = lv_value ).
          ENDIF.

* end of ins issue #366 - missing conditional rules: top10

      ENDCASE.

      lo_element->append_child( new_child = lo_element_2 ). " cfRule node

      o_element_root->append_child( new_child = lo_element ). " Conditional formatting node
    ENDWHILE.
  ENDMETHOD.

  METHOD add_data_validations.
    DATA: lo_element         TYPE REF TO if_ixml_element,
          lo_element_2       TYPE REF TO if_ixml_element,
          lo_element_3       TYPE REF TO if_ixml_element,
          lo_iterator        TYPE REF TO Lcl_excel_collection_iterator,
          lo_data_validation TYPE REF TO Lcl_excel_data_validation,
          lv_value           TYPE string,
          lv_cell_row_s      TYPE string.

    IF o_worksheet->get_data_validations_size( ) GT 0.
      " dataValidations node
      lo_element = o_document->create_simple_element( name   = lc_xml_node_datavalidations
                                                      parent = o_document ).
      " Conditional formatting node
      lo_iterator = o_worksheet->get_data_validations_iterator( ).
      WHILE lo_iterator->has_next( ) EQ abap_true.
        lo_data_validation ?= lo_iterator->get_next( ).
        " dataValidation node
        lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_datavalidation
                                                          parent = o_document ).
        lv_value = lo_data_validation->type.
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_type
                                        value = lv_value ).
        IF NOT lo_data_validation->operator IS INITIAL.
          lv_value = lo_data_validation->operator.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_operator
                                          value = lv_value ).
        ENDIF.
        IF lo_data_validation->allowblank EQ abap_true.
          lv_value = '1'.
        ELSE.
          lv_value = '0'.
        ENDIF.
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_allowblank
                                        value = lv_value ).
        IF lo_data_validation->showinputmessage EQ abap_true.
          lv_value = '1'.
        ELSE.
          lv_value = '0'.
        ENDIF.
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_showinputmessage
                                        value = lv_value ).
        IF lo_data_validation->showerrormessage EQ abap_true.
          lv_value = '1'.
        ELSE.
          lv_value = '0'.
        ENDIF.
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_showerrormessage
                                        value = lv_value ).
        IF lo_data_validation->showdropdown EQ abap_true.
          lv_value = '1'.
        ELSE.
          lv_value = '0'.
        ENDIF.
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_showdropdown
                                        value = lv_value ).
        IF NOT lo_data_validation->errortitle IS INITIAL.
          lv_value = lo_data_validation->errortitle.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_errortitle
                                          value = lv_value ).
        ENDIF.
        IF NOT lo_data_validation->error IS INITIAL.
          lv_value = lo_data_validation->error.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_error
                                          value = lv_value ).
        ENDIF.
        IF NOT lo_data_validation->errorstyle IS INITIAL.
          lv_value = lo_data_validation->errorstyle.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_errorstyle
                                          value = lv_value ).
        ENDIF.
        IF NOT lo_data_validation->prompttitle IS INITIAL.
          lv_value = lo_data_validation->prompttitle.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_prompttitle
                                          value = lv_value ).
        ENDIF.
        IF NOT lo_data_validation->prompt IS INITIAL.
          lv_value = lo_data_validation->prompt.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_prompt
                                          value = lv_value ).
        ENDIF.
        lv_cell_row_s = lo_data_validation->cell_row.
        CONDENSE lv_cell_row_s.
        CONCATENATE lo_data_validation->cell_column lv_cell_row_s INTO lv_value.
        IF lo_data_validation->cell_row_to IS NOT INITIAL.
          lv_cell_row_s = lo_data_validation->cell_row_to.
          CONDENSE lv_cell_row_s.
          CONCATENATE lv_value ':' lo_data_validation->cell_column_to lv_cell_row_s INTO lv_value.
        ENDIF.
        lo_element_2->set_attribute_ns( name  = lc_xml_attr_sqref
                                        value = lv_value ).
        " formula1 node
        lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_formula1
                                                          parent = o_document ).
        lv_value = lo_data_validation->formula1.
        lo_element_3->set_value( value = lv_value ).

        lo_element_2->append_child( new_child = lo_element_3 ). " formula1 node
        " formula2 node
        IF NOT lo_data_validation->formula2 IS INITIAL.
          lo_element_3 = o_document->create_simple_element( name   = lc_xml_node_formula2
                                                            parent = o_document ).
          lv_value = lo_data_validation->formula2.
          lo_element_3->set_value( value = lv_value ).

          lo_element_2->append_child( new_child = lo_element_3 ). " formula2 node
        ENDIF.

        lo_element->append_child( new_child = lo_element_2 ). " dataValidation node
      ENDWHILE.
      o_element_root->append_child( new_child = lo_element ). " dataValidations node
    ENDIF.
  ENDMETHOD.

  METHOD add_hyperlinks.
    DATA: lo_element          TYPE REF TO if_ixml_element,
          lo_element_2        TYPE REF TO if_ixml_element,
          lo_iterator         TYPE REF TO Lcl_excel_collection_iterator,
          lv_value            TYPE string,
          lv_hyperlinks_count TYPE i,
          lo_link             TYPE REF TO Lcl_excel_hyperlink.

    lv_hyperlinks_count = o_worksheet->get_hyperlinks_size( ).
    IF lv_hyperlinks_count > 0.
      lo_element = o_document->create_simple_element( name   = 'hyperlinks'
                                                      parent = o_document ).

      lo_iterator = o_worksheet->get_hyperlinks_iterator( ).
      WHILE lo_iterator->has_next( ) EQ abap_true.
        lo_link ?= lo_iterator->get_next( ).

        lo_element_2 = o_document->create_simple_element( name   = 'hyperlink'
                                                          parent = lo_element ).

        lv_value = lo_link->get_ref( ).
        lo_element_2->set_attribute_ns( name  = 'ref'
                                        value = lv_value ).

        IF lo_link->is_internal( ) = abap_true.
          lv_value = lo_link->get_url( ).
          lo_element_2->set_attribute_ns( name  = 'location'
                                          value = lv_value ).
        ELSE.
          ADD 1 TO v_relation_id.

          lv_value = v_relation_id.
          CONDENSE lv_value.
          CONCATENATE 'rId' lv_value INTO lv_value.

          lo_element_2->set_attribute_ns( name  = 'r:id'
                                          value = lv_value ).

        ENDIF.

        lo_element->append_child( new_child = lo_element_2 ).
      ENDWHILE.

      o_element_root->append_child( new_child = lo_element ).
    ENDIF.
  ENDMETHOD.

  METHOD add_print_options.
    DATA:
          lo_element      TYPE REF TO if_ixml_element.

    IF o_worksheet->print_gridlines                  = abap_true
      OR o_worksheet->sheet_setup->vertical_centered   = abap_true
      OR o_worksheet->sheet_setup->horizontal_centered = abap_true.
      lo_element = o_document->create_simple_element( name   = 'printOptions'
                                                      parent = o_document ).

      IF o_worksheet->print_gridlines = abap_true.
        lo_element->set_attribute_ns( name  = lc_xml_attr_gridlines
                                      value = 'true' ).
      ENDIF.

      IF o_worksheet->sheet_setup->horizontal_centered = abap_true.
        lo_element->set_attribute_ns( name  = 'horizontalCentered'
                                      value = 'true' ).
      ENDIF.

      IF o_worksheet->sheet_setup->vertical_centered = abap_true.
        lo_element->set_attribute_ns( name  = 'verticalCentered'
                                      value = 'true' ).
      ENDIF.

      o_element_root->append_child( new_child = lo_element ).
    ENDIF.
  ENDMETHOD.

  METHOD add_page_margins.
    DATA:
      lo_element TYPE REF TO if_ixml_element,
      lv_value   TYPE string.

    lo_element = o_document->create_simple_element( name   = lc_xml_node_pagemargins
                                                    parent = o_document ).

    lv_value = o_worksheet->sheet_setup->margin_left.
    CONDENSE lv_value NO-GAPS.
    lo_element->set_attribute_ns( name  = lc_xml_attr_left
                                  value = lv_value ).
    lv_value = o_worksheet->sheet_setup->margin_right.
    CONDENSE lv_value NO-GAPS.
    lo_element->set_attribute_ns( name  = lc_xml_attr_right
                                  value = lv_value ).
    lv_value = o_worksheet->sheet_setup->margin_top.
    CONDENSE lv_value NO-GAPS.
    lo_element->set_attribute_ns( name  = lc_xml_attr_top
                                  value = lv_value ).
    lv_value = o_worksheet->sheet_setup->margin_bottom.
    CONDENSE lv_value NO-GAPS.
    lo_element->set_attribute_ns( name  = lc_xml_attr_bottom
                                  value = lv_value ).
    lv_value = o_worksheet->sheet_setup->margin_header.
    CONDENSE lv_value NO-GAPS.
    lo_element->set_attribute_ns( name  = lc_xml_attr_header
                                  value = lv_value ).
    lv_value = o_worksheet->sheet_setup->margin_footer.
    CONDENSE lv_value NO-GAPS.
    lo_element->set_attribute_ns( name  = lc_xml_attr_footer
                                  value = lv_value ).
    o_element_root->append_child( new_child = lo_element ). " pageMargins node
  ENDMETHOD.

  METHOD add_page_setup.
    DATA:
      lo_element TYPE REF TO if_ixml_element,
      lv_value   TYPE string.

    lo_element = o_document->create_simple_element( name   = lc_xml_node_pagesetup
                                                    parent = o_document ).

    IF o_worksheet->sheet_setup->black_and_white IS NOT INITIAL.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_blackandwhite
                                    value = `1` ).
    ENDIF.

    IF o_worksheet->sheet_setup->cell_comments IS NOT INITIAL.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_cellcomments
                                    value = o_worksheet->sheet_setup->cell_comments ).
    ENDIF.

    IF o_worksheet->sheet_setup->copies IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->copies.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_copies
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->draft IS NOT INITIAL.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_draft
                                    value = `1` ).
    ENDIF.

    IF o_worksheet->sheet_setup->errors IS NOT INITIAL.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_errors
                                    value = o_worksheet->sheet_setup->errors ).
    ENDIF.

    IF o_worksheet->sheet_setup->first_page_number IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->first_page_number.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_firstpagenumber
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->fit_to_page IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->fit_to_height.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_fittoheight
                                    value = lv_value ).
      lv_value = o_worksheet->sheet_setup->fit_to_width.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_fittowidth
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->horizontal_dpi IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->horizontal_dpi.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_horizontaldpi
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->orientation IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->orientation.
      lo_element->set_attribute_ns( name  = lc_xml_attr_orientation
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->page_order IS NOT INITIAL.
      lo_element->set_attribute_ns( name  = lc_xml_attr_pageorder
                                    value = o_worksheet->sheet_setup->page_order ).
    ENDIF.

    IF o_worksheet->sheet_setup->paper_height IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->paper_height.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_paperheight
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->paper_size IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->paper_size.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_papersize
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->paper_width IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->paper_width.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_paperwidth
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->scale IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->scale.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_scale
                                    value = lv_value ).
    ENDIF.

    IF o_worksheet->sheet_setup->use_first_page_num IS NOT INITIAL.
      lo_element->set_attribute_ns( name  = lc_xml_attr_usefirstpagenumber
                                    value = `1` ).
    ENDIF.

    IF o_worksheet->sheet_setup->use_printer_defaults IS NOT INITIAL.
      lo_element->set_attribute_ns( name  = lc_xml_attr_useprinterdefaults
                                    value = `1` ).
    ENDIF.

    IF o_worksheet->sheet_setup->vertical_dpi IS NOT INITIAL.
      lv_value = o_worksheet->sheet_setup->vertical_dpi.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_verticaldpi
                                    value = lv_value ).
    ENDIF.

    o_element_root->append_child( new_child = lo_element ). " pageSetup node
  ENDMETHOD.

  METHOD add_header_footer.
    DATA:
      lo_element   TYPE REF TO if_ixml_element,
      lo_element_2 TYPE REF TO if_ixml_element,
      lv_value     TYPE string.

    IF    o_worksheet->sheet_setup->odd_header IS NOT INITIAL
       OR o_worksheet->sheet_setup->odd_footer IS NOT INITIAL
       OR o_worksheet->sheet_setup->diff_oddeven_headerfooter = abap_true.

      lo_element = o_document->create_simple_element( name   = lc_xml_node_headerfooter
                                                      parent = o_document ).

      " Different header/footer for odd/even pages?
      IF o_worksheet->sheet_setup->diff_oddeven_headerfooter = abap_true.
        lo_element->set_attribute_ns( name  = lc_xml_attr_differentoddeven
                                      value = '1' ).
      ENDIF.

      " OddHeader
      CLEAR: lv_value.
      o_worksheet->sheet_setup->get_header_footer_string( IMPORTING ep_odd_header = lv_value ) .
      IF lv_value IS NOT INITIAL.
        lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_oddheader
                                                          parent = o_document ).
        lo_element_2->set_value( value = lv_value ).
        lo_element->append_child( new_child = lo_element_2 ).
      ENDIF.

      " OddFooter
      CLEAR: lv_value.
      o_worksheet->sheet_setup->get_header_footer_string( IMPORTING ep_odd_footer = lv_value ) .
      IF lv_value IS NOT INITIAL.
        lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_oddfooter
                                                          parent = o_document ).
        lo_element_2->set_value( value = lv_value ).
        lo_element->append_child( new_child = lo_element_2 ).
      ENDIF.

      " evenHeader
      CLEAR: lv_value.
      o_worksheet->sheet_setup->get_header_footer_string( IMPORTING ep_even_header = lv_value ) .
      IF lv_value IS NOT INITIAL.
        lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_evenheader
                                                          parent = o_document ).
        lo_element_2->set_value( value = lv_value ).
        lo_element->append_child( new_child = lo_element_2 ).
      ENDIF.

      " evenFooter
      CLEAR: lv_value.
      o_worksheet->sheet_setup->get_header_footer_string( IMPORTING ep_even_footer = lv_value ) .
      IF lv_value IS NOT INITIAL.
        lo_element_2 = o_document->create_simple_element( name   = lc_xml_node_evenfooter
                                                          parent = o_document ).
        lo_element_2->set_value( value = lv_value ).
        lo_element->append_child( new_child = lo_element_2 ).
      ENDIF.

      o_element_root->append_child( new_child = lo_element ). " headerFooter

    ENDIF.
  ENDMETHOD.

  METHOD add_drawing.
    DATA:
      lo_element  TYPE REF TO if_ixml_element,
      lv_value    TYPE string,
      lo_drawings TYPE REF TO Lcl_excel_drawings.

    lo_drawings = o_worksheet->get_drawings( ).
    IF lo_drawings->is_empty( ) = abap_false.
      lo_element = o_document->create_simple_element( name   = lc_xml_node_drawing
                                                      parent = o_document ).
      ADD 1 TO v_relation_id.

      lv_value = v_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      lo_element->set_attribute( name  = 'r:id'
                                 value = lv_value ).
      o_element_root->append_child( new_child = lo_element ).
    ENDIF.
  ENDMETHOD.

  METHOD add_drawing_for_comments.
    DATA: lo_element              TYPE REF TO if_ixml_element,
          lv_value                TYPE string,
          lo_drawing_for_comments TYPE REF TO Lcl_excel_comments.
    " (Legacy) drawings for comments

    lo_drawing_for_comments = o_worksheet->get_comments( ).
    IF lo_drawing_for_comments->is_empty( ) = abap_false.
      lo_element = o_document->create_simple_element( name   = lc_xml_node_drawing_for_cmt
                                                      parent = o_document ).
      ADD 1 TO v_relation_id.  " +1 for legacyDrawings

      lv_value = v_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      lo_element->set_attribute( name  = 'r:id'
                                 value = lv_value ).
      o_element_root->append_child( new_child = lo_element ).

      ADD 1 TO v_relation_id.  " +1 for comments (not referenced in XL sheet but let's reserve the rId)
    ENDIF.
* End   - Add - Issue #180
  ENDMETHOD.

  METHOD add_drawing_for_header_footer.
    DATA:
      lo_element  TYPE REF TO if_ixml_element,
      lv_value    TYPE string,
      lt_drawings TYPE zexcel_t_drawings.
* Header/Footer Image

    lt_drawings = o_worksheet->get_header_footer_drawings( ).
    IF lines( lt_drawings ) > 0. "Header or footer image exist
      lo_element = o_document->create_simple_element( name   = lc_xml_node_drawing_for_hd_ft
                                                      parent = o_document ).
      ADD 1 TO v_relation_id.  " +1 for legacyDrawings
      lv_value = v_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      lo_element->set_attribute( name  = 'r:id'
                                 value = lv_value ).
      o_element_root->append_child( new_child = lo_element ).
      ADD 1 TO v_relation_id.  " +1 for comments (not referenced in XL sheet but let's reserve the rId)
    ENDIF.
*
  ENDMETHOD.

  METHOD add_table_parts.
    DATA:
      lo_element     TYPE REF TO if_ixml_element,
      lo_element_2   TYPE REF TO if_ixml_element,
      lo_iterator    TYPE REF TO Lcl_excel_collection_iterator,
      lo_table       TYPE REF TO Lcl_excel_table,
      lv_table_count TYPE i,
      lv_value       TYPE string.

* tables

    lv_table_count = o_worksheet->get_tables_size( ).
    IF lv_table_count > 0.
      lo_element = o_document->create_simple_element( name   = 'tableParts'
                                                      parent = o_document ).
      lv_value = lv_table_count.
      CONDENSE lv_value.
      lo_element->set_attribute_ns( name  = 'count'
                                    value = lv_value ).

      lo_iterator = o_worksheet->get_tables_iterator( ).
      WHILE lo_iterator->has_next( ) EQ abap_true.
        lo_table ?= lo_iterator->get_next( ).
        ADD 1 TO v_relation_id.

        lv_value = v_relation_id.
        CONDENSE lv_value.
        CONCATENATE 'rId' lv_value INTO lv_value.
        lo_element_2 = o_document->create_simple_element( name   = 'tablePart'
                                                          parent = lo_element ).
        lo_element_2->set_attribute_ns( name  = 'r:id'
                                        value = lv_value ).
        lo_element->append_child( new_child = lo_element_2 ).

      ENDWHILE.

      o_element_root->append_child( new_child = lo_element ).

    ENDIF.
  ENDMETHOD.

  METHOD add_sheet_data.
    DATA:
      lo_element     TYPE REF TO if_ixml_element.

    lo_element = o_excel_ref->create_xl_sheet_sheet_data( io_worksheet = o_worksheet
                                                          io_document  = o_document ).

    o_element_root->append_child( new_child = lo_element ). " sheetData node
  ENDMETHOD.

  METHOD add_page_breaks.

    TRY.
        o_excel_ref->create_xl_sheet_pagebreaks( io_document  = o_document
                                                 io_parent    = o_element_root
                                                 io_worksheet = o_worksheet ).
      CATCH Lcx_excel. " Ignore Hyperlink reading errors - pass everything we were able to identify
    ENDTRY.

  ENDMETHOD.

  METHOD add_ignored_errors.

    o_excel_ref->create_xl_sheet_ignored_errors( io_worksheet    = o_worksheet
                                                 io_document     = o_document
                                                 io_element_root = o_element_root ).

  ENDMETHOD.

ENDCLASS.

*"* test class
*include Lcl_excel_writer_2007=========ccau.
*"* use this source file for your ABAP unit test classes

*CLASS SHRITEFUH64VYIPN5I4UIDBJAANSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJAAOSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJAAPSE4 DEFINITION DEFERRED.
*CLASS Lcl_excel_writer_2007 DEFINITION LOCAL FRIENDS
*    SHRITEFUH64VYIPN5I4UIDBJAANSE4
*    SHRITEFUH64VYIPN5I4UIDBJAAOSE4
*    SHRITEFUH64VYIPN5I4UIDBJAAPSE4.












class LCL_EXCEL_WRITER_2007 implementation.
*"* method's implementations
*include methods.
  METHOD escape_string_value.

    DATA: lt_character_positions TYPE TABLE OF i,
          lv_character_position  TYPE i,
          lv_escaped_value       TYPE string.

    result = iv_value.
    IF result CA control_characters.

      CLEAR lt_character_positions.
      APPEND sy-fdpos TO lt_character_positions.
      lv_character_position = sy-fdpos + 1.
      WHILE result+lv_character_position CA control_characters.
        ADD sy-fdpos TO lv_character_position.
        APPEND lv_character_position TO lt_character_positions.
        ADD 1 TO lv_character_position.
      ENDWHILE.
      SORT lt_character_positions BY table_line DESCENDING.

      LOOP AT lt_character_positions INTO lv_character_position.
        lv_escaped_value = |_x{ cl_abap_conv_out_ce=>uccp( substring( val = result off = lv_character_position len = 1 ) ) }_|.
        REPLACE SECTION OFFSET lv_character_position LENGTH 1 OF result WITH lv_escaped_value.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD add_1_val_child_node.

    DATA: lo_child TYPE REF TO if_ixml_element.

    lo_child = io_document->create_simple_element( name   = iv_elem_name
                                                   parent = io_document ).
    IF iv_attr_name IS NOT INITIAL.
      lo_child->set_attribute_ns( name  = iv_attr_name
                                  value = iv_attr_value ).
    ENDIF.
    io_parent->append_child( new_child = lo_child ).

  ENDMETHOD.
  METHOD add_further_data_to_zip.
* Can be used by child classes like xlsm-writer to write additional data to zip archive
  ENDMETHOD.
  METHOD constructor.
    DATA: lt_unicode_point_codes TYPE TABLE OF string,
          lv_unicode_point_code  TYPE i.

    me->ixml = cl_ixml=>create( ).

    SPLIT '0,1,2,3,4,5,6,7,8,' " U+0000 to U+0008
       && '11,12,'             " U+000B, U+000C
       && '14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,' " U+000E to U+001F
       && '65534,65535'        " U+FFFE, U+FFFF
      AT ',' INTO TABLE lt_unicode_point_codes.
    control_characters = ``.
    LOOP AT lt_unicode_point_codes INTO lv_unicode_point_code.
      control_characters = control_characters && cl_abap_conv_in_ce=>uccpi( lv_unicode_point_code ).
    ENDLOOP.

  ENDMETHOD.
  METHOD create.

* Office 2007 file format is a cab of several xml files with extension .xlsx

    DATA: lo_zip              TYPE REF TO cl_abap_zip,
          lo_worksheet        TYPE REF TO Lcl_excel_worksheet,
          lo_active_worksheet TYPE REF TO Lcl_excel_worksheet,
          lo_iterator         TYPE REF TO Lcl_excel_collection_iterator,
          lo_nested_iterator  TYPE REF TO Lcl_excel_collection_iterator,
          lo_table            TYPE REF TO Lcl_excel_table,
          lo_drawing          TYPE REF TO Lcl_excel_drawing,
          lo_drawings         TYPE REF TO Lcl_excel_drawings,
          lo_comment          TYPE REF TO Lcl_excel_comment,   " (+) Issue #180
          lo_comments         TYPE REF TO Lcl_excel_comments.  " (+) Issue #180

    DATA: lv_content                TYPE xstring,
          lv_active                 TYPE flag,
          lv_xl_sheet               TYPE string,
          lv_xl_sheet_rels          TYPE string,
          lv_xl_drawing_for_comment TYPE string,   " (+) Issue #180
          lv_xl_comment             TYPE string,   " (+) Issue #180
          lv_xl_drawing             TYPE string,
          lv_xl_drawing_rels        TYPE string,
          lv_index_str              TYPE string,
          lv_value                  TYPE string,
          lv_sheet_index            TYPE i,
          lv_drawing_index          TYPE i,
          lv_comment_index          TYPE i.        " (+) Issue #180

**********************************************************************

**********************************************************************
* Start of insertion # issue 139 - Dateretention of cellstyles
    me->excel->add_static_styles( ).
* End of insertion # issue 139 - Dateretention of cellstyles

**********************************************************************
* STEP 1: Create archive object file (ZIP)
    CREATE OBJECT lo_zip.

**********************************************************************
* STEP 2: Add [Content_Types].xml to zip
    lv_content = me->create_content_types( ).
    lo_zip->add( name    = me->c_content_types
                 content = lv_content ).

**********************************************************************
* STEP 3: Add _rels/.rels to zip
    lv_content = me->create_relationships( ).
    lo_zip->add( name    = me->c_relationships
                 content = lv_content ).

**********************************************************************
* STEP 4: Add docProps/app.xml to zip
    lv_content = me->create_docprops_app( ).
    lo_zip->add( name    = me->c_docprops_app
                 content = lv_content ).

**********************************************************************
* STEP 5: Add docProps/core.xml to zip
    lv_content = me->create_docprops_core( ).
    lo_zip->add( name    = me->c_docprops_core
                 content = lv_content ).

**********************************************************************
* STEP 6: Add xl/_rels/workbook.xml.rels to zip
    lv_content = me->create_xl_relationships( ).
    lo_zip->add( name    = me->c_xl_relationships
                 content = lv_content ).

**********************************************************************
* STEP 6: Add xl/_rels/workbook.xml.rels to zip
    lv_content = me->create_xl_theme( ).
    lo_zip->add( name    = me->c_xl_theme
                 content = lv_content ).

**********************************************************************
* STEP 7: Add xl/workbook.xml to zip
    lv_content = me->create_xl_workbook( ).
    lo_zip->add( name    = me->c_xl_workbook
                 content = lv_content ).

**********************************************************************
* STEP 8: Add xl/workbook.xml to zip
    lv_content = me->create_xl_styles( ).
    lo_zip->add( name    = me->c_xl_styles
                 content = lv_content ).

**********************************************************************
* STEP 9: Add sharedStrings.xml to zip
    lv_content = me->create_xl_sharedstrings( ).
    lo_zip->add( name    = me->c_xl_sharedstrings
                 content = lv_content ).

**********************************************************************
* STEP 10: Add sheet#.xml and drawing#.xml to zip
    lo_iterator = me->excel->get_worksheets_iterator( ).
    lo_active_worksheet = me->excel->get_active_worksheet( ).

    WHILE lo_iterator->has_next( ) EQ abap_true.
      lv_sheet_index = sy-index.

      lo_worksheet ?= lo_iterator->get_next( ).
      IF lo_active_worksheet->get_guid( ) EQ lo_worksheet->get_guid( ).
        lv_active = abap_true.
      ELSE.
        lv_active = abap_false.
      ENDIF.
      lv_content = me->create_xl_sheet( io_worksheet = lo_worksheet
                                        iv_active    = lv_active ).
      lv_xl_sheet = me->c_xl_sheet.

      lv_index_str = lv_sheet_index.
      CONDENSE lv_index_str NO-GAPS.
      REPLACE ALL OCCURRENCES OF '#' IN lv_xl_sheet WITH lv_index_str.
      lo_zip->add( name    = lv_xl_sheet
                   content = lv_content ).

* Begin - Add - Issue #180
* Add comments **********************************
      lo_comments = lo_worksheet->get_comments( ).
      IF lo_comments->is_empty( ) = abap_false.
        lv_comment_index = lv_comment_index + 1.

        " Create comment itself
        lv_content = me->create_xl_comments( lo_worksheet ).
        lv_xl_comment = me->c_xl_comments.
        lv_index_str = lv_comment_index.
        CONDENSE lv_index_str NO-GAPS.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_comment WITH lv_index_str.
        lo_zip->add( name    = lv_xl_comment
                     content = lv_content ).

        " Create vmlDrawing that will host the comment
        lv_content = me->create_xl_drawing_for_comments( lo_worksheet ).
        lv_xl_drawing_for_comment = me->cl_xl_drawing_for_comments.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_drawing_for_comment WITH lv_index_str.
        lo_zip->add( name    = lv_xl_drawing_for_comment
                     content = lv_content ).
      ENDIF.
* End   - Add - Issue #180

* Add drawings **********************************
      lo_drawings = lo_worksheet->get_drawings( ).
      IF lo_drawings->is_empty( ) = abap_false.
        lv_drawing_index = lv_drawing_index + 1.

        lv_content = me->create_xl_drawings( lo_worksheet ).
        lv_xl_drawing = me->c_xl_drawings.
        lv_index_str = lv_drawing_index.
        CONDENSE lv_index_str NO-GAPS.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_drawing WITH lv_index_str.
        lo_zip->add( name    = lv_xl_drawing
                     content = lv_content ).

        lv_content = me->create_xl_drawings_rels( lo_worksheet ).
        lv_xl_drawing_rels = me->c_xl_drawings_rels.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_drawing_rels WITH lv_index_str.
        lo_zip->add( name    = lv_xl_drawing_rels
                     content = lv_content ).
      ENDIF.

* Add Header/Footer image
      DATA: lt_drawings TYPE zexcel_t_drawings.
      lt_drawings = lo_worksheet->get_header_footer_drawings( ).
      IF lines( lt_drawings ) > 0. "Header or footer image exist

        lv_comment_index = lv_comment_index + 1.
        lv_index_str = lv_comment_index.
        CONDENSE lv_index_str NO-GAPS.

        " Create vmlDrawing that will host the image
        lv_content = me->create_xl_drawing_for_hdft_im( lo_worksheet ).
        lv_xl_drawing_for_comment = me->cl_xl_drawing_for_comments.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_drawing_for_comment WITH lv_index_str.
        lo_zip->add( name    = lv_xl_drawing_for_comment
                     content = lv_content ).

        " Create vmlDrawing REL that will host the image
        lv_content = me->create_xl_drawings_hdft_rels( lo_worksheet ).
        lv_xl_drawing_rels = me->c_xl_drawings_vml_rels.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_drawing_rels WITH lv_index_str.
        lo_zip->add( name    = lv_xl_drawing_rels
                     content = lv_content ).
      ENDIF.


      lv_xl_sheet_rels = me->c_xl_sheet_rels.
      lv_content = me->create_xl_sheet_rels( io_worksheet = lo_worksheet
                                             iv_drawing_index = lv_drawing_index
                                             iv_comment_index = lv_comment_index ).      " (+) Issue #180

      lv_index_str = lv_sheet_index.
      CONDENSE lv_index_str NO-GAPS.
      REPLACE ALL OCCURRENCES OF '#' IN lv_xl_sheet_rels WITH lv_index_str.
      lo_zip->add( name    = lv_xl_sheet_rels
                   content = lv_content ).

      lo_nested_iterator = lo_worksheet->get_tables_iterator( ).

      WHILE lo_nested_iterator->has_next( ) EQ abap_true.
        lo_table ?= lo_nested_iterator->get_next( ).
        lv_content = me->create_xl_table( lo_table ).

        lv_value = lo_table->get_name( ).
        CONCATENATE 'xl/tables/' lv_value '.xml' INTO lv_value.
        lo_zip->add( name = lv_value
                      content = lv_content ).
      ENDWHILE.



    ENDWHILE.

**********************************************************************
* STEP 11: Add media
    lo_iterator = me->excel->get_drawings_iterator( Lcl_excel_drawing=>type_image ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_drawing ?= lo_iterator->get_next( ).

      lv_content = lo_drawing->get_media( ).
      lv_value = lo_drawing->get_media_name( ).
      CONCATENATE 'xl/media/' lv_value INTO lv_value.
      lo_zip->add( name    = lv_value
                   content = lv_content ).
    ENDWHILE.

**********************************************************************
* STEP 12: Add charts
    lo_iterator = me->excel->get_drawings_iterator( Lcl_excel_drawing=>type_chart ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_drawing ?= lo_iterator->get_next( ).

      lv_content = lo_drawing->get_media( ).

      "-------------Added by Alessandro Iannacci - Only if template exist
      IF lv_content IS NOT INITIAL AND me->excel->use_template EQ abap_true.
        lv_value = lo_drawing->get_media_name( ).
        CONCATENATE 'xl/charts/' lv_value INTO lv_value.
        lo_zip->add( name    = lv_value
                     content = lv_content ).
      ELSE. "ADD CUSTOM CHART!!!!
        lv_content = me->create_xl_charts( lo_drawing ).
        lv_value = lo_drawing->get_media_name( ).
        CONCATENATE 'xl/charts/' lv_value INTO lv_value.
        lo_zip->add( name    = lv_value
                     content = lv_content ).
      ENDIF.
      "-------------------------------------------------
    ENDWHILE.

* Second to last step: Allow further information put into the zip archive by child classes
    me->add_further_data_to_zip( lo_zip ).

**********************************************************************
* Last step: Create the final zip
    ep_excel = lo_zip->save( ).

  ENDMETHOD.
  METHOD create_content_types.


** Constant node name
    DATA: lc_xml_node_types        TYPE string VALUE 'Types',
          lc_xml_node_override     TYPE string VALUE 'Override',
          lc_xml_node_default      TYPE string VALUE 'Default',
          " Node attributes
          lc_xml_attr_partname     TYPE string VALUE 'PartName',
          lc_xml_attr_extension    TYPE string VALUE 'Extension',
          lc_xml_attr_contenttype  TYPE string VALUE 'ContentType',
          " Node namespace
          lc_xml_node_types_ns     TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/content-types',
          " Node extension
          lc_xml_node_rels_ext     TYPE string VALUE 'rels',
          lc_xml_node_xml_ext      TYPE string VALUE 'xml',
          lc_xml_node_xml_vml      TYPE string VALUE 'vml',   " (+) GGAR
          " Node partnumber
          lc_xml_node_theme_pn     TYPE string VALUE '/xl/theme/theme1.xml',
          lc_xml_node_styles_pn    TYPE string VALUE '/xl/styles.xml',
          lc_xml_node_workb_pn     TYPE string VALUE '/xl/workbook.xml',
          lc_xml_node_props_pn     TYPE string VALUE '/docProps/app.xml',
          lc_xml_node_worksheet_pn TYPE string VALUE '/xl/worksheets/sheet#.xml',
          lc_xml_node_strings_pn   TYPE string VALUE '/xl/sharedStrings.xml',
          lc_xml_node_core_pn      TYPE string VALUE '/docProps/core.xml',
          lc_xml_node_chart_pn     TYPE string VALUE '/xl/charts/chart#.xml',
          " Node contentType
          lc_xml_node_theme_ct     TYPE string VALUE 'application/vnd.openxmlformats-officedocument.theme+xml',
          lc_xml_node_styles_ct    TYPE string VALUE 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml',
          lc_xml_node_workb_ct     TYPE string VALUE 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml',
          lc_xml_node_rels_ct      TYPE string VALUE 'application/vnd.openxmlformats-package.relationships+xml',
          lc_xml_node_vml_ct       TYPE string VALUE 'application/vnd.openxmlformats-officedocument.vmlDrawing',
          lc_xml_node_xml_ct       TYPE string VALUE 'application/xml',
          lc_xml_node_props_ct     TYPE string VALUE 'application/vnd.openxmlformats-officedocument.extended-properties+xml',
          lc_xml_node_worksheet_ct TYPE string VALUE 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml',
          lc_xml_node_strings_ct   TYPE string VALUE 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml',
          lc_xml_node_core_ct      TYPE string VALUE 'application/vnd.openxmlformats-package.core-properties+xml',
          lc_xml_node_table_ct     TYPE string VALUE 'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml',
          lc_xml_node_comments_ct  TYPE string VALUE 'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml',   " (+) GGAR
          lc_xml_node_drawings_ct  TYPE string VALUE 'application/vnd.openxmlformats-officedocument.drawing+xml',
          lc_xml_node_chart_ct     TYPE string VALUE 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml'.

    DATA: lo_document        TYPE REF TO if_ixml_document,
          lo_element_root    TYPE REF TO if_ixml_element,
          lo_element         TYPE REF TO if_ixml_element,
          lo_worksheet       TYPE REF TO Lcl_excel_worksheet,
          lo_iterator        TYPE REF TO Lcl_excel_collection_iterator,
          lo_nested_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_table           TYPE REF TO Lcl_excel_table.

    DATA: lv_worksheets_num        TYPE i,
          lv_worksheets_numc       TYPE n LENGTH 3,
          lv_xml_node_worksheet_pn TYPE string,
          lv_value                 TYPE string,
          lv_comment_index         TYPE i VALUE 1,  " (+) GGAR
          lv_drawing_index         TYPE i VALUE 1,
          lv_index_str             TYPE string.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node types
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_types
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
    value = lc_xml_node_types_ns ).

**********************************************************************
* STEP 4: Create subnodes

    " rels node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_default
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_extension
                                  value = lc_xml_node_rels_ext ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_rels_ct ).
    lo_element_root->append_child( new_child = lo_element ).

    " extension node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_default
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_extension
                                  value = lc_xml_node_xml_ext ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_xml_ct ).
    lo_element_root->append_child( new_child = lo_element ).

* Begin - Add - GGAR
    " VML node (for comments)
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_default
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_extension
                                  value = lc_xml_node_xml_vml ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_vml_ct ).
    lo_element_root->append_child( new_child = lo_element ).
* End   - Add - GGAR

    " Theme node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lc_xml_node_theme_pn ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_theme_ct ).
    lo_element_root->append_child( new_child = lo_element ).

    " Styles node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lc_xml_node_styles_pn ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_styles_ct ).
    lo_element_root->append_child( new_child = lo_element ).

    " Workbook node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lc_xml_node_workb_pn ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_workb_ct ).
    lo_element_root->append_child( new_child = lo_element ).

    " Properties node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lc_xml_node_props_pn ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_props_ct ).
    lo_element_root->append_child( new_child = lo_element ).

    " Worksheet node
    lv_worksheets_num = excel->get_worksheets_size( ).
    DO lv_worksheets_num TIMES.
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                       parent = lo_document ).

      lv_worksheets_numc = sy-index.
      SHIFT lv_worksheets_numc LEFT DELETING LEADING '0'.
      lv_xml_node_worksheet_pn = lc_xml_node_worksheet_pn.
      REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_worksheet_pn WITH lv_worksheets_numc.
      lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                    value = lv_xml_node_worksheet_pn ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                    value = lc_xml_node_worksheet_ct ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDDO.

    lo_iterator = me->excel->get_worksheets_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).

      lo_nested_iterator = lo_worksheet->get_tables_iterator( ).

      WHILE lo_nested_iterator->has_next( ) EQ abap_true.
        lo_table ?= lo_nested_iterator->get_next( ).

        lv_value = lo_table->get_name( ).
        CONCATENATE '/xl/tables/' lv_value '.xml' INTO lv_value.

        lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lv_value ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_table_ct ).
        lo_element_root->append_child( new_child = lo_element ).
      ENDWHILE.

* Begin - Add - GGAR
      " Comments
      DATA: lo_comments TYPE REF TO Lcl_excel_comments.

      lo_comments = lo_worksheet->get_comments( ).
      IF lo_comments->is_empty( ) = abap_false.
        lv_index_str = lv_comment_index.
        CONDENSE lv_index_str NO-GAPS.
        CONCATENATE '/' me->c_xl_comments INTO lv_value.
        REPLACE '#' WITH lv_index_str INTO lv_value.

        lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                         parent = lo_document ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                      value = lv_value ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                      value = lc_xml_node_comments_ct ).
        lo_element_root->append_child( new_child = lo_element ).

        ADD 1 TO lv_comment_index.
      ENDIF.
* End   - Add - GGAR

      " Drawings
      DATA: lo_drawings TYPE REF TO Lcl_excel_drawings.

      lo_drawings = lo_worksheet->get_drawings( ).
      IF lo_drawings->is_empty( ) = abap_false.
        lv_index_str = lv_drawing_index.
        CONDENSE lv_index_str NO-GAPS.
        CONCATENATE '/' me->c_xl_drawings INTO lv_value.
        REPLACE '#' WITH lv_index_str INTO lv_value.

        lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lv_value ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_drawings_ct ).
        lo_element_root->append_child( new_child = lo_element ).

        ADD 1 TO lv_drawing_index.
      ENDIF.
    ENDWHILE.

    " media mimes
    DATA: lo_drawing    TYPE REF TO Lcl_excel_drawing,
          lt_media_type TYPE TABLE OF mimetypes-extension,
          lv_media_type TYPE mimetypes-extension,
          lv_mime_type  TYPE mimetypes-type.

    lo_iterator = me->excel->get_drawings_iterator( Lcl_excel_drawing=>type_image ).
    WHILE lo_iterator->has_next( ) = abap_true.
      lo_drawing ?= lo_iterator->get_next( ).

      lv_media_type = lo_drawing->get_media_type( ).
      COLLECT lv_media_type INTO lt_media_type.
    ENDWHILE.

    LOOP AT lt_media_type INTO lv_media_type.
      CALL FUNCTION 'SDOK_MIMETYPE_GET'
        EXPORTING
          extension = lv_media_type
        IMPORTING
          mimetype  = lv_mime_type.

      lo_element = lo_document->create_simple_element( name   = lc_xml_node_default
                                                       parent = lo_document ).
      lv_value = lv_media_type.
      lo_element->set_attribute_ns( name  = lc_xml_attr_extension
                                    value = lv_value ).
      lv_value = lv_mime_type.
      lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                    value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDLOOP.

    " Charts
    lo_iterator = me->excel->get_drawings_iterator( Lcl_excel_drawing=>type_chart ).
    WHILE lo_iterator->has_next( ) = abap_true.
      lo_drawing ?= lo_iterator->get_next( ).

      lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                       parent = lo_document ).
      lv_index_str = lo_drawing->get_index( ).
      CONDENSE lv_index_str.
      lv_value = lc_xml_node_chart_pn.
      REPLACE ALL OCCURRENCES OF '#' IN lv_value WITH lv_index_str.
      lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                    value = lc_xml_node_chart_ct ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDWHILE.

    " Strings node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lc_xml_node_strings_pn ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_strings_ct ).
    lo_element_root->append_child( new_child = lo_element ).

    " Strings node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_override
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_partname
                                  value = lc_xml_node_core_pn ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_core_ct ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).
  ENDMETHOD.
  METHOD create_docprops_app.


** Constant node name
    DATA: lc_xml_node_properties        TYPE string VALUE 'Properties',
          lc_xml_node_application       TYPE string VALUE 'Application',
          lc_xml_node_docsecurity       TYPE string VALUE 'DocSecurity',
          lc_xml_node_scalecrop         TYPE string VALUE 'ScaleCrop',
          lc_xml_node_headingpairs      TYPE string VALUE 'HeadingPairs',
          lc_xml_node_vector            TYPE string VALUE 'vector',
          lc_xml_node_variant           TYPE string VALUE 'variant',
          lc_xml_node_lpstr             TYPE string VALUE 'lpstr',
          lc_xml_node_i4                TYPE string VALUE 'i4',
          lc_xml_node_titlesofparts     TYPE string VALUE 'TitlesOfParts',
          lc_xml_node_company           TYPE string VALUE 'Company',
          lc_xml_node_linksuptodate     TYPE string VALUE 'LinksUpToDate',
          lc_xml_node_shareddoc         TYPE string VALUE 'SharedDoc',
          lc_xml_node_hyperlinkschanged TYPE string VALUE 'HyperlinksChanged',
          lc_xml_node_appversion        TYPE string VALUE 'AppVersion',
          " Namespace prefix
          lc_vt_ns                      TYPE string VALUE 'vt',
          lc_xml_node_props_ns          TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',
          lc_xml_node_props_vt_ns       TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',
          " Node attributes
          lc_xml_attr_size              TYPE string VALUE 'size',
          lc_xml_attr_basetype          TYPE string VALUE 'baseType'.

    DATA: lo_document            TYPE REF TO if_ixml_document,
          lo_element_root        TYPE REF TO if_ixml_element,
          lo_element             TYPE REF TO if_ixml_element,
          lo_sub_element_vector  TYPE REF TO if_ixml_element,
          lo_sub_element_variant TYPE REF TO if_ixml_element,
          lo_sub_element_lpstr   TYPE REF TO if_ixml_element,
          lo_sub_element_i4      TYPE REF TO if_ixml_element,
          lo_iterator            TYPE REF TO Lcl_excel_collection_iterator,
          lo_worksheet           TYPE REF TO Lcl_excel_worksheet.

    DATA: lv_value                TYPE string.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node properties
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_properties
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_props_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:vt'
                                       value = lc_xml_node_props_vt_ns ).

**********************************************************************
* STEP 4: Create subnodes
    " Application
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_application
                                                     parent = lo_document ).
    lv_value = excel->Lif_excel_book_properties~application.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " DocSecurity
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_docsecurity
                                                              parent = lo_document ).
    lv_value = excel->Lif_excel_book_properties~docsecurity.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " ScaleCrop
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_scalecrop
                                                     parent = lo_document ).
    lv_value = me->flag2bool( excel->Lif_excel_book_properties~scalecrop ).
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " HeadingPairs
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_headingpairs
                                                     parent = lo_document ).


    " * vector node
    lo_sub_element_vector = lo_document->create_simple_element_ns( name   = lc_xml_node_vector
                                                                   prefix = lc_vt_ns
                                                                   parent = lo_document ).
    lo_sub_element_vector->set_attribute_ns( name    = lc_xml_attr_size
                                             value   = '2' ).
    lo_sub_element_vector->set_attribute_ns( name    = lc_xml_attr_basetype
                                             value   = lc_xml_node_variant ).

    " ** variant node
    lo_sub_element_variant = lo_document->create_simple_element_ns( name   = lc_xml_node_variant
                                                                    prefix = lc_vt_ns
                                                                    parent = lo_document ).

    " *** lpstr node
    lo_sub_element_lpstr = lo_document->create_simple_element_ns( name   = lc_xml_node_lpstr
                                                                  prefix = lc_vt_ns
                                                                  parent = lo_document ).
    lv_value = excel->get_worksheets_name( ).
    lo_sub_element_lpstr->set_value( value = lv_value ).
    lo_sub_element_variant->append_child( new_child = lo_sub_element_lpstr ). " lpstr node

    lo_sub_element_vector->append_child( new_child = lo_sub_element_variant ). " variant node

    " ** variant node
    lo_sub_element_variant = lo_document->create_simple_element_ns( name   = lc_xml_node_variant
                                                                    prefix = lc_vt_ns
                                                                    parent = lo_document ).

    " *** i4 node
    lo_sub_element_i4 = lo_document->create_simple_element_ns( name   = lc_xml_node_i4
                                                               prefix = lc_vt_ns
                                                               parent = lo_document ).
    lv_value = excel->get_worksheets_size( ).
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_sub_element_i4->set_value( value = lv_value ).
    lo_sub_element_variant->append_child( new_child = lo_sub_element_i4 ). " lpstr node

    lo_sub_element_vector->append_child( new_child = lo_sub_element_variant ). " variant node

    lo_element->append_child( new_child = lo_sub_element_vector ). " vector node

    lo_element_root->append_child( new_child = lo_element ). " HeadingPairs


    " TitlesOfParts
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_titlesofparts
                                                     parent = lo_document ).


    " * vector node
    lo_sub_element_vector = lo_document->create_simple_element_ns( name   = lc_xml_node_vector
                                                                   prefix = lc_vt_ns
                                                                   parent = lo_document ).
    lv_value = excel->get_worksheets_size( ).
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_sub_element_vector->set_attribute_ns( name    = lc_xml_attr_size
                                             value   = lv_value ).
    lo_sub_element_vector->set_attribute_ns( name    = lc_xml_attr_basetype
                                             value   = lc_xml_node_lpstr ).

    lo_iterator = excel->get_worksheets_iterator( ).

    WHILE lo_iterator->has_next( ) EQ abap_true.
      " ** lpstr node
      lo_sub_element_lpstr = lo_document->create_simple_element_ns( name   = lc_xml_node_lpstr
                                                                    prefix = lc_vt_ns
                                                                    parent = lo_document ).
      lo_worksheet ?= lo_iterator->get_next( ).
      lv_value = lo_worksheet->get_title( ).
      lo_sub_element_lpstr->set_value( value = lv_value ).
      lo_sub_element_vector->append_child( new_child = lo_sub_element_lpstr ). " lpstr node
    ENDWHILE.

    lo_element->append_child( new_child = lo_sub_element_vector ). " vector node

    lo_element_root->append_child( new_child = lo_element ). " TitlesOfParts



    " Company
    IF excel->Lif_excel_book_properties~company IS NOT INITIAL.
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_company
                                                       parent = lo_document ).
      lv_value = excel->Lif_excel_book_properties~company.
      lo_element->set_value( value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDIF.

    " LinksUpToDate
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_linksuptodate
                                                     parent = lo_document ).
    lv_value = me->flag2bool( excel->Lif_excel_book_properties~linksuptodate ).
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " SharedDoc
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_shareddoc
                                                     parent = lo_document ).
    lv_value = me->flag2bool( excel->Lif_excel_book_properties~shareddoc ).
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " HyperlinksChanged
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_hyperlinkschanged
                                                     parent = lo_document ).
    lv_value = me->flag2bool( excel->Lif_excel_book_properties~hyperlinkschanged ).
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " AppVersion
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_appversion
                                                     parent = lo_document ).
    lv_value = excel->Lif_excel_book_properties~appversion.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).
  ENDMETHOD.
  METHOD create_docprops_core.


** Constant node name
    DATA: lc_xml_node_coreproperties TYPE string VALUE 'coreProperties',
          lc_xml_node_creator        TYPE string VALUE 'creator',
          lc_xml_node_description    TYPE string VALUE 'description',
          lc_xml_node_lastmodifiedby TYPE string VALUE 'lastModifiedBy',
          lc_xml_node_created        TYPE string VALUE 'created',
          lc_xml_node_modified       TYPE string VALUE 'modified',
          " Node attributes
          lc_xml_attr_type           TYPE string VALUE 'type',
          lc_xml_attr_target         TYPE string VALUE 'dcterms:W3CDTF',
          " Node namespace
          lc_cp_ns                   TYPE string VALUE 'cp',
          lc_dc_ns                   TYPE string VALUE 'dc',
          lc_dcterms_ns              TYPE string VALUE 'dcterms',
*        lc_dcmitype_ns              TYPE string VALUE 'dcmitype',
          lc_xsi_ns                  TYPE string VALUE 'xsi',
          lc_xml_node_cp_ns          TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties',
          lc_xml_node_dc_ns          TYPE string VALUE 'http://purl.org/dc/elements/1.1/',
          lc_xml_node_dcterms_ns     TYPE string VALUE 'http://purl.org/dc/terms/',
          lc_xml_node_dcmitype_ns    TYPE string VALUE 'http://purl.org/dc/dcmitype/',
          lc_xml_node_xsi_ns         TYPE string VALUE 'http://www.w3.org/2001/XMLSchema-instance'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element.

    DATA: lv_value TYPE string,
          lv_date  TYPE d,
          lv_time  TYPE t.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node coreProperties
    lo_element_root  = lo_document->create_simple_element_ns( name   = lc_xml_node_coreproperties
                                                              prefix = lc_cp_ns
                                                              parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:cp'
                                       value = lc_xml_node_cp_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:dc'
                                       value = lc_xml_node_dc_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:dcterms'
                                       value = lc_xml_node_dcterms_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:dcmitype'
                                       value = lc_xml_node_dcmitype_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:xsi'
                                       value = lc_xml_node_xsi_ns ).

**********************************************************************
* STEP 4: Create subnodes
    " Creator node
    lo_element = lo_document->create_simple_element_ns( name   = lc_xml_node_creator
                                                        prefix = lc_dc_ns
                                                        parent = lo_document ).
    lv_value = excel->Lif_excel_book_properties~creator.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " Description node
    lo_element = lo_document->create_simple_element_ns( name   = lc_xml_node_description
                                                        prefix = lc_dc_ns
                                                        parent = lo_document ).
    lv_value = excel->Lif_excel_book_properties~description.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " lastModifiedBy node
    lo_element = lo_document->create_simple_element_ns( name   = lc_xml_node_lastmodifiedby
                                                        prefix = lc_cp_ns
                                                        parent = lo_document ).
    lv_value = excel->Lif_excel_book_properties~lastmodifiedby.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " Created node
    lo_element = lo_document->create_simple_element_ns( name   = lc_xml_node_created
                                                        prefix = lc_dcterms_ns
                                                        parent = lo_document ).
    lo_element->set_attribute_ns( name    = lc_xml_attr_type
                                  prefix  = lc_xsi_ns
                                  value   = lc_xml_attr_target ).

    CONVERT TIME STAMP excel->Lif_excel_book_properties~created TIME ZONE sy-zonlo INTO DATE lv_date TIME lv_time.
    CONCATENATE lv_date lv_time INTO lv_value RESPECTING BLANKS.
    REPLACE ALL OCCURRENCES OF REGEX '([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})' IN lv_value WITH '$1-$2-$3T$4:$5:$6Z'.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " Modified node
    lo_element = lo_document->create_simple_element_ns( name   = lc_xml_node_modified
                                                        prefix = lc_dcterms_ns
                                                        parent = lo_document ).
    lo_element->set_attribute_ns( name    = lc_xml_attr_type
                                  prefix  = lc_xsi_ns
                                  value   = lc_xml_attr_target ).
    CONVERT TIME STAMP excel->Lif_excel_book_properties~modified TIME ZONE sy-zonlo INTO DATE lv_date TIME lv_time.
    CONCATENATE lv_date lv_time INTO lv_value RESPECTING BLANKS.
    REPLACE ALL OCCURRENCES OF REGEX '([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})' IN lv_value WITH '$1-$2-$3T$4:$5:$6Z'.
    lo_element->set_value( value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).
  ENDMETHOD.
  METHOD create_dxf_style.

    CONSTANTS: lc_xml_node_dxf         TYPE string VALUE 'dxf',
               lc_xml_node_font        TYPE string VALUE 'font',
               lc_xml_node_b           TYPE string VALUE 'b',            "bold
               lc_xml_node_i           TYPE string VALUE 'i',            "italic
               lc_xml_node_u           TYPE string VALUE 'u',            "underline
               lc_xml_node_strike      TYPE string VALUE 'strike',       "strikethrough
               lc_xml_attr_val         TYPE string VALUE 'val',
               lc_xml_node_fill        TYPE string VALUE 'fill',
               lc_xml_node_patternfill TYPE string VALUE 'patternFill',
               lc_xml_attr_patterntype TYPE string VALUE 'patternType',
               lc_xml_node_fgcolor     TYPE string VALUE 'fgColor',
               lc_xml_node_bgcolor     TYPE string VALUE 'bgColor'.

    DATA: ls_styles_mapping     TYPE zexcel_s_styles_mapping,
          ls_cellxfs            TYPE zexcel_s_cellxfs,
          ls_style_cond_mapping TYPE zexcel_s_styles_cond_mapping,
          lo_sub_element        TYPE REF TO if_ixml_element,
          lo_sub_element_2      TYPE REF TO if_ixml_element,
          lv_index              TYPE i,
          ls_font               TYPE zexcel_s_style_font,
          lo_element_font       TYPE REF TO if_ixml_element,
          lv_value              TYPE string,
          ls_fill               TYPE zexcel_s_style_fill,
          lo_element_fill       TYPE REF TO if_ixml_element.

    CHECK iv_cell_style IS NOT INITIAL.

    READ TABLE me->styles_mapping INTO ls_styles_mapping WITH KEY guid = iv_cell_style.
    ADD 1 TO ls_styles_mapping-style. " the numbering starts from 0
    READ TABLE it_cellxfs INTO ls_cellxfs INDEX ls_styles_mapping-style.
    ADD 1 TO ls_cellxfs-fillid.       " the numbering starts from 0

    READ TABLE me->styles_cond_mapping INTO ls_style_cond_mapping WITH KEY style = ls_styles_mapping-style.
    IF sy-subrc EQ 0.
      ls_style_cond_mapping-guid  = iv_cell_style.
      APPEND ls_style_cond_mapping TO me->styles_cond_mapping.
    ELSE.
      ls_style_cond_mapping-guid  = iv_cell_style.
      ls_style_cond_mapping-style = ls_styles_mapping-style.
      ls_style_cond_mapping-dxf   = cv_dfx_count.
      APPEND ls_style_cond_mapping TO me->styles_cond_mapping.
      ADD 1 TO cv_dfx_count.

      " dxf node
      lo_sub_element = io_ixml_document->create_simple_element( name   = lc_xml_node_dxf
                                                                parent = io_ixml_document ).

      "Conditional formatting font style correction by Alessandro Iannacci START
      lv_index = ls_cellxfs-fontid + 1.
      READ TABLE it_fonts INTO ls_font INDEX lv_index.
      IF ls_font IS NOT INITIAL.
        lo_element_font = io_ixml_document->create_simple_element( name   = lc_xml_node_font
                                                              parent = io_ixml_document ).
        IF ls_font-bold EQ abap_true.
          lo_sub_element_2 = io_ixml_document->create_simple_element( name   = lc_xml_node_b
                                                               parent = io_ixml_document ).
          lo_element_font->append_child( new_child = lo_sub_element_2 ).
        ENDIF.
        IF ls_font-italic EQ abap_true.
          lo_sub_element_2 = io_ixml_document->create_simple_element( name   = lc_xml_node_i
                                                               parent = io_ixml_document ).
          lo_element_font->append_child( new_child = lo_sub_element_2 ).
        ENDIF.
        IF ls_font-underline EQ abap_true.
          lo_sub_element_2 = io_ixml_document->create_simple_element( name   = lc_xml_node_u
                                                               parent = io_ixml_document ).
          lv_value = ls_font-underline_mode.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_val
                                            value = lv_value ).
          lo_element_font->append_child( new_child = lo_sub_element_2 ).
        ENDIF.
        IF ls_font-strikethrough EQ abap_true.
          lo_sub_element_2 = io_ixml_document->create_simple_element( name   = lc_xml_node_strike
                                                               parent = io_ixml_document ).
          lo_element_font->append_child( new_child = lo_sub_element_2 ).
        ENDIF.
        "color
        create_xl_styles_color_node(
            io_document        = io_ixml_document
            io_parent          = lo_element_font
            is_color           = ls_font-color ).
        lo_sub_element->append_child( new_child = lo_element_font ).
      ENDIF.
      "---Conditional formatting font style correction by Alessandro Iannacci END


      READ TABLE it_fills INTO ls_fill INDEX ls_cellxfs-fillid.
      IF ls_fill IS NOT INITIAL.
        " fill properties
        lo_element_fill = io_ixml_document->create_simple_element( name   = lc_xml_node_fill
                                                                 parent = io_ixml_document ).
        "pattern
        lo_sub_element_2 = io_ixml_document->create_simple_element( name   = lc_xml_node_patternfill
                                                             parent = io_ixml_document ).
        lv_value = ls_fill-filltype.
        lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_patterntype
                                            value = lv_value ).
        " fgcolor
        create_xl_styles_color_node(
            io_document        = io_ixml_document
            io_parent          = lo_sub_element_2
            is_color           = ls_fill-fgcolor
            iv_color_elem_name = lc_xml_node_fgcolor ).

        IF  ls_fill-fgcolor-rgb IS INITIAL AND
          ls_fill-fgcolor-indexed EQ Lcl_excel_style_color=>c_indexed_not_set AND
          ls_fill-fgcolor-theme EQ Lcl_excel_style_color=>c_theme_not_set AND
          ls_fill-fgcolor-tint IS INITIAL AND ls_fill-bgcolor-indexed EQ Lcl_excel_style_color=>c_indexed_sys_foreground.

          " bgcolor
          create_xl_styles_color_node(
              io_document        = io_ixml_document
              io_parent          = lo_sub_element_2
              is_color           = ls_fill-bgcolor
              iv_color_elem_name = lc_xml_node_bgcolor ).

        ENDIF.

        lo_element_fill->append_child( new_child = lo_sub_element_2 ). "pattern

        lo_sub_element->append_child( new_child = lo_element_fill ).
      ENDIF.
    ENDIF.

    io_dxf_element->append_child( new_child = lo_sub_element ).
  ENDMETHOD.
  METHOD create_relationships.


** Constant node name
    DATA: lc_xml_node_relationships TYPE string VALUE 'Relationships',
          lc_xml_node_relationship  TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id            TYPE string VALUE 'Id',
          lc_xml_attr_type          TYPE string VALUE 'Type',
          lc_xml_attr_target        TYPE string VALUE 'Target',
          " Node namespace
          lc_xml_node_rels_ns       TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships',
          " Node id
          lc_xml_node_rid1_id       TYPE string VALUE 'rId1',
          lc_xml_node_rid2_id       TYPE string VALUE 'rId2',
          lc_xml_node_rid3_id       TYPE string VALUE 'rId3',
          " Node type
          lc_xml_node_rid1_tp       TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument',
          lc_xml_node_rid2_tp       TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
          lc_xml_node_rid3_tp       TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties',
          " Node target
          lc_xml_node_rid1_tg       TYPE string VALUE 'xl/workbook.xml',
          lc_xml_node_rid2_tg       TYPE string VALUE 'docProps/core.xml',
          lc_xml_node_rid3_tg       TYPE string VALUE 'docProps/app.xml'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_relationships
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_rels_ns ).

**********************************************************************
* STEP 4: Create subnodes
    " Theme node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                  value = lc_xml_node_rid3_id ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                  value = lc_xml_node_rid3_tp ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                  value = lc_xml_node_rid3_tg ).
    lo_element_root->append_child( new_child = lo_element ).

    " Styles node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                  value = lc_xml_node_rid2_id ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                  value = lc_xml_node_rid2_tp ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                  value = lc_xml_node_rid2_tg ).
    lo_element_root->append_child( new_child = lo_element ).

    " rels node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                  value = lc_xml_node_rid1_id ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                  value = lc_xml_node_rid1_tp ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                  value = lc_xml_node_rid1_tg ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).
  ENDMETHOD.
  METHOD create_xl_charts.


** Constant node name
    CONSTANTS: lc_xml_node_chartspace         TYPE string VALUE 'c:chartSpace',
               lc_xml_node_ns_c               TYPE string VALUE 'http://schemas.openxmlformats.org/drawingml/2006/chart',
               lc_xml_node_ns_a               TYPE string VALUE 'http://schemas.openxmlformats.org/drawingml/2006/main',
               lc_xml_node_ns_r               TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
               lc_xml_node_date1904           TYPE string VALUE 'c:date1904',
               lc_xml_node_lang               TYPE string VALUE 'c:lang',
               lc_xml_node_roundedcorners     TYPE string VALUE 'c:roundedCorners',
               lc_xml_node_altcont            TYPE string VALUE 'mc:AlternateContent',
               lc_xml_node_altcont_ns_mc      TYPE string VALUE 'http://schemas.openxmlformats.org/markup-compatibility/2006',
               lc_xml_node_choice             TYPE string VALUE 'mc:Choice',
               lc_xml_node_choice_ns_requires TYPE string VALUE 'c14',
               lc_xml_node_choice_ns_c14      TYPE string VALUE 'http://schemas.microsoft.com/office/drawing/2007/8/2/chart',
               lc_xml_node_style              TYPE string VALUE 'c14:style',
               lc_xml_node_fallback           TYPE string VALUE 'mc:Fallback',
               lc_xml_node_style2             TYPE string VALUE 'c:style',

               "---------------------------CHART
               lc_xml_node_chart              TYPE string VALUE 'c:chart',
               lc_xml_node_autotitledeleted   TYPE string VALUE 'c:autoTitleDeleted',
               "plotArea
               lc_xml_node_plotarea           TYPE string VALUE 'c:plotArea',
               lc_xml_node_layout             TYPE string VALUE 'c:layout',
               lc_xml_node_varycolors         TYPE string VALUE 'c:varyColors',
               lc_xml_node_ser                TYPE string VALUE 'c:ser',
               lc_xml_node_idx                TYPE string VALUE 'c:idx',
               lc_xml_node_order              TYPE string VALUE 'c:order',
               lc_xml_node_tx                 TYPE string VALUE 'c:tx',
               lc_xml_node_v                  TYPE string VALUE 'c:v',
               lc_xml_node_val                TYPE string VALUE 'c:val',
               lc_xml_node_cat                TYPE string VALUE 'c:cat',
               lc_xml_node_numref             TYPE string VALUE 'c:numRef',
               lc_xml_node_strref             TYPE string VALUE 'c:strRef',
               lc_xml_node_f                  TYPE string VALUE 'c:f', "this is the range
               lc_xml_node_overlap            TYPE string VALUE 'c:overlap',
               "note: numcache avoided
               lc_xml_node_dlbls              TYPE string VALUE 'c:dLbls',
               lc_xml_node_showlegendkey      TYPE string VALUE 'c:showLegendKey',
               lc_xml_node_showval            TYPE string VALUE 'c:showVal',
               lc_xml_node_showcatname        TYPE string VALUE 'c:showCatName',
               lc_xml_node_showsername        TYPE string VALUE 'c:showSerName',
               lc_xml_node_showpercent        TYPE string VALUE 'c:showPercent',
               lc_xml_node_showbubblesize     TYPE string VALUE 'c:showBubbleSize',
               "plotArea->pie
               lc_xml_node_piechart           TYPE string VALUE 'c:pieChart',
               lc_xml_node_showleaderlines    TYPE string VALUE 'c:showLeaderLines',
               lc_xml_node_firstsliceang      TYPE string VALUE 'c:firstSliceAng',
               "plotArea->line
               lc_xml_node_linechart          TYPE string VALUE 'c:lineChart',
               lc_xml_node_symbol             TYPE string VALUE 'c:symbol',
               lc_xml_node_marker             TYPE string VALUE 'c:marker',
               lc_xml_node_smooth             TYPE string VALUE 'c:smooth',
               "plotArea->bar
               lc_xml_node_invertifnegative   TYPE string VALUE 'c:invertIfNegative',
               lc_xml_node_barchart           TYPE string VALUE 'c:barChart',
               lc_xml_node_bardir             TYPE string VALUE 'c:barDir',
               lc_xml_node_gapwidth           TYPE string VALUE 'c:gapWidth',
               "plotArea->line + plotArea->bar
               lc_xml_node_grouping           TYPE string VALUE 'c:grouping',
               lc_xml_node_axid               TYPE string VALUE 'c:axId',
               lc_xml_node_catax              TYPE string VALUE 'c:catAx',
               lc_xml_node_valax              TYPE string VALUE 'c:valAx',
               lc_xml_node_scaling            TYPE string VALUE 'c:scaling',
               lc_xml_node_orientation        TYPE string VALUE 'c:orientation',
               lc_xml_node_delete             TYPE string VALUE 'c:delete',
               lc_xml_node_axpos              TYPE string VALUE 'c:axPos',
               lc_xml_node_numfmt             TYPE string VALUE 'c:numFmt',
               lc_xml_node_majorgridlines     TYPE string VALUE 'c:majorGridlines',
               lc_xml_node_majortickmark      TYPE string VALUE 'c:majorTickMark',
               lc_xml_node_minortickmark      TYPE string VALUE 'c:minorTickMark',
               lc_xml_node_ticklblpos         TYPE string VALUE 'c:tickLblPos',
               lc_xml_node_crossax            TYPE string VALUE 'c:crossAx',
               lc_xml_node_crosses            TYPE string VALUE 'c:crosses',
               lc_xml_node_auto               TYPE string VALUE 'c:auto',
               lc_xml_node_lblalgn            TYPE string VALUE 'c:lblAlgn',
               lc_xml_node_lbloffset          TYPE string VALUE 'c:lblOffset',
               lc_xml_node_nomultilvllbl      TYPE string VALUE 'c:noMultiLvlLbl',
               lc_xml_node_crossbetween       TYPE string VALUE 'c:crossBetween',
               "legend
               lc_xml_node_legend             TYPE string VALUE 'c:legend',
               "legend->pie
               lc_xml_node_legendpos          TYPE string VALUE 'c:legendPos',
*                  lc_xml_node_layout            TYPE string VALUE 'c:layout', "already exist
               lc_xml_node_overlay            TYPE string VALUE 'c:overlay',
               lc_xml_node_txpr               TYPE string VALUE 'c:txPr',
               lc_xml_node_bodypr             TYPE string VALUE 'a:bodyPr',
               lc_xml_node_lststyle           TYPE string VALUE 'a:lstStyle',
               lc_xml_node_p                  TYPE string VALUE 'a:p',
               lc_xml_node_ppr                TYPE string VALUE 'a:pPr',
               lc_xml_node_defrpr             TYPE string VALUE 'a:defRPr',
               lc_xml_node_endpararpr         TYPE string VALUE 'a:endParaRPr',
               "legend->bar + legend->line
               lc_xml_node_plotvisonly        TYPE string VALUE 'c:plotVisOnly',
               lc_xml_node_dispblanksas       TYPE string VALUE 'c:dispBlanksAs',
               lc_xml_node_showdlblsovermax   TYPE string VALUE 'c:showDLblsOverMax',
               "---------------------------END OF CHART

               lc_xml_node_printsettings      TYPE string VALUE 'c:printSettings',
               lc_xml_node_headerfooter       TYPE string VALUE 'c:headerFooter',
               lc_xml_node_pagemargins        TYPE string VALUE 'c:pageMargins',
               lc_xml_node_pagesetup          TYPE string VALUE 'c:pageSetup'.


    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element.


    DATA lo_element                               TYPE REF TO if_ixml_element.
    DATA lo_element2                              TYPE REF TO if_ixml_element.
    DATA lo_element3                              TYPE REF TO if_ixml_element.
    DATA lo_el_rootchart                           TYPE REF TO if_ixml_element.
    DATA lo_element4                              TYPE REF TO if_ixml_element.
    DATA lo_element5                              TYPE REF TO if_ixml_element.
    DATA lo_element6                              TYPE REF TO if_ixml_element.
    DATA lo_element7                              TYPE REF TO if_ixml_element.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

***********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_chartspace
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:c'
                                       value = lc_xml_node_ns_c ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:a'
                                       value = lc_xml_node_ns_a ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:r'
                                       value = lc_xml_node_ns_r ).

**********************************************************************
* STEP 4: Create chart

    DATA lo_chartb TYPE REF TO Lcl_excel_graph_bars.
    DATA lo_chartp TYPE REF TO Lcl_excel_graph_pie.
    DATA lo_chartl TYPE REF TO Lcl_excel_graph_line.
    DATA lo_chart TYPE REF TO Lcl_excel_graph.

    DATA ls_serie TYPE Lcl_excel_graph=>s_series.
    DATA ls_ax TYPE Lcl_excel_graph_bars=>s_ax.
    DATA lv_str TYPE string.

    "Identify chart type
    CASE io_drawing->graph_type.
      WHEN Lcl_excel_drawing=>c_graph_bars.
        lo_chartb ?= io_drawing->graph.
      WHEN Lcl_excel_drawing=>c_graph_pie.
        lo_chartp ?= io_drawing->graph.
      WHEN Lcl_excel_drawing=>c_graph_line.
        lo_chartl ?= io_drawing->graph.
      WHEN OTHERS.
    ENDCASE.


    lo_chart = io_drawing->graph.

    lo_element = lo_document->create_simple_element( name = lc_xml_node_date1904
                                                         parent = lo_element_root ).
    lo_element->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_1904val ).

    lo_element = lo_document->create_simple_element( name = lc_xml_node_lang
                                                         parent = lo_element_root ).
    lo_element->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_langval ).

    lo_element = lo_document->create_simple_element( name = lc_xml_node_roundedcorners
                                                         parent = lo_element_root ).
    lo_element->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_roundedcornersval ).

    lo_element = lo_document->create_simple_element( name = lc_xml_node_altcont
                                                         parent = lo_element_root ).
    lo_element->set_attribute_ns( name  = 'xmlns:mc'
                                      value = lc_xml_node_altcont_ns_mc ).

    "Choice
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_choice
                                                         parent = lo_element ).
    lo_element2->set_attribute_ns( name  = 'Requires'
                                      value = lc_xml_node_choice_ns_requires ).
    lo_element2->set_attribute_ns( name  = 'xmlns:c14'
                                      value = lc_xml_node_choice_ns_c14 ).

    "C14:style
    lo_element3 = lo_document->create_simple_element( name = lc_xml_node_style
                                                         parent = lo_element2 ).
    lo_element3->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_c14styleval ).

    "Fallback
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_fallback
                                                         parent = lo_element ).

    "C:style
    lo_element3 = lo_document->create_simple_element( name = lc_xml_node_style2
                                                         parent = lo_element2 ).
    lo_element3->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_styleval ).

    "---------------------------CHART
    lo_element = lo_document->create_simple_element( name = lc_xml_node_chart
                                                         parent = lo_element_root ).
    "Added
    IF lo_chart->title IS NOT INITIAL.
      lo_element2 = lo_document->create_simple_element( name = 'c:title'
                                                           parent = lo_element ).
      lo_element3 = lo_document->create_simple_element( name = 'c:tx'
                                                           parent = lo_element2 ).
      lo_element4 = lo_document->create_simple_element( name = 'c:rich'
                                                           parent = lo_element3 ).
      lo_element5 = lo_document->create_simple_element( name = 'a:bodyPr'
                                                           parent = lo_element4 ).
      lo_element5 = lo_document->create_simple_element( name = 'a:lstStyle'
                                                           parent = lo_element4 ).
      lo_element5 = lo_document->create_simple_element( name = 'a:p'
                                                           parent = lo_element4 ).
      lo_element6 = lo_document->create_simple_element( name = 'a:pPr'
                                                           parent = lo_element5 ).
      lo_element7 = lo_document->create_simple_element( name = 'a:defRPr'
                                                           parent = lo_element6 ).
      lo_element6 = lo_document->create_simple_element( name = 'a:r'
                                                           parent = lo_element5 ).
      lo_element7 = lo_document->create_simple_element( name = 'a:rPr'
                                                           parent = lo_element6 ).
      lo_element7->set_attribute_ns( name  = 'lang'
                                        value = 'en-US' ).
      lo_element7 = lo_document->create_simple_element( name = 'a:t'
                                                           parent = lo_element6 ).
      lo_element7->set_value( value = lo_chart->title ).
    ENDIF.
    "End
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_autotitledeleted
                                                         parent = lo_element ).
    lo_element2->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_autotitledeletedval ).

    "plotArea
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_plotarea
                                                       parent = lo_element ).
    lo_element3 = lo_document->create_simple_element( name = lc_xml_node_layout
                                                       parent = lo_element2 ).
    CASE io_drawing->graph_type.
      WHEN Lcl_excel_drawing=>c_graph_bars.
        "----bar
        lo_element3 = lo_document->create_simple_element( name = lc_xml_node_barchart
                                                     parent = lo_element2 ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_bardir
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_bardirval ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_grouping
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_groupingval ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_varycolors
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_varycolorsval ).

        "series
        LOOP AT lo_chartb->series INTO ls_serie.
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_ser
                                                     parent = lo_element3 ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_idx
                                                     parent = lo_element4 ).
          IF ls_serie-idx IS NOT INITIAL.
            lv_str = ls_serie-idx.
          ELSE.
            lv_str = sy-tabix - 1.
          ENDIF.
          CONDENSE lv_str.
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = lv_str ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_order
                                                     parent = lo_element4 ).
          lv_str = ls_serie-order.
          CONDENSE lv_str.
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = lv_str ).
          IF ls_serie-sername IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_tx
                                                      parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_v
                                                      parent = lo_element5 ).
            lo_element6->set_value( value = ls_serie-sername ).
          ENDIF.
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_invertifnegative
                                                     parent = lo_element4 ).
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = ls_serie-invertifnegative ).
          IF ls_serie-lbl IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_cat
                                                       parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_strref
                                                       parent = lo_element5 ).
            lo_element7 = lo_document->create_simple_element( name = lc_xml_node_f
                                                       parent = lo_element6 ).
            lo_element7->set_value( value = ls_serie-lbl ).
          ENDIF.
          IF ls_serie-ref IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_val
                                                       parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_numref
                                                       parent = lo_element5 ).
            lo_element7 = lo_document->create_simple_element( name = lc_xml_node_f
                                                       parent = lo_element6 ).
            lo_element7->set_value( value = ls_serie-ref ).
          ENDIF.
        ENDLOOP.
        "endseries
        IF lo_chartb->ns_groupingval = Lcl_excel_graph_bars=>c_groupingval_stacked.
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_overlap
                                                            parent = lo_element3 ).
          lo_element4->set_attribute_ns( name  = 'val'
                                         value = '100' ).
        ENDIF.

        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_dlbls
                                                     parent = lo_element3 ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showlegendkey
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_showlegendkeyval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showval
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_showvalval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showcatname
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_showcatnameval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showsername
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_showsernameval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showpercent
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_showpercentval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showbubblesize
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_showbubblesizeval ).

        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_gapwidth
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartb->ns_gapwidthval ).

        "axes
        lo_el_rootchart = lo_element3.
        LOOP AT lo_chartb->axes INTO ls_ax.
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axid
                                                     parent = lo_el_rootchart ).
          lo_element4->set_attribute_ns( name  = 'val'
                                  value = ls_ax-axid ).
          CASE ls_ax-type.
            WHEN Lcl_excel_graph_bars=>c_catax.
              lo_element3 = lo_document->create_simple_element( name = lc_xml_node_catax
                                                     parent = lo_element2 ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axid
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axid ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_scaling
                                                     parent = lo_element3 ).
              lo_element5 = lo_document->create_simple_element( name = lc_xml_node_orientation
                                                     parent = lo_element4 ).
              lo_element5->set_attribute_ns( name  = 'val'
                                             value = ls_ax-orientation ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_delete
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-delete ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_numfmt
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'formatCode'
                                             value = ls_ax-formatcode ).
              lo_element4->set_attribute_ns( name  = 'sourceLinked'
                                             value = ls_ax-sourcelinked ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_majortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-majortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_minortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-minortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_ticklblpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-ticklblpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crossax
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crossax ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crosses
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crosses ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_auto
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-auto ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_lblalgn
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-lblalgn ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_lbloffset
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-lbloffset ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_nomultilvllbl
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-nomultilvllbl ).
            WHEN Lcl_excel_graph_bars=>c_valax.
              lo_element3 = lo_document->create_simple_element( name = lc_xml_node_valax
                                                     parent = lo_element2 ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axid
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axid ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_scaling
                                                     parent = lo_element3 ).
              lo_element5 = lo_document->create_simple_element( name = lc_xml_node_orientation
                                                     parent = lo_element4 ).
              lo_element5->set_attribute_ns( name  = 'val'
                                             value = ls_ax-orientation ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_delete
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-delete ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_majorgridlines
                                                     parent = lo_element3 ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_numfmt
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'formatCode'
                                             value = ls_ax-formatcode ).
              lo_element4->set_attribute_ns( name  = 'sourceLinked'
                                             value = ls_ax-sourcelinked ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_majortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-majortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_minortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-minortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_ticklblpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-ticklblpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crossax
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crossax ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crosses
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crosses ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crossbetween
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crossbetween ).
            WHEN OTHERS.
          ENDCASE.
        ENDLOOP.
        "endaxes

      WHEN Lcl_excel_drawing=>c_graph_pie.
        "----pie
        lo_element3 = lo_document->create_simple_element( name = lc_xml_node_piechart
                                                     parent = lo_element2 ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_varycolors
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_varycolorsval ).

        "series
        LOOP AT lo_chartp->series INTO ls_serie.
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_ser
                                                     parent = lo_element3 ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_idx
                                                     parent = lo_element4 ).
          IF ls_serie-idx IS NOT INITIAL.
            lv_str = ls_serie-idx.
          ELSE.
            lv_str = sy-tabix - 1.
          ENDIF.
          CONDENSE lv_str.
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = lv_str ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_order
                                                     parent = lo_element4 ).
          lv_str = ls_serie-order.
          CONDENSE lv_str.
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = lv_str ).
          IF ls_serie-sername IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_tx
                                                      parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_v
                                                      parent = lo_element5 ).
            lo_element6->set_value( value = ls_serie-sername ).
          ENDIF.
          IF ls_serie-lbl IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_cat
                                                       parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_strref
                                                       parent = lo_element5 ).
            lo_element7 = lo_document->create_simple_element( name = lc_xml_node_f
                                                       parent = lo_element6 ).
            lo_element7->set_value( value = ls_serie-lbl ).
          ENDIF.
          IF ls_serie-ref IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_val
                                                       parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_numref
                                                       parent = lo_element5 ).
            lo_element7 = lo_document->create_simple_element( name = lc_xml_node_f
                                                       parent = lo_element6 ).
            lo_element7->set_value( value = ls_serie-ref ).
          ENDIF.
        ENDLOOP.
        "endseries

        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_dlbls
                                                     parent = lo_element3 ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showlegendkey
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_showlegendkeyval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showval
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_showvalval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showcatname
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_showcatnameval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showsername
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_showsernameval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showpercent
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_showpercentval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showbubblesize
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_showbubblesizeval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showleaderlines
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_showleaderlinesval ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_firstsliceang
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartp->ns_firstsliceangval ).
      WHEN Lcl_excel_drawing=>c_graph_line.
        "----line
        lo_element3 = lo_document->create_simple_element( name = lc_xml_node_linechart
                                                     parent = lo_element2 ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_grouping
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_groupingval ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_varycolors
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_varycolorsval ).

        "series
        LOOP AT lo_chartl->series INTO ls_serie.
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_ser
                                                     parent = lo_element3 ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_idx
                                                     parent = lo_element4 ).
          IF ls_serie-idx IS NOT INITIAL.
            lv_str = ls_serie-idx.
          ELSE.
            lv_str = sy-tabix - 1.
          ENDIF.
          CONDENSE lv_str.
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = lv_str ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_order
                                                     parent = lo_element4 ).
          lv_str = ls_serie-order.
          CONDENSE lv_str.
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = lv_str ).
          IF ls_serie-sername IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_tx
                                                      parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_v
                                                      parent = lo_element5 ).
            lo_element6->set_value( value = ls_serie-sername ).
          ENDIF.
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_marker
                                                     parent = lo_element4 ).
          lo_element6 = lo_document->create_simple_element( name = lc_xml_node_symbol
                                                     parent = lo_element5 ).
          lo_element6->set_attribute_ns( name  = 'val'
                                  value = ls_serie-symbol ).
          IF ls_serie-lbl IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_cat
                                                       parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_strref
                                                       parent = lo_element5 ).
            lo_element7 = lo_document->create_simple_element( name = lc_xml_node_f
                                                       parent = lo_element6 ).
            lo_element7->set_value( value = ls_serie-lbl ).
          ENDIF.
          IF ls_serie-ref IS NOT INITIAL.
            lo_element5 = lo_document->create_simple_element( name = lc_xml_node_val
                                                       parent = lo_element4 ).
            lo_element6 = lo_document->create_simple_element( name = lc_xml_node_numref
                                                       parent = lo_element5 ).
            lo_element7 = lo_document->create_simple_element( name = lc_xml_node_f
                                                       parent = lo_element6 ).
            lo_element7->set_value( value = ls_serie-ref ).
          ENDIF.
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_smooth
                                                       parent = lo_element4 ).
          lo_element5->set_attribute_ns( name  = 'val'
                                  value = ls_serie-smooth ).
        ENDLOOP.
        "endseries

        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_dlbls
                                                     parent = lo_element3 ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showlegendkey
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_showlegendkeyval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showval
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_showvalval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showcatname
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_showcatnameval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showsername
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_showsernameval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showpercent
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_showpercentval ).
        lo_element5 = lo_document->create_simple_element( name = lc_xml_node_showbubblesize
                                                     parent = lo_element4 ).
        lo_element5->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_showbubblesizeval ).

        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_marker
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_markerval ).
        lo_element4 = lo_document->create_simple_element( name = lc_xml_node_smooth
                                                     parent = lo_element3 ).
        lo_element4->set_attribute_ns( name  = 'val'
                                  value = lo_chartl->ns_smoothval ).

        "axes
        lo_el_rootchart = lo_element3.
        LOOP AT lo_chartl->axes INTO ls_ax.
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axid
                                                     parent = lo_el_rootchart ).
          lo_element4->set_attribute_ns( name  = 'val'
                                  value = ls_ax-axid ).
          CASE ls_ax-type.
            WHEN Lcl_excel_graph_line=>c_catax.
              lo_element3 = lo_document->create_simple_element( name = lc_xml_node_catax
                                                     parent = lo_element2 ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axid
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axid ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_scaling
                                                     parent = lo_element3 ).
              lo_element5 = lo_document->create_simple_element( name = lc_xml_node_orientation
                                                     parent = lo_element4 ).
              lo_element5->set_attribute_ns( name  = 'val'
                                             value = ls_ax-orientation ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_delete
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-delete ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_majortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-majortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_minortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-minortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_ticklblpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-ticklblpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crossax
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crossax ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crosses
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crosses ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_auto
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-auto ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_lblalgn
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-lblalgn ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_lbloffset
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-lbloffset ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_nomultilvllbl
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-nomultilvllbl ).
            WHEN Lcl_excel_graph_line=>c_valax.
              lo_element3 = lo_document->create_simple_element( name = lc_xml_node_valax
                                                     parent = lo_element2 ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axid
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axid ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_scaling
                                                     parent = lo_element3 ).
              lo_element5 = lo_document->create_simple_element( name = lc_xml_node_orientation
                                                     parent = lo_element4 ).
              lo_element5->set_attribute_ns( name  = 'val'
                                             value = ls_ax-orientation ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_delete
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-delete ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_axpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-axpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_majorgridlines
                                                     parent = lo_element3 ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_numfmt
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'formatCode'
                                             value = ls_ax-formatcode ).
              lo_element4->set_attribute_ns( name  = 'sourceLinked'
                                             value = ls_ax-sourcelinked ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_majortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-majortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_minortickmark
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-minortickmark ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_ticklblpos
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-ticklblpos ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crossax
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crossax ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crosses
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crosses ).
              lo_element4 = lo_document->create_simple_element( name = lc_xml_node_crossbetween
                                                     parent = lo_element3 ).
              lo_element4->set_attribute_ns( name  = 'val'
                                             value = ls_ax-crossbetween ).
            WHEN OTHERS.
          ENDCASE.
        ENDLOOP.
        "endaxes

      WHEN OTHERS.
    ENDCASE.

    "legend
    IF lo_chart->print_label EQ abap_true.
      lo_element2 = lo_document->create_simple_element( name = lc_xml_node_legend
                                                         parent = lo_element ).
      CASE io_drawing->graph_type.
        WHEN Lcl_excel_drawing=>c_graph_bars.
          "----bar
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_legendpos
                                                       parent = lo_element2 ).
          lo_element3->set_attribute_ns( name  = 'val'
                                    value = lo_chartb->ns_legendposval ).
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_layout
                                                       parent = lo_element2 ).
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_overlay
                                                       parent = lo_element2 ).
          lo_element3->set_attribute_ns( name  = 'val'
                                    value = lo_chartb->ns_overlayval ).
        WHEN Lcl_excel_drawing=>c_graph_line.
          "----line
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_legendpos
                                                       parent = lo_element2 ).
          lo_element3->set_attribute_ns( name  = 'val'
                                    value = lo_chartl->ns_legendposval ).
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_layout
                                                       parent = lo_element2 ).
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_overlay
                                                       parent = lo_element2 ).
          lo_element3->set_attribute_ns( name  = 'val'
                                    value = lo_chartl->ns_overlayval ).
        WHEN Lcl_excel_drawing=>c_graph_pie.
          "----pie
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_legendpos
                                                       parent = lo_element2 ).
          lo_element3->set_attribute_ns( name  = 'val'
                                    value = lo_chartp->ns_legendposval ).
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_layout
                                                       parent = lo_element2 ).
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_overlay
                                                       parent = lo_element2 ).
          lo_element3->set_attribute_ns( name  = 'val'
                                    value = lo_chartp->ns_overlayval ).
          lo_element3 = lo_document->create_simple_element( name = lc_xml_node_txpr
                                                       parent = lo_element2 ).
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_bodypr
                                                       parent = lo_element3 ).
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_lststyle
                                                       parent = lo_element3 ).
          lo_element4 = lo_document->create_simple_element( name = lc_xml_node_p
                                                       parent = lo_element3 ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_ppr
                                                       parent = lo_element4 ).
          lo_element5->set_attribute_ns( name  = 'rtl'
                                    value = lo_chartp->ns_pprrtl ).
          lo_element6 = lo_document->create_simple_element( name = lc_xml_node_defrpr
                                                       parent = lo_element5 ).
          lo_element5 = lo_document->create_simple_element( name = lc_xml_node_endpararpr
                                                       parent = lo_element4 ).
          lo_element5->set_attribute_ns( name  = 'lang'
                                    value = lo_chartp->ns_endpararprlang ).
        WHEN OTHERS.
      ENDCASE.
    ENDIF.

    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_plotvisonly
                                                         parent = lo_element ).
    lo_element2->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_plotvisonlyval ).
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_dispblanksas
                                                         parent = lo_element ).
    lo_element2->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_dispblanksasval ).
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_showdlblsovermax
                                                         parent = lo_element ).
    lo_element2->set_attribute_ns( name  = 'val'
                                      value = lo_chart->ns_showdlblsovermaxval ).
    "---------------------------END OF CHART

    "printSettings
    lo_element = lo_document->create_simple_element( name = lc_xml_node_printsettings
                                                         parent = lo_element_root ).
    "headerFooter
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_headerfooter
                                                         parent = lo_element ).
    "pageMargins
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_pagemargins
                                                         parent = lo_element ).
    lo_element2->set_attribute_ns( name  = 'b'
                                      value = lo_chart->pagemargins-b ).
    lo_element2->set_attribute_ns( name  = 'l'
                                      value = lo_chart->pagemargins-l ).
    lo_element2->set_attribute_ns( name  = 'r'
                                      value = lo_chart->pagemargins-r ).
    lo_element2->set_attribute_ns( name  = 't'
                                      value = lo_chart->pagemargins-t ).
    lo_element2->set_attribute_ns( name  = 'header'
                                      value = lo_chart->pagemargins-header ).
    lo_element2->set_attribute_ns( name  = 'footer'
                                      value = lo_chart->pagemargins-footer ).
    "pageSetup
    lo_element2 = lo_document->create_simple_element( name = lc_xml_node_pagesetup
                                                         parent = lo_element ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).
  ENDMETHOD.
  METHOD create_xl_comments.
** Constant node name
    CONSTANTS: lc_xml_node_comments    TYPE string VALUE 'comments',
               lc_xml_node_ns          TYPE string VALUE 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
               " authors
               lc_xml_node_author      TYPE string VALUE 'author',
               lc_xml_node_authors     TYPE string VALUE 'authors',
               " comments
               lc_xml_node_commentlist TYPE string VALUE 'commentList',
               lc_xml_node_comment     TYPE string VALUE 'comment',
               lc_xml_node_text        TYPE string VALUE 'text',
               lc_xml_node_r           TYPE string VALUE 'r',
               lc_xml_node_rpr         TYPE string VALUE 'rPr',
               lc_xml_node_b           TYPE string VALUE 'b',
               lc_xml_node_sz          TYPE string VALUE 'sz',
               lc_xml_node_color       TYPE string VALUE 'color',
               lc_xml_node_rfont       TYPE string VALUE 'rFont',
*             lc_xml_node_charset     TYPE string VALUE 'charset',
               lc_xml_node_family      TYPE string VALUE 'family',
               lc_xml_node_t           TYPE string VALUE 't',
               " comments attributes
               lc_xml_attr_ref         TYPE string VALUE 'ref',
               lc_xml_attr_authorid    TYPE string VALUE 'authorId',
               lc_xml_attr_val         TYPE string VALUE 'val',
               lc_xml_attr_indexed     TYPE string VALUE 'indexed',
               lc_xml_attr_xmlspacing  TYPE string VALUE 'xml:space'.


    DATA: lo_document            TYPE REF TO if_ixml_document,
          lo_element_root        TYPE REF TO if_ixml_element,
          lo_element_authors     TYPE REF TO if_ixml_element,
          lo_element_author      TYPE REF TO if_ixml_element,
          lo_element_commentlist TYPE REF TO if_ixml_element,
          lo_element_comment     TYPE REF TO if_ixml_element,
          lo_element_text        TYPE REF TO if_ixml_element,
          lo_element_r           TYPE REF TO if_ixml_element,
          lo_element_rpr         TYPE REF TO if_ixml_element,
          lo_element_b           TYPE REF TO if_ixml_element,
          lo_element_sz          TYPE REF TO if_ixml_element,
          lo_element_color       TYPE REF TO if_ixml_element,
          lo_element_rfont       TYPE REF TO if_ixml_element,
*       lo_element_charset     TYPE REF TO if_ixml_element,
          lo_element_family      TYPE REF TO if_ixml_element,
          lo_element_t           TYPE REF TO if_ixml_element,
          lo_iterator            TYPE REF TO Lcl_excel_collection_iterator,
          lo_comments            TYPE REF TO Lcl_excel_comments,
          lo_comment             TYPE REF TO Lcl_excel_comment.
    DATA: lv_rel_id TYPE i,
          lv_author TYPE string.


**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

***********************************************************************
* STEP 3: Create main node relationships
    lo_element_root = lo_document->create_simple_element( name   = lc_xml_node_comments
                                                          parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_ns ).

**********************************************************************
* STEP 4: Create authors
* TO-DO: management of several authors
    lo_element_authors = lo_document->create_simple_element( name   = lc_xml_node_authors
                                                             parent = lo_document ).

    lo_element_author  = lo_document->create_simple_element( name   = lc_xml_node_author
                                                             parent = lo_document ).
    lv_author = sy-uname.
    lo_element_author->set_value( lv_author ).

    lo_element_authors->append_child( new_child = lo_element_author ).
    lo_element_root->append_child( new_child = lo_element_authors ).

**********************************************************************
* STEP 5: Create comments

    lo_element_commentlist = lo_document->create_simple_element( name   = lc_xml_node_commentlist
                                                                 parent = lo_document ).

    lo_comments = io_worksheet->get_comments( ).

    lo_iterator = lo_comments->get_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_comment ?= lo_iterator->get_next( ).

      lo_element_comment = lo_document->create_simple_element( name   = lc_xml_node_comment
                                                               parent = lo_document ).
      lo_element_comment->set_attribute_ns( name  = lc_xml_attr_ref
                                            value = lo_comment->get_ref( ) ).
      lo_element_comment->set_attribute_ns( name  = lc_xml_attr_authorid
                                            value = '0' ).  " TO-DO

      lo_element_text = lo_document->create_simple_element( name   = lc_xml_node_text
                                                            parent = lo_document ).
      lo_element_r    = lo_document->create_simple_element( name   = lc_xml_node_r
                                                            parent = lo_document ).
      lo_element_rpr  = lo_document->create_simple_element( name   = lc_xml_node_rpr
                                                            parent = lo_document ).

      lo_element_b    = lo_document->create_simple_element( name   = lc_xml_node_b
                                                            parent = lo_document ).
      lo_element_rpr->append_child( new_child = lo_element_b ).

      add_1_val_child_node( io_document = lo_document io_parent = lo_element_rpr iv_elem_name = lc_xml_node_sz     iv_attr_name = lc_xml_attr_val     iv_attr_value = '9' ).
      add_1_val_child_node( io_document = lo_document io_parent = lo_element_rpr iv_elem_name = lc_xml_node_color  iv_attr_name = lc_xml_attr_indexed iv_attr_value = '81' ).
      add_1_val_child_node( io_document = lo_document io_parent = lo_element_rpr iv_elem_name = lc_xml_node_rfont  iv_attr_name = lc_xml_attr_val     iv_attr_value = 'Tahoma' ).
      add_1_val_child_node( io_document = lo_document io_parent = lo_element_rpr iv_elem_name = lc_xml_node_family iv_attr_name = lc_xml_attr_val     iv_attr_value = '2' ).

      lo_element_r->append_child( new_child = lo_element_rpr ).

      lo_element_t    = lo_document->create_simple_element( name   = lc_xml_node_t
                                                            parent = lo_document ).
      lo_element_t->set_attribute_ns( name  = lc_xml_attr_xmlspacing
                                      value = 'preserve' ).
      lo_element_t->set_value( lo_comment->get_text( ) ).
      lo_element_r->append_child( new_child = lo_element_t ).

      lo_element_text->append_child( new_child = lo_element_r ).
      lo_element_comment->append_child( new_child = lo_element_text ).
      lo_element_commentlist->append_child( new_child = lo_element_comment ).
    ENDWHILE.

    lo_element_root->append_child( new_child = lo_element_commentlist ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_drawings.


** Constant node name
    CONSTANTS: lc_xml_node_wsdr   TYPE string VALUE 'xdr:wsDr',
               lc_xml_node_ns_xdr TYPE string VALUE 'http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing',
               lc_xml_node_ns_a   TYPE string VALUE 'http://schemas.openxmlformats.org/drawingml/2006/main'.

    DATA: lo_document           TYPE REF TO if_ixml_document,
          lo_element_root       TYPE REF TO if_ixml_element,
          lo_element_cellanchor TYPE REF TO if_ixml_element,
          lo_iterator           TYPE REF TO Lcl_excel_collection_iterator,
          lo_drawings           TYPE REF TO Lcl_excel_drawings,
          lo_drawing            TYPE REF TO Lcl_excel_drawing.
    DATA: lv_rel_id            TYPE i.



**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

***********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_wsdr
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:xdr'
                                       value = lc_xml_node_ns_xdr ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:a'
                                       value = lc_xml_node_ns_a ).

**********************************************************************
* STEP 4: Create drawings

    CLEAR: lv_rel_id.

    lo_drawings = io_worksheet->get_drawings( ).

    lo_iterator = lo_drawings->get_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_drawing ?= lo_iterator->get_next( ).

      ADD 1 TO lv_rel_id.
      lo_element_cellanchor = me->create_xl_drawing_anchor(
              io_drawing    = lo_drawing
              io_document   = lo_document
              ip_index      = lv_rel_id ).

      lo_element_root->append_child( new_child = lo_element_cellanchor ).

    ENDWHILE.

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_drawings_hdft_rels.

** Constant node name
    DATA: lc_xml_node_relationships TYPE string VALUE 'Relationships',
          lc_xml_node_relationship  TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id            TYPE string VALUE 'Id',
          lc_xml_attr_type          TYPE string VALUE 'Type',
          lc_xml_attr_target        TYPE string VALUE 'Target',
          " Node namespace
          lc_xml_node_rels_ns       TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships',
          lc_xml_node_rid_image_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
          lc_xml_node_rid_chart_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart'.

    DATA: lo_drawing      TYPE REF TO Lcl_excel_drawing,
          lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element,
          lv_value        TYPE string,
          lv_relation_id  TYPE i,
          lt_temp         TYPE strtable,
          lt_drawings     TYPE zexcel_t_drawings.

    FIELD-SYMBOLS: <fs_temp>     TYPE sstrtable,
                   <fs_drawings> TYPE zexcel_s_drawings.


* BODY
**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_relationships
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_rels_ns ).

**********************************************************************
* STEP 4: Create subnodes

**********************************************************************


    lt_drawings = io_worksheet->get_header_footer_drawings( ).
    LOOP AT lt_drawings ASSIGNING <fs_drawings>. "Header or footer image exist
      ADD 1 TO lv_relation_id.
      lv_value = <fs_drawings>-drawing->get_index( ).
      READ TABLE lt_temp WITH KEY str = lv_value TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        APPEND INITIAL LINE TO lt_temp ASSIGNING <fs_temp>.
        <fs_temp>-row_index = sy-tabix.
        <fs_temp>-str = lv_value.
        CONDENSE lv_value.
        CONCATENATE 'rId' lv_value INTO lv_value.
        lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                           parent = lo_document ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                      value = lv_value ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                      value = lc_xml_node_rid_image_tp ).

        lv_value = '../media/#'.
        REPLACE '#' IN lv_value WITH <fs_drawings>-drawing->get_media_name( ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                      value = lv_value ).
        lo_element_root->append_child( new_child = lo_element ).
      ENDIF.
    ENDLOOP.

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.                    "create_xl_drawings_hdft_rels
  METHOD create_xl_drawings_rels.

** Constant node name
    DATA: lc_xml_node_relationships TYPE string VALUE 'Relationships',
          lc_xml_node_relationship  TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id            TYPE string VALUE 'Id',
          lc_xml_attr_type          TYPE string VALUE 'Type',
          lc_xml_attr_target        TYPE string VALUE 'Target',
          " Node namespace
          lc_xml_node_rels_ns       TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships',
          lc_xml_node_rid_image_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
          lc_xml_node_rid_chart_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element,
          lo_iterator     TYPE REF TO Lcl_excel_collection_iterator,
          lo_drawings     TYPE REF TO Lcl_excel_drawings,
          lo_drawing      TYPE REF TO Lcl_excel_drawing.

    DATA: lv_value   TYPE string,
          lv_counter TYPE i.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_relationships
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_rels_ns ).

**********************************************************************
* STEP 4: Create subnodes

    " Add sheet Relationship nodes here
    lv_counter = 0.
    lo_drawings = io_worksheet->get_drawings( ).
    lo_iterator = lo_drawings->get_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_drawing ?= lo_iterator->get_next( ).
      ADD 1 TO lv_counter.

      lv_value = lv_counter.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.

      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                   parent = lo_document ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                    value = lv_value ).

      lv_value = lo_drawing->get_media_name( ).
      CASE lo_drawing->get_type( ).
        WHEN Lcl_excel_drawing=>type_image.
          CONCATENATE '../media/' lv_value INTO lv_value.
          lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                        value = lc_xml_node_rid_image_tp ).

        WHEN Lcl_excel_drawing=>type_chart.
          CONCATENATE '../charts/' lv_value INTO lv_value.
          lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                        value = lc_xml_node_rid_chart_tp ).

      ENDCASE.
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                    value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDWHILE.


**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_drawings_vml.

    DATA:
      lo_xml_document TYPE REF TO cl_xml_document,
      ld_stream       TYPE string.


* INIT_RESULT
    CLEAR ep_content.


* BODY
    ld_stream = set_vml_string( ).

    CREATE OBJECT lo_xml_document.
    CALL METHOD lo_xml_document->parse_string
      EXPORTING
        stream = ld_stream.

    CALL FUNCTION 'SCMS_STRING_TO_XSTRING'
      EXPORTING
        text   = ld_stream
      IMPORTING
        buffer = ep_content
      EXCEPTIONS
        failed = 1
        OTHERS = 2.
    IF sy-subrc <> 0.
      CLEAR ep_content.
    ENDIF.


  ENDMETHOD.
  METHOD create_xl_drawings_vml_rels.

** Constant node name
    DATA: lc_xml_node_relationships TYPE string VALUE 'Relationships',
          lc_xml_node_relationship  TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id            TYPE string VALUE 'Id',
          lc_xml_attr_type          TYPE string VALUE 'Type',
          lc_xml_attr_target        TYPE string VALUE 'Target',
          " Node namespace
          lc_xml_node_rels_ns       TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships',
          lc_xml_node_rid_image_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image',
          lc_xml_node_rid_chart_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart'.

    DATA: lo_iterator     TYPE REF TO Lcl_excel_collection_iterator,
          lo_drawing      TYPE REF TO Lcl_excel_drawing,
          lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element,
          lv_value        TYPE string,
          lv_relation_id  TYPE i.


* BODY
**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_relationships
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_rels_ns ).

**********************************************************************
* STEP 4: Create subnodes
    lv_relation_id = 0.
    lo_iterator = me->excel->get_drawings_iterator( Lcl_excel_drawing=>type_image ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_drawing ?= lo_iterator->get_next( ).
      IF lo_drawing->get_type( ) = Lcl_excel_drawing=>type_image_header_footer.
        ADD 1 TO lv_relation_id.
        lv_value = lv_relation_id.
        CONDENSE lv_value.
        CONCATENATE 'rId' lv_value INTO lv_value.
        lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                           parent = lo_document ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_id
*                                    value = 'LOGO' ).
                                      value = lv_value ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                      value = lc_xml_node_rid_image_tp ).

        lv_value = '../media/#'.
        REPLACE '#' IN lv_value WITH lo_drawing->get_media_name( ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_target
*                                    value = '../media/LOGO.png' ).
                                      value = lv_value ).
        lo_element_root->append_child( new_child = lo_element ).
      ENDIF.

    ENDWHILE.



**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_drawing_anchor.

** Constant node name
    CONSTANTS: lc_xml_node_onecellanchor     TYPE string VALUE 'xdr:oneCellAnchor',
               lc_xml_node_twocellanchor     TYPE string VALUE 'xdr:twoCellAnchor',
               lc_xml_node_from              TYPE string VALUE 'xdr:from',
               lc_xml_node_to                TYPE string VALUE 'xdr:to',
               lc_xml_node_pic               TYPE string VALUE 'xdr:pic',
               lc_xml_node_ext               TYPE string VALUE 'xdr:ext',
               lc_xml_node_clientdata        TYPE string VALUE 'xdr:clientData',

               lc_xml_node_col               TYPE string VALUE 'xdr:col',
               lc_xml_node_coloff            TYPE string VALUE 'xdr:colOff',
               lc_xml_node_row               TYPE string VALUE 'xdr:row',
               lc_xml_node_rowoff            TYPE string VALUE 'xdr:rowOff',

               lc_xml_node_nvpicpr           TYPE string VALUE 'xdr:nvPicPr',
               lc_xml_node_cnvpr             TYPE string VALUE 'xdr:cNvPr',
               lc_xml_node_cnvpicpr          TYPE string VALUE 'xdr:cNvPicPr',
               lc_xml_node_piclocks          TYPE string VALUE 'a:picLocks',

               lc_xml_node_sppr              TYPE string VALUE 'xdr:spPr',
               lc_xml_node_apgeom            TYPE string VALUE 'a:prstGeom',
               lc_xml_node_aavlst            TYPE string VALUE 'a:avLst',

               lc_xml_node_graphicframe      TYPE string VALUE 'xdr:graphicFrame',
               lc_xml_node_nvgraphicframepr  TYPE string VALUE 'xdr:nvGraphicFramePr',
               lc_xml_node_cnvgraphicframepr TYPE string VALUE 'xdr:cNvGraphicFramePr',
               lc_xml_node_graphicframelocks TYPE string VALUE 'a:graphicFrameLocks',
               lc_xml_node_xfrm              TYPE string VALUE 'xdr:xfrm',
               lc_xml_node_aoff              TYPE string VALUE 'a:off',
               lc_xml_node_aext              TYPE string VALUE 'a:ext',
               lc_xml_node_agraphic          TYPE string VALUE 'a:graphic',
               lc_xml_node_agraphicdata      TYPE string VALUE 'a:graphicData',

               lc_xml_node_ns_c              TYPE string VALUE 'http://schemas.openxmlformats.org/drawingml/2006/chart',
               lc_xml_node_cchart            TYPE string VALUE 'c:chart',

               lc_xml_node_blipfill          TYPE string VALUE 'xdr:blipFill',
               lc_xml_node_ablip             TYPE string VALUE 'a:blip',
               lc_xml_node_astretch          TYPE string VALUE 'a:stretch',
               lc_xml_node_ns_r              TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships'.

    DATA: lo_element_graphicframe TYPE REF TO if_ixml_element,
          lo_element              TYPE REF TO if_ixml_element,
          lo_element2             TYPE REF TO if_ixml_element,
          lo_element3             TYPE REF TO if_ixml_element,
          lo_element_from         TYPE REF TO if_ixml_element,
          lo_element_to           TYPE REF TO if_ixml_element,
          lo_element_ext          TYPE REF TO if_ixml_element,
          lo_element_pic          TYPE REF TO if_ixml_element,
          lo_element_clientdata   TYPE REF TO if_ixml_element,
          ls_position             TYPE zexcel_drawing_position,
          lv_col                  TYPE string, " zexcel_cell_column,
          lv_row                  TYPE string, " zexcel_cell_row.
          lv_col_offset           TYPE string,
          lv_row_offset           TYPE string,
          lv_value                TYPE string.

    ls_position = io_drawing->get_position( ).

    IF ls_position-anchor = 'ONE'.
      ep_anchor = io_document->create_simple_element( name   = lc_xml_node_onecellanchor
                                                                  parent = io_document ).
    ELSE.
      ep_anchor = io_document->create_simple_element( name   = lc_xml_node_twocellanchor
                                                                  parent = io_document ).
    ENDIF.

*   from cell ******************************
    lo_element_from = io_document->create_simple_element( name   = lc_xml_node_from
                                                          parent = io_document ).

    lv_col = ls_position-from-col.
    lv_row = ls_position-from-row.
    lv_col_offset = ls_position-from-col_offset.
    lv_row_offset = ls_position-from-row_offset.
    CONDENSE lv_col NO-GAPS.
    CONDENSE lv_row NO-GAPS.
    CONDENSE lv_col_offset NO-GAPS.
    CONDENSE lv_row_offset NO-GAPS.

    lo_element = io_document->create_simple_element( name = lc_xml_node_col
                                                     parent = io_document ).
    lo_element->set_value( value = lv_col ).
    lo_element_from->append_child( new_child = lo_element ).

    lo_element = io_document->create_simple_element( name = lc_xml_node_coloff
                                                     parent = io_document ).
    lo_element->set_value( value = lv_col_offset ).
    lo_element_from->append_child( new_child = lo_element ).

    lo_element = io_document->create_simple_element( name = lc_xml_node_row
                                                     parent = io_document ).
    lo_element->set_value( value = lv_row ).
    lo_element_from->append_child( new_child = lo_element ).

    lo_element = io_document->create_simple_element( name = lc_xml_node_rowoff
                                                     parent = io_document ).
    lo_element->set_value( value = lv_row_offset ).
    lo_element_from->append_child( new_child = lo_element ).
    ep_anchor->append_child( new_child = lo_element_from ).

    IF ls_position-anchor = 'ONE'.

*   ext ******************************
      lo_element_ext = io_document->create_simple_element( name   = lc_xml_node_ext
                                                           parent = io_document ).

      lv_value = io_drawing->get_width_emu_str( ).
      lo_element_ext->set_attribute_ns( name  = 'cx'
                                     value = lv_value ).
      lv_value = io_drawing->get_height_emu_str( ).
      lo_element_ext->set_attribute_ns( name  = 'cy'
                                     value = lv_value ).
      ep_anchor->append_child( new_child = lo_element_ext ).

    ELSEIF ls_position-anchor = 'TWO'.

*   to cell ******************************
      lo_element_to = io_document->create_simple_element( name   = lc_xml_node_to
                                                          parent = io_document ).

      lv_col = ls_position-to-col.
      lv_row = ls_position-to-row.
      lv_col_offset = ls_position-to-col_offset.
      lv_row_offset = ls_position-to-row_offset.
      CONDENSE lv_col NO-GAPS.
      CONDENSE lv_row NO-GAPS.
      CONDENSE lv_col_offset NO-GAPS.
      CONDENSE lv_row_offset NO-GAPS.

      lo_element = io_document->create_simple_element( name = lc_xml_node_col
                                                       parent = io_document ).
      lo_element->set_value( value = lv_col ).
      lo_element_to->append_child( new_child = lo_element ).

      lo_element = io_document->create_simple_element( name = lc_xml_node_coloff
                                                       parent = io_document ).
      lo_element->set_value( value = lv_col_offset ).
      lo_element_to->append_child( new_child = lo_element ).

      lo_element = io_document->create_simple_element( name = lc_xml_node_row
                                                       parent = io_document ).
      lo_element->set_value( value = lv_row ).
      lo_element_to->append_child( new_child = lo_element ).

      lo_element = io_document->create_simple_element( name = lc_xml_node_rowoff
                                                       parent = io_document ).
      lo_element->set_value( value = lv_row_offset ).
      lo_element_to->append_child( new_child = lo_element ).
      ep_anchor->append_child( new_child = lo_element_to ).

    ENDIF.

    CASE io_drawing->get_type( ).
      WHEN Lcl_excel_drawing=>type_image.
*     pic **********************************
        lo_element_pic = io_document->create_simple_element( name   = lc_xml_node_pic
                                                             parent = io_document ).
*     nvPicPr
        lo_element  = io_document->create_simple_element( name = lc_xml_node_nvpicpr
                                                          parent = io_document ).
*     cNvPr
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_cnvpr
                                                          parent = io_document ).
        lv_value = sy-index.
        CONDENSE lv_value.
        lo_element2->set_attribute_ns( name  = 'id'
                                       value = lv_value ).
        lo_element2->set_attribute_ns( name  = 'name'
                                       value = io_drawing->title ).
        lo_element->append_child( new_child = lo_element2 ).

*     cNvPicPr
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_cnvpicpr
                                                          parent = io_document ).

*     picLocks
        lo_element3 = io_document->create_simple_element( name = lc_xml_node_piclocks
                                                          parent = io_document ).
        lo_element3->set_attribute_ns( name  = 'noChangeAspect'
                                       value = '1' ).

        lo_element2->append_child( new_child = lo_element3 ).
        lo_element->append_child( new_child = lo_element2 ).
        lo_element_pic->append_child( new_child = lo_element ).

*     blipFill
        lv_value = ip_index.
        CONDENSE lv_value.
        CONCATENATE 'rId' lv_value INTO lv_value.

        lo_element  = io_document->create_simple_element( name = lc_xml_node_blipfill
                                                          parent = io_document ).
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_ablip
                                                          parent = io_document ).
        lo_element2->set_attribute_ns( name  = 'xmlns:r'
                                       value = lc_xml_node_ns_r ).
        lo_element2->set_attribute_ns( name  = 'r:embed'
                                       value = lv_value ).
        lo_element->append_child( new_child = lo_element2 ).

        lo_element2  = io_document->create_simple_element( name = lc_xml_node_astretch
                                                          parent = io_document ).
        lo_element->append_child( new_child = lo_element2 ).

        lo_element_pic->append_child( new_child = lo_element ).

*     spPr
        lo_element  = io_document->create_simple_element( name = lc_xml_node_sppr
                                                          parent = io_document ).

        lo_element2 = io_document->create_simple_element( name = lc_xml_node_apgeom
                                                          parent = io_document ).
        lo_element2->set_attribute_ns( name  = 'prst'
                                       value = 'rect' ).
        lo_element3 = io_document->create_simple_element( name = lc_xml_node_aavlst
                                                          parent = io_document ).
        lo_element2->append_child( new_child = lo_element3 ).
        lo_element->append_child( new_child = lo_element2 ).

        lo_element_pic->append_child( new_child = lo_element ).
        ep_anchor->append_child( new_child = lo_element_pic ).
      WHEN Lcl_excel_drawing=>type_chart.
*     graphicFrame **********************************
        lo_element_graphicframe = io_document->create_simple_element( name   = lc_xml_node_graphicframe
                                                             parent = io_document ).
*     nvGraphicFramePr
        lo_element  = io_document->create_simple_element( name = lc_xml_node_nvgraphicframepr
                                                          parent = io_document ).
*     cNvPr
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_cnvpr
                                                          parent = io_document ).
        lv_value = sy-index.
        CONDENSE lv_value.
        lo_element2->set_attribute_ns( name  = 'id'
                                       value = lv_value ).
        lo_element2->set_attribute_ns( name  = 'name'
                                       value = io_drawing->title ).
        lo_element->append_child( new_child = lo_element2 ).
*     cNvGraphicFramePr
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_cnvgraphicframepr
                                                          parent = io_document ).
        lo_element3 = io_document->create_simple_element( name = lc_xml_node_graphicframelocks
                                                          parent = io_document ).
        lo_element2->append_child( new_child = lo_element3 ).
        lo_element->append_child( new_child = lo_element2 ).
        lo_element_graphicframe->append_child( new_child = lo_element ).

*     xfrm
        lo_element  = io_document->create_simple_element( name = lc_xml_node_xfrm
                                                          parent = io_document ).
*     off
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_aoff
                                                          parent = io_document ).
        lo_element2->set_attribute_ns( name  = 'y' value = '0' ).
        lo_element2->set_attribute_ns( name  = 'x' value = '0' ).
        lo_element->append_child( new_child = lo_element2 ).
*     ext
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_aext
                                                          parent = io_document ).
        lo_element2->set_attribute_ns( name  = 'cy' value = '0' ).
        lo_element2->set_attribute_ns( name  = 'cx' value = '0' ).
        lo_element->append_child( new_child = lo_element2 ).
        lo_element_graphicframe->append_child( new_child = lo_element ).

*     graphic
        lo_element  = io_document->create_simple_element( name = lc_xml_node_agraphic
                                                          parent = io_document ).
*     graphicData
        lo_element2 = io_document->create_simple_element( name = lc_xml_node_agraphicdata
                                                          parent = io_document ).
        lo_element2->set_attribute_ns( name  = 'uri' value = lc_xml_node_ns_c ).

*     chart
        lo_element3 = io_document->create_simple_element( name = lc_xml_node_cchart
                                                          parent = io_document ).

        lo_element3->set_attribute_ns( name  = 'xmlns:r'
                                       value = lc_xml_node_ns_r ).
        lo_element3->set_attribute_ns( name  = 'xmlns:c'
                                       value = lc_xml_node_ns_c ).

        lv_value = ip_index.
        CONDENSE lv_value.
        CONCATENATE 'rId' lv_value INTO lv_value.
        lo_element3->set_attribute_ns( name  = 'r:id'
                                       value = lv_value ).
        lo_element2->append_child( new_child = lo_element3 ).
        lo_element->append_child( new_child = lo_element2 ).
        lo_element_graphicframe->append_child( new_child = lo_element ).
        ep_anchor->append_child( new_child = lo_element_graphicframe ).

    ENDCASE.

*   client data ***************************
    lo_element_clientdata = io_document->create_simple_element( name   = lc_xml_node_clientdata
                                                                parent = io_document ).
    ep_anchor->append_child( new_child = lo_element_clientdata ).

  ENDMETHOD.
  METHOD create_xl_drawing_for_comments.
** Constant node name
    CONSTANTS: lc_xml_node_xml             TYPE string VALUE 'xml',
               lc_xml_node_ns_v            TYPE string VALUE 'urn:schemas-microsoft-com:vml',
               lc_xml_node_ns_o            TYPE string VALUE 'urn:schemas-microsoft-com:office:office',
               lc_xml_node_ns_x            TYPE string VALUE 'urn:schemas-microsoft-com:office:excel',
               " shapelayout
               lc_xml_node_shapelayout     TYPE string VALUE 'o:shapelayout',
               lc_xml_node_idmap           TYPE string VALUE 'o:idmap',
               " shapetype
               lc_xml_node_shapetype       TYPE string VALUE 'v:shapetype',
               lc_xml_node_stroke          TYPE string VALUE 'v:stroke',
               lc_xml_node_path            TYPE string VALUE 'v:path',
               " shape
               lc_xml_node_shape           TYPE string VALUE 'v:shape',
               lc_xml_node_fill            TYPE string VALUE 'v:fill',
               lc_xml_node_shadow          TYPE string VALUE 'v:shadow',
               lc_xml_node_textbox         TYPE string VALUE 'v:textbox',
               lc_xml_node_div             TYPE string VALUE 'div',
               lc_xml_node_clientdata      TYPE string VALUE 'x:ClientData',
               lc_xml_node_movewithcells   TYPE string VALUE 'x:MoveWithCells',
               lc_xml_node_sizewithcells   TYPE string VALUE 'x:SizeWithCells',
               lc_xml_node_anchor          TYPE string VALUE 'x:Anchor',
               lc_xml_node_autofill        TYPE string VALUE 'x:AutoFill',
               lc_xml_node_row             TYPE string VALUE 'x:Row',
               lc_xml_node_column          TYPE string VALUE 'x:Column',
               " attributes,
               lc_xml_attr_vext            TYPE string VALUE 'v:ext',
               lc_xml_attr_data            TYPE string VALUE 'data',
               lc_xml_attr_id              TYPE string VALUE 'id',
               lc_xml_attr_coordsize       TYPE string VALUE 'coordsize',
               lc_xml_attr_ospt            TYPE string VALUE 'o:spt',
               lc_xml_attr_joinstyle       TYPE string VALUE 'joinstyle',
               lc_xml_attr_path            TYPE string VALUE 'path',
               lc_xml_attr_gradientshapeok TYPE string VALUE 'gradientshapeok',
               lc_xml_attr_oconnecttype    TYPE string VALUE 'o:connecttype',
               lc_xml_attr_type            TYPE string VALUE 'type',
               lc_xml_attr_style           TYPE string VALUE 'style',
               lc_xml_attr_fillcolor       TYPE string VALUE 'fillcolor',
               lc_xml_attr_oinsetmode      TYPE string VALUE 'o:insetmode',
               lc_xml_attr_color           TYPE string VALUE 'color',
               lc_xml_attr_color2          TYPE string VALUE 'color2',
               lc_xml_attr_on              TYPE string VALUE 'on',
               lc_xml_attr_obscured        TYPE string VALUE 'obscured',
               lc_xml_attr_objecttype      TYPE string VALUE 'ObjectType',
               " attributes values
               lc_xml_attr_val_edit        TYPE string VALUE 'edit',
               lc_xml_attr_val_rect        TYPE string VALUE 'rect',
               lc_xml_attr_val_t           TYPE string VALUE 't',
               lc_xml_attr_val_miter       TYPE string VALUE 'miter',
               lc_xml_attr_val_auto        TYPE string VALUE 'auto',
               lc_xml_attr_val_black       TYPE string VALUE 'black',
               lc_xml_attr_val_none        TYPE string VALUE 'none',
               lc_xml_attr_val_msodir      TYPE string VALUE 'mso-direction-alt:auto',
               lc_xml_attr_val_note        TYPE string VALUE 'Note'.


    DATA: lo_document              TYPE REF TO if_ixml_document,
          lo_element_root          TYPE REF TO if_ixml_element,
          "shapelayout
          lo_element_shapelayout   TYPE REF TO if_ixml_element,
          lo_element_idmap         TYPE REF TO if_ixml_element,
          "shapetype
          lo_element_shapetype     TYPE REF TO if_ixml_element,
          lo_element_stroke        TYPE REF TO if_ixml_element,
          lo_element_path          TYPE REF TO if_ixml_element,
          "shape
          lo_element_shape         TYPE REF TO if_ixml_element,
          lo_element_fill          TYPE REF TO if_ixml_element,
          lo_element_shadow        TYPE REF TO if_ixml_element,
          lo_element_textbox       TYPE REF TO if_ixml_element,
          lo_element_div           TYPE REF TO if_ixml_element,
          lo_element_clientdata    TYPE REF TO if_ixml_element,
          lo_element_movewithcells TYPE REF TO if_ixml_element,
          lo_element_sizewithcells TYPE REF TO if_ixml_element,
          lo_element_anchor        TYPE REF TO if_ixml_element,
          lo_element_autofill      TYPE REF TO if_ixml_element,
          lo_element_row           TYPE REF TO if_ixml_element,
          lo_element_column        TYPE REF TO if_ixml_element,
          lo_iterator              TYPE REF TO Lcl_excel_collection_iterator,
          lo_comments              TYPE REF TO Lcl_excel_comments,
          lo_comment               TYPE REF TO Lcl_excel_comment,
          lv_row                   TYPE zexcel_cell_row,
          lv_str_column            TYPE zexcel_cell_column_alpha,
          lv_column                TYPE zexcel_cell_column,
          lv_index                 TYPE i,
          lv_attr_id_index         TYPE i,
          lv_attr_id               TYPE string,
          lv_int_value             TYPE i,
          lv_int_value_string      TYPE string.
    DATA: lv_rel_id            TYPE i.


**********************************************************************
* STEP 1: Create XML document
    lo_document = me->ixml->create_document( ).

***********************************************************************
* STEP 2: Create main node relationships
    lo_element_root = lo_document->create_simple_element( name   = lc_xml_node_xml
                                                          parent = lo_document ).
    lo_element_root->set_attribute_ns( : name  = 'xmlns:v'  value = lc_xml_node_ns_v ),
                                         name  = 'xmlns:o'  value = lc_xml_node_ns_o ),
                                         name  = 'xmlns:x'  value = lc_xml_node_ns_x ).

**********************************************************************
* STEP 3: Create o:shapeLayout
* TO-DO: management of several authors
    lo_element_shapelayout = lo_document->create_simple_element( name   = lc_xml_node_shapelayout
                                                                 parent = lo_document ).

    lo_element_shapelayout->set_attribute_ns( name  = lc_xml_attr_vext
                                              value = lc_xml_attr_val_edit ).

    lo_element_idmap = lo_document->create_simple_element( name   = lc_xml_node_idmap
                                                           parent = lo_document ).
    lo_element_idmap->set_attribute_ns( : name  = lc_xml_attr_vext  value = lc_xml_attr_val_edit ),
                                          name  = lc_xml_attr_data  value = '1' ).

    lo_element_shapelayout->append_child( new_child = lo_element_idmap ).

    lo_element_root->append_child( new_child = lo_element_shapelayout ).

**********************************************************************
* STEP 4: Create v:shapetype

    lo_element_shapetype = lo_document->create_simple_element( name   = lc_xml_node_shapetype
                                                               parent = lo_document ).

    lo_element_shapetype->set_attribute_ns( : name  = lc_xml_attr_id         value = '_x0000_t202' ),
                                              name  = lc_xml_attr_coordsize  value = '21600,21600' ),
                                              name  = lc_xml_attr_ospt       value = '202' ),
                                              name  = lc_xml_attr_path       value = 'm,l,21600r21600,l21600,xe' ).

    lo_element_stroke = lo_document->create_simple_element( name   = lc_xml_node_stroke
                                                            parent = lo_document ).
    lo_element_stroke->set_attribute_ns( name  = lc_xml_attr_joinstyle       value = lc_xml_attr_val_miter ).

    lo_element_path   = lo_document->create_simple_element( name   = lc_xml_node_path
                                                            parent = lo_document ).
    lo_element_path->set_attribute_ns( : name  = lc_xml_attr_gradientshapeok value = lc_xml_attr_val_t ),
                                         name  = lc_xml_attr_oconnecttype    value = lc_xml_attr_val_rect ).

    lo_element_shapetype->append_child( : new_child = lo_element_stroke ),
                                          new_child = lo_element_path ).

    lo_element_root->append_child( new_child = lo_element_shapetype ).

**********************************************************************
* STEP 4: Create v:shapetype

    lo_comments = io_worksheet->get_comments( ).

    lo_iterator = lo_comments->get_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lv_index = sy-index.
      lo_comment ?= lo_iterator->get_next( ).

      Lcl_excel_common=>convert_columnrow2column_a_row( EXPORTING i_columnrow = lo_comment->get_ref( )
                                                        IMPORTING e_column = lv_str_column
                                                                  e_row    = lv_row ).
      lv_column = Lcl_excel_common=>convert_column2int( lv_str_column ).

      lo_element_shape = lo_document->create_simple_element( name   = lc_xml_node_shape
                                                             parent = lo_document ).

      lv_attr_id_index = 1024 + lv_index.
      lv_attr_id = lv_attr_id_index.
      CONCATENATE '_x0000_s' lv_attr_id INTO lv_attr_id.
      lo_element_shape->set_attribute_ns( : name  = lc_xml_attr_id          value = lv_attr_id ),
                                            name  = lc_xml_attr_type        value = '#_x0000_t202' ),
                                            name  = lc_xml_attr_style       value = 'size:auto;width:auto;height:auto;position:absolute;margin-left:117pt;margin-top:172.5pt;z-index:1;visibility:hidden' ),
                                            name  = lc_xml_attr_fillcolor   value = '#ffffe1' ),
                                            name  = lc_xml_attr_oinsetmode  value = lc_xml_attr_val_auto ).

      " Fill
      lo_element_fill = lo_document->create_simple_element( name   = lc_xml_node_fill
                                                            parent = lo_document ).
      lo_element_fill->set_attribute_ns( name = lc_xml_attr_color2  value = '#ffffe1' ).
      lo_element_shape->append_child( new_child = lo_element_fill ).
      " Shadow
      lo_element_shadow = lo_document->create_simple_element( name   = lc_xml_node_shadow
                                                              parent = lo_document ).
      lo_element_shadow->set_attribute_ns( : name = lc_xml_attr_on        value = lc_xml_attr_val_t ),
                                             name = lc_xml_attr_color     value = lc_xml_attr_val_black ),
                                             name = lc_xml_attr_obscured  value = lc_xml_attr_val_t ).
      lo_element_shape->append_child( new_child = lo_element_shadow ).
      " Path
      lo_element_path = lo_document->create_simple_element( name   = lc_xml_node_path
                                                            parent = lo_document ).
      lo_element_path->set_attribute_ns( name = lc_xml_attr_oconnecttype  value = lc_xml_attr_val_none ).
      lo_element_shape->append_child( new_child = lo_element_path ).
      " Textbox
      lo_element_textbox = lo_document->create_simple_element( name   = lc_xml_node_textbox
                                                               parent = lo_document ).
      lo_element_textbox->set_attribute_ns( name = lc_xml_attr_style  value = lc_xml_attr_val_msodir ).
      lo_element_div = lo_document->create_simple_element( name   = lc_xml_node_div
                                                           parent = lo_document ).
      lo_element_div->set_attribute_ns( name = lc_xml_attr_style  value = 'text-align:left' ).
      lo_element_textbox->append_child( new_child = lo_element_div ).
      lo_element_shape->append_child( new_child = lo_element_textbox ).
      " ClientData
      lo_element_clientdata = lo_document->create_simple_element( name   = lc_xml_node_clientdata
                                                                  parent = lo_document ).
      lo_element_clientdata->set_attribute_ns( name = lc_xml_attr_objecttype  value = lc_xml_attr_val_note ).
      lo_element_movewithcells = lo_document->create_simple_element( name   = lc_xml_node_movewithcells
                                                                     parent = lo_document ).
      lo_element_clientdata->append_child( new_child = lo_element_movewithcells ).
      lo_element_sizewithcells = lo_document->create_simple_element( name   = lc_xml_node_sizewithcells
                                                                     parent = lo_document ).
      lo_element_clientdata->append_child( new_child = lo_element_sizewithcells ).
      lo_element_anchor = lo_document->create_simple_element( name   = lc_xml_node_anchor
                                                              parent = lo_document ).
      lo_element_anchor->set_value( '2, 15, 11, 10, 4, 31, 15, 9' ).
      lo_element_clientdata->append_child( new_child = lo_element_anchor ).
      lo_element_autofill = lo_document->create_simple_element( name   = lc_xml_node_autofill
                                                                parent = lo_document ).
      lo_element_autofill->set_value( 'False' ).
      lo_element_clientdata->append_child( new_child = lo_element_autofill ).
      lo_element_row = lo_document->create_simple_element( name   = lc_xml_node_row
                                                           parent = lo_document ).
      lv_int_value = lv_row - 1.
      lv_int_value_string = lv_int_value.
      lo_element_row->set_value( lv_int_value_string ).
      lo_element_clientdata->append_child( new_child = lo_element_row ).
      lo_element_column = lo_document->create_simple_element( name   = lc_xml_node_column
                                                                parent = lo_document ).
      lv_int_value = lv_column - 1.
      lv_int_value_string = lv_int_value.
      lo_element_column->set_value( lv_int_value_string ).
      lo_element_clientdata->append_child( new_child = lo_element_column ).

      lo_element_shape->append_child( new_child = lo_element_clientdata ).

      lo_element_root->append_child( new_child = lo_element_shape ).
    ENDWHILE.

**********************************************************************
* STEP 6: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_drawing_for_hdft_im.


    DATA:
      ld_1            TYPE string,
      ld_2            TYPE string,
      ld_3            TYPE string,
      ld_4            TYPE string,
      ld_5            TYPE string,
      ld_7            TYPE string,

      ls_odd_header   TYPE zexcel_s_worksheet_head_foot,
      ls_odd_footer   TYPE zexcel_s_worksheet_head_foot,
      ls_even_header  TYPE zexcel_s_worksheet_head_foot,
      ls_even_footer  TYPE zexcel_s_worksheet_head_foot,
      lv_content      TYPE string,
      lo_xml_document TYPE REF TO cl_xml_document.


* INIT_RESULT
    CLEAR ep_content.


* BODY
    ld_1 = '<xml xmlns:v="urn:schemas-microsoft-com:vml"  xmlns:o="urn:schemas-microsoft-com:office:office"  xmlns:x="urn:schemas-microsoft-com:office:excel"><o:shapelayout v:ext="edit"><o:idmap v:ext="edit" data="1"/></o:shapelayout>'.
    ld_2 = '<v:shapetype id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"/><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"/>'.
    ld_3 = '<v:f eqn="sum @0 1 0"/><v:f eqn="sum 0 0 @1"/><v:f eqn="prod @2 1 2"/><v:f eqn="prod @3 21600 pixelWidth"/><v:f eqn="prod @3 21600 pixelHeight"/><v:f eqn="sum @0 0 1"/><v:f eqn="prod @6 1 2"/><v:f eqn="prod @7 21600 pixelWidth"/>'.
    ld_4 = '<v:f eqn="sum @8 21600 0"/><v:f eqn="prod @7 21600 pixelHeight"/><v:f eqn="sum @10 21600 0"/></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/><o:lock v:ext="edit" aspectratio="t"/></v:shapetype>'.


    CONCATENATE ld_1
                ld_2
                ld_3
                ld_4
         INTO lv_content.

    io_worksheet->sheet_setup->get_header_footer( IMPORTING ep_odd_header = ls_odd_header
                                                            ep_odd_footer = ls_odd_footer
                                                            ep_even_header = ls_even_header
                                                            ep_even_footer = ls_even_footer ).

    ld_5 = me->set_vml_shape_header( ls_odd_header ).
    CONCATENATE lv_content
                ld_5
           INTO lv_content.
    ld_5 = me->set_vml_shape_header( ls_even_header ).
    CONCATENATE lv_content
                ld_5
           INTO lv_content.
    ld_5 = me->set_vml_shape_footer( ls_odd_footer ).
    CONCATENATE lv_content
                ld_5
           INTO lv_content.
    ld_5 = me->set_vml_shape_footer( ls_even_footer ).
    CONCATENATE lv_content
                ld_5
           INTO lv_content.

    ld_7 = '</xml>'.

    CONCATENATE lv_content
                ld_7
           INTO lv_content.

    CREATE OBJECT lo_xml_document.
    CALL METHOD lo_xml_document->parse_string
      EXPORTING
        stream = lv_content.

    CALL FUNCTION 'SCMS_STRING_TO_XSTRING'
      EXPORTING
        text   = lv_content
      IMPORTING
        buffer = ep_content
      EXCEPTIONS
        failed = 1
        OTHERS = 2.
    IF sy-subrc <> 0.
      CLEAR ep_content.
    ENDIF.

  ENDMETHOD.
  METHOD create_xl_relationships.


** Constant node name
    DATA: lc_xml_node_relationships TYPE string VALUE 'Relationships',
          lc_xml_node_relationship  TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id            TYPE string VALUE 'Id',
          lc_xml_attr_type          TYPE string VALUE 'Type',
          lc_xml_attr_target        TYPE string VALUE 'Target',
          " Node namespace
          lc_xml_node_rels_ns       TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships',
          " Node id
          lc_xml_node_ridx_id       TYPE string VALUE 'rId#',
          " Node type
          lc_xml_node_rid_sheet_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
          lc_xml_node_rid_theme_tp  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
          lc_xml_node_rid_styles_tp TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
          lc_xml_node_rid_shared_tp TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
          " Node target
          lc_xml_node_ridx_tg       TYPE string VALUE 'worksheets/sheet#.xml',
          lc_xml_node_rid_shared_tg TYPE string VALUE 'sharedStrings.xml',
          lc_xml_node_rid_styles_tg TYPE string VALUE 'styles.xml',
          lc_xml_node_rid_theme_tg  TYPE string VALUE 'theme/theme1.xml'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element.

    DATA: lv_xml_node_ridx_tg TYPE string,
          lv_xml_node_ridx_id TYPE string,
          lv_size             TYPE i,
          lv_syindex          TYPE string.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_relationships
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_rels_ns ).

**********************************************************************
* STEP 4: Create subnodes

    lv_size = excel->get_worksheets_size( ).


    " Relationship node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
    parent = lo_document ).
    lv_size = lv_size + 1.
    lv_syindex = lv_size.
    SHIFT lv_syindex RIGHT DELETING TRAILING space.
    SHIFT lv_syindex LEFT DELETING LEADING space.
    lv_xml_node_ridx_id = lc_xml_node_ridx_id.
    REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_ridx_id WITH lv_syindex.
    lo_element->set_attribute_ns( name  = lc_xml_attr_id
    value = lv_xml_node_ridx_id ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_type
    value = lc_xml_node_rid_theme_tp ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_target
    value = lc_xml_node_rid_theme_tg ).
    lo_element_root->append_child( new_child = lo_element ).


    " Relationship node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                     parent = lo_document ).
    lv_size = lv_size + 1.
    lv_syindex = lv_size.
    SHIFT lv_syindex RIGHT DELETING TRAILING space.
    SHIFT lv_syindex LEFT DELETING LEADING space.
    lv_xml_node_ridx_id = lc_xml_node_ridx_id.
    REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_ridx_id WITH lv_syindex.
    lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                  value = lv_xml_node_ridx_id ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                  value = lc_xml_node_rid_styles_tp ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                  value = lc_xml_node_rid_styles_tg ).
    lo_element_root->append_child( new_child = lo_element ).



    lv_size = excel->get_worksheets_size( ).

    DO lv_size TIMES.
      " Relationship node
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
      parent = lo_document ).
      lv_xml_node_ridx_id = lc_xml_node_ridx_id.
      lv_xml_node_ridx_tg = lc_xml_node_ridx_tg.
      lv_syindex = sy-index.
      SHIFT lv_syindex RIGHT DELETING TRAILING space.
      SHIFT lv_syindex LEFT DELETING LEADING space.
      REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_ridx_id WITH lv_syindex.
      REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_ridx_tg WITH lv_syindex.
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
      value = lv_xml_node_ridx_id ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_type
      value = lc_xml_node_rid_sheet_tp ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
      value = lv_xml_node_ridx_tg ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDDO.

    " Relationship node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                     parent = lo_document ).
    ADD 3 TO lv_size.
    lv_syindex = lv_size.
    SHIFT lv_syindex RIGHT DELETING TRAILING space.
    SHIFT lv_syindex LEFT DELETING LEADING space.
    lv_xml_node_ridx_id = lc_xml_node_ridx_id.
    REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_ridx_id WITH lv_syindex.
    lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                  value = lv_xml_node_ridx_id ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                  value = lc_xml_node_rid_shared_tp ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                  value = lc_xml_node_rid_shared_tg ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_sharedstrings.


** Constant node name
    DATA: lc_xml_node_sst         TYPE string VALUE 'sst',
          lc_xml_node_si          TYPE string VALUE 'si',
          lc_xml_node_t           TYPE string VALUE 't',
          lc_xml_node_r           TYPE string VALUE 'r',
          lc_xml_node_rpr         TYPE string VALUE 'rPr',
          " Node attributes
          lc_xml_attr_count       TYPE string VALUE 'count',
          lc_xml_attr_uniquecount TYPE string VALUE 'uniqueCount',
          " Node namespace
          lc_xml_node_ns          TYPE string VALUE 'http://schemas.openxmlformats.org/spreadsheetml/2006/main'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element,
          lo_sub_element  TYPE REF TO if_ixml_element,
          lo_sub2_element TYPE REF TO if_ixml_element,
          lo_font_element TYPE REF TO if_ixml_element,
          lo_iterator     TYPE REF TO Lcl_excel_collection_iterator,
          lo_worksheet    TYPE REF TO Lcl_excel_worksheet.

    DATA: lt_cell_data       TYPE zexcel_t_cell_data_unsorted,
          lt_cell_data_rtf   TYPE zexcel_t_cell_data_unsorted,
          lv_value           TYPE string,
          ls_shared_string   TYPE zexcel_s_shared_string,
          lv_count_str       TYPE string,
          lv_uniquecount_str TYPE string,
          lv_sytabix         TYPE i,
          lv_count           TYPE i,
          lv_uniquecount     TYPE i.

    FIELD-SYMBOLS: <fs_sheet_content> TYPE zexcel_s_cell_data,
                   <fs_rtf>           TYPE zexcel_s_rtf,
                   <fs_sheet_string>  TYPE zexcel_s_shared_string.

**********************************************************************
* STEP 1: Collect strings from each worksheet
    lo_iterator = excel->get_worksheets_iterator( ).

    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).
      APPEND LINES OF lo_worksheet->sheet_content TO lt_cell_data.
    ENDWHILE.

    DELETE lt_cell_data WHERE cell_formula IS NOT INITIAL. " delete formula content

    DESCRIBE TABLE lt_cell_data LINES lv_count.
    lv_count_str = lv_count.

    " separating plain and rich text format strings
    lt_cell_data_rtf = lt_cell_data.
    DELETE lt_cell_data WHERE rtf_tab IS NOT INITIAL.
    DELETE lt_cell_data_rtf WHERE rtf_tab IS INITIAL.

    SHIFT lv_count_str RIGHT DELETING TRAILING space.
    SHIFT lv_count_str LEFT DELETING LEADING space.

    SORT lt_cell_data BY cell_value data_type.
    DELETE ADJACENT DUPLICATES FROM lt_cell_data COMPARING cell_value data_type.

    " leave unique rich text format strings
    SORT lt_cell_data_rtf BY cell_value rtf_tab.
    DELETE ADJACENT DUPLICATES FROM lt_cell_data_rtf COMPARING cell_value rtf_tab.
    " merge into single list
    APPEND LINES OF lt_cell_data_rtf TO lt_cell_data.
    SORT lt_cell_data BY cell_value rtf_tab.
    FREE lt_cell_data_rtf.

    DESCRIBE TABLE lt_cell_data LINES lv_uniquecount.
    lv_uniquecount_str = lv_uniquecount.

    SHIFT lv_uniquecount_str RIGHT DELETING TRAILING space.
    SHIFT lv_uniquecount_str LEFT DELETING LEADING space.

    CLEAR lv_count.
    LOOP AT lt_cell_data ASSIGNING <fs_sheet_content> WHERE data_type = 's'.
      lv_sytabix = lv_count.
      ls_shared_string-string_no = lv_sytabix.
      ls_shared_string-string_value = <fs_sheet_content>-cell_value.
      ls_shared_string-string_type = <fs_sheet_content>-data_type.
      ls_shared_string-rtf_tab = <fs_sheet_content>-rtf_tab.
      INSERT ls_shared_string INTO TABLE shared_strings.
      ADD 1 TO lv_count.
    ENDLOOP.


**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_sst
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_ns ).
    lo_element_root->set_attribute_ns( name  = lc_xml_attr_count
                                       value = lv_count_str ).
    lo_element_root->set_attribute_ns( name  = lc_xml_attr_uniquecount
                                       value = lv_uniquecount_str ).

**********************************************************************
* STEP 4: Create subnode
    LOOP AT shared_strings ASSIGNING <fs_sheet_string>.
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_si
                                                       parent = lo_document ).
      IF <fs_sheet_string>-rtf_tab IS INITIAL.
        lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_t
                                                             parent = lo_document ).
        IF boolc( contains( val = <fs_sheet_string>-string_value start = ` ` ) ) = abap_true
              OR boolc( contains( val = <fs_sheet_string>-string_value end = ` ` ) ) = abap_true.
          lo_sub_element->set_attribute( name = 'space' namespace = 'xml' value = 'preserve' ).
        ENDIF.
        lv_value = escape_string_value( <fs_sheet_string>-string_value ).
        lo_sub_element->set_value( value = lv_value ).
      ELSE.
        LOOP AT <fs_sheet_string>-rtf_tab ASSIGNING <fs_rtf>.
          lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_r
                                                               parent = lo_element ).
          TRY.
              lv_value = substring( val = <fs_sheet_string>-string_value
                                    off = <fs_rtf>-offset
                                    len = <fs_rtf>-length ).
            CATCH cx_sy_range_out_of_bounds.
              EXIT.
          ENDTRY.
          lv_value = escape_string_value( lv_value ).
          IF <fs_rtf>-font IS NOT INITIAL.
            lo_font_element = lo_document->create_simple_element( name   = lc_xml_node_rpr
                                                                  parent = lo_sub_element ).
            create_xl_styles_font_node( io_document = lo_document
                                        io_parent   = lo_font_element
                                        is_font     = <fs_rtf>-font
                                        iv_use_rtf  = abap_true ).
          ENDIF.
          lo_sub2_element = lo_document->create_simple_element( name   = lc_xml_node_t
                                                              parent = lo_sub_element ).
          IF boolc( contains( val = lv_value start = ` ` ) ) = abap_true
                OR boolc( contains( val = lv_value end = ` ` ) ) = abap_true.
            lo_sub2_element->set_attribute( name = 'space' namespace = 'xml' value = 'preserve' ).
          ENDIF.
          lo_sub2_element->set_value( lv_value ).
        ENDLOOP.
      ENDIF.
      lo_element->append_child( new_child = lo_sub_element ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDLOOP.

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_sheet.

** Constant node name
    DATA: lc_xml_node_worksheet          TYPE string VALUE 'worksheet',
          " Node namespace
          lc_xml_node_ns                 TYPE string VALUE 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
          lc_xml_node_r_ns               TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
          lc_xml_node_comp_ns            TYPE string VALUE 'http://schemas.openxmlformats.org/markup-compatibility/2006',
          lc_xml_node_comp_pref          TYPE string VALUE 'x14ac',
          lc_xml_node_ig_ns              TYPE string VALUE 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac'.

    DATA: lo_document        TYPE REF TO if_ixml_document,
          lo_element_root    TYPE REF TO if_ixml_element,
          lo_create_xl_sheet TYPE REF TO SHRITEFUH64VYIPN5I4UIDBJAALSE4.



**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

***********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_worksheet
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:r'
                                       value = lc_xml_node_r_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:mc'
                                       value = lc_xml_node_comp_ns ).
    lo_element_root->set_attribute_ns( name  = 'mc:Ignorable'
                                       value = lc_xml_node_comp_pref ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:x14ac'
                                       value = lc_xml_node_ig_ns ).


**********************************************************************
* STEP 4: Create subnodes

    CREATE OBJECT lo_create_xl_sheet.
    lo_create_xl_sheet->create( io_worksheet         = io_worksheet
                                io_document          = lo_document
                                iv_active            = iv_active
                                io_excel_writer_2007 = me ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_sheet_column_formula.

    TYPES: ls_column_formula_used     TYPE mty_column_formula_used,
           lv_column_alpha            TYPE zexcel_cell_column_alpha,
           lv_top_cell_coords         TYPE zexcel_cell_coords,
           lv_bottom_cell_coords      TYPE zexcel_cell_coords,
           lv_cell_coords             TYPE zexcel_cell_coords,
           lv_ref_value               TYPE string,
           lv_test_shared             TYPE string,
           lv_si                      TYPE i,
           lv_1st_line_shared_formula TYPE abap_bool.
    DATA: lv_value                   TYPE string,
          ls_column_formula_used     TYPE mty_column_formula_used,
          lv_column_alpha            TYPE zexcel_cell_column_alpha,
          lv_top_cell_coords         TYPE zexcel_cell_coords,
          lv_bottom_cell_coords      TYPE zexcel_cell_coords,
          lv_cell_coords             TYPE zexcel_cell_coords,
          lv_ref_value               TYPE string,
          lv_1st_line_shared_formula TYPE abap_bool.
    FIELD-SYMBOLS: <ls_column_formula>      TYPE Lcl_excel_worksheet=>mty_s_column_formula,
                   <ls_column_formula_used> TYPE mty_column_formula_used.


    READ TABLE it_column_formulas WITH TABLE KEY id = is_sheet_content-column_formula_id ASSIGNING <ls_column_formula>.
    ASSERT sy-subrc = 0.

    lv_value = <ls_column_formula>-formula.
    lv_1st_line_shared_formula = abap_false.
    eo_element = io_document->create_simple_element( name   = 'f'
                                                     parent = io_document ).
    READ TABLE ct_column_formulas_used WITH TABLE KEY id = is_sheet_content-column_formula_id ASSIGNING <ls_column_formula_used>.
    IF sy-subrc <> 0.
      CLEAR ls_column_formula_used.
      ls_column_formula_used-id = is_sheet_content-column_formula_id.
      IF is_formula_shareable( ip_formula = lv_value ) = abap_true.
        ls_column_formula_used-t = 'shared'.
        ls_column_formula_used-si = cv_si.
        CONDENSE ls_column_formula_used-si.
        cv_si = cv_si + 1.
        lv_1st_line_shared_formula = abap_true.
      ENDIF.
      INSERT ls_column_formula_used INTO TABLE ct_column_formulas_used ASSIGNING <ls_column_formula_used>.
    ENDIF.

    IF lv_1st_line_shared_formula = abap_true OR <ls_column_formula_used>-t <> 'shared'.
      lv_column_alpha = Lcl_excel_common=>convert_column2alpha( ip_column = is_sheet_content-cell_column ).
      lv_top_cell_coords = |{ lv_column_alpha }{ <ls_column_formula>-table_top_left_row + 1 }|.
      lv_bottom_cell_coords = |{ lv_column_alpha }{ <ls_column_formula>-table_bottom_right_row + 1 }|.
      lv_cell_coords = |{ lv_column_alpha }{ is_sheet_content-cell_row }|.
      IF lv_top_cell_coords = lv_cell_coords.
        lv_ref_value = |{ lv_top_cell_coords }:{ lv_bottom_cell_coords }|.
      ELSE.
        lv_ref_value = |{ lv_cell_coords }:{ lv_bottom_cell_coords }|.
        lv_value = Lcl_excel_common=>shift_formula(
            iv_reference_formula = lv_value
            iv_shift_cols        = 0
            iv_shift_rows        = is_sheet_content-cell_row - <ls_column_formula>-table_top_left_row - 1 ).
      ENDIF.
    ENDIF.

    IF <ls_column_formula_used>-t = 'shared'.
      eo_element->set_attribute( name  = 't'
                                 value = <ls_column_formula_used>-t ).
      eo_element->set_attribute( name  = 'si'
                                 value = <ls_column_formula_used>-si ).
      IF lv_1st_line_shared_formula = abap_true.
        eo_element->set_attribute( name  = 'ref'
                                   value = lv_ref_value ).
        eo_element->set_value( value = lv_value ).
      ENDIF.
    ELSE.
      eo_element->set_value( value = lv_value ).
    ENDIF.

  ENDMETHOD.
  METHOD create_xl_sheet_ignored_errors.
    DATA: lo_element        TYPE REF TO if_ixml_element,
          lo_element2       TYPE REF TO if_ixml_element,
          lt_ignored_errors TYPE Lcl_excel_worksheet=>mty_th_ignored_errors.
    FIELD-SYMBOLS: <ls_ignored_errors> TYPE Lcl_excel_worksheet=>mty_s_ignored_errors.

    lt_ignored_errors = io_worksheet->get_ignored_errors( ).

    IF lt_ignored_errors IS NOT INITIAL.
      lo_element = io_document->create_simple_element( name   = 'ignoredErrors'
                                                       parent = io_document ).


      LOOP AT lt_ignored_errors ASSIGNING <ls_ignored_errors>.

        lo_element2 = io_document->create_simple_element( name   = 'ignoredError'
                                                          parent = io_document ).

        lo_element2->set_attribute_ns( name  = 'sqref'
                                       value = <ls_ignored_errors>-cell_coords ).

        IF <ls_ignored_errors>-eval_error = abap_true.
          lo_element2->set_attribute_ns( name  = 'evalError'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-two_digit_text_year = abap_true.
          lo_element2->set_attribute_ns( name  = 'twoDigitTextYear'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-number_stored_as_text = abap_true.
          lo_element2->set_attribute_ns( name  = 'numberStoredAsText'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-formula = abap_true.
          lo_element2->set_attribute_ns( name  = 'formula'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-formula_range = abap_true.
          lo_element2->set_attribute_ns( name  = 'formulaRange'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-unlocked_formula = abap_true.
          lo_element2->set_attribute_ns( name  = 'unlockedFormula'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-empty_cell_reference = abap_true.
          lo_element2->set_attribute_ns( name  = 'emptyCellReference'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-list_data_validation = abap_true.
          lo_element2->set_attribute_ns( name  = 'listDataValidation'
                                         value = '1' ).
        ENDIF.
        IF <ls_ignored_errors>-calculated_column = abap_true.
          lo_element2->set_attribute_ns( name  = 'calculatedColumn'
                                         value = '1' ).
        ENDIF.

        lo_element->append_child( lo_element2 ).

      ENDLOOP.

      io_element_root->append_child( lo_element ).

    ENDIF.

  ENDMETHOD.
  METHOD create_xl_sheet_pagebreaks.
    DATA: lo_pagebreaks     TYPE REF TO Lcl_excel_worksheet_pagebreaks,
          lt_pagebreaks     TYPE Lcl_excel_worksheet_pagebreaks=>tt_pagebreak_at,
          lt_rows           TYPE HASHED TABLE OF int4 WITH UNIQUE KEY table_line,
          lt_columns        TYPE HASHED TABLE OF int4 WITH UNIQUE KEY table_line,

          lo_node_rowbreaks TYPE REF TO if_ixml_element,
          lo_node_colbreaks TYPE REF TO if_ixml_element,
          lo_node_break     TYPE REF TO if_ixml_element,

          lv_value          TYPE string.


    FIELD-SYMBOLS: <ls_pagebreak> LIKE LINE OF lt_pagebreaks.

    lo_pagebreaks = io_worksheet->get_pagebreaks( ).
    CHECK lo_pagebreaks IS BOUND.

    lt_pagebreaks = lo_pagebreaks->get_all_pagebreaks( ).
    CHECK lt_pagebreaks IS NOT INITIAL.  " No need to proceed if don't have any pagebreaks.

    lo_node_rowbreaks = io_document->create_simple_element( name   = 'rowBreaks'
                                                            parent = io_document ).

    lo_node_colbreaks = io_document->create_simple_element( name   = 'colBreaks'
                                                            parent = io_document ).


    LOOP AT lt_pagebreaks ASSIGNING <ls_pagebreak>.

* Count how many rows and columns need to be broken
      INSERT <ls_pagebreak>-cell_row    INTO TABLE lt_rows.
      IF sy-subrc = 0. " New
        lv_value = <ls_pagebreak>-cell_row.
        CONDENSE lv_value.

        lo_node_break = io_document->create_simple_element( name   = 'brk'
                                                            parent = io_document ).
        lo_node_break->set_attribute( name = 'id'  value = lv_value ).
        lo_node_break->set_attribute( name = 'man' value = '1' ).      " Manual break
        lo_node_break->set_attribute( name = 'max' value = '16383' ).  " Max columns

        lo_node_rowbreaks->append_child( new_child = lo_node_break ).
      ENDIF.

      INSERT <ls_pagebreak>-cell_column INTO TABLE lt_columns.
      IF sy-subrc = 0. " New
        lv_value = <ls_pagebreak>-cell_column.
        CONDENSE lv_value.

        lo_node_break = io_document->create_simple_element( name   = 'brk'
                                                            parent = io_document ).
        lo_node_break->set_attribute( name = 'id'  value = lv_value ).
        lo_node_break->set_attribute( name = 'man' value = '1' ).        " Manual break
        lo_node_break->set_attribute( name = 'max' value = '1048575' ).  " Max rows

        lo_node_colbreaks->append_child( new_child = lo_node_break ).
      ENDIF.


    ENDLOOP.

    lv_value = lines( lt_rows ).
    CONDENSE lv_value.
    lo_node_rowbreaks->set_attribute( name = 'count'             value = lv_value ).
    lo_node_rowbreaks->set_attribute( name = 'manualBreakCount'  value = lv_value ).

    lv_value = lines( lt_rows ).
    CONDENSE lv_value.
    lo_node_colbreaks->set_attribute( name = 'count'             value = lv_value ).
    lo_node_colbreaks->set_attribute( name = 'manualBreakCount'  value = lv_value ).

    io_parent->append_child( new_child = lo_node_rowbreaks ).
    io_parent->append_child( new_child = lo_node_colbreaks ).

  ENDMETHOD.
  METHOD create_xl_sheet_rels.


** Constant node name
    DATA: lc_xml_node_relationships      TYPE string VALUE 'Relationships',
          lc_xml_node_relationship       TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id                 TYPE string VALUE 'Id',
          lc_xml_attr_type               TYPE string VALUE 'Type',
          lc_xml_attr_target             TYPE string VALUE 'Target',
          lc_xml_attr_target_mode        TYPE string VALUE 'TargetMode',
          lc_xml_val_external            TYPE string VALUE 'External',
          " Node namespace
          lc_xml_node_rels_ns            TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships',
          lc_xml_node_rid_table_tp       TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table',
          lc_xml_node_rid_printer_tp     TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/printerSettings',
          lc_xml_node_rid_drawing_tp     TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
          lc_xml_node_rid_comment_tp     TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',        " (+) Issue #180
          lc_xml_node_rid_drawing_cmt_tp TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing',      " (+) Issue #180
          lc_xml_node_rid_link_tp        TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element,
          lo_iterator     TYPE REF TO Lcl_excel_collection_iterator,
          lo_table        TYPE REF TO Lcl_excel_table,
          lo_link         TYPE REF TO Lcl_excel_hyperlink.

    DATA: lv_value         TYPE string,
          lv_relation_id   TYPE i,
          lv_index_str     TYPE string,
          lv_comment_index TYPE i.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_relationships
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_rels_ns ).

**********************************************************************
* STEP 4: Create subnodes

    " Add sheet Relationship nodes here
    lv_relation_id = 0.
    lo_iterator = io_worksheet->get_hyperlinks_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_link ?= lo_iterator->get_next( ).
      CHECK lo_link->is_internal( ) = abap_false.  " issue #340 - don't put internal links here
      ADD 1 TO lv_relation_id.

      lv_value = lv_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.

      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                       parent = lo_document ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                    value = lc_xml_node_rid_link_tp ).

      lv_value = lo_link->get_url( ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_target_mode
                                    value = lc_xml_val_external ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDWHILE.

* drawing
    DATA: lo_drawings TYPE REF TO Lcl_excel_drawings.

    lo_drawings = io_worksheet->get_drawings( ).
    IF lo_drawings->is_empty( ) = abap_false.
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                       parent = lo_document ).
      ADD 1 TO lv_relation_id.

      lv_value = lv_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                    value = lc_xml_node_rid_drawing_tp ).

      lv_index_str = iv_drawing_index.
      CONDENSE lv_index_str NO-GAPS.
      lv_value = me->c_xl_drawings.
      REPLACE 'xl' WITH '..' INTO lv_value.
      REPLACE '#' WITH lv_index_str INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDIF.

* Begin - Add - Issue #180
    DATA: lo_comments  TYPE REF TO Lcl_excel_comments.

    lv_comment_index = iv_comment_index.

    lo_comments = io_worksheet->get_comments( ).
    IF lo_comments->is_empty( ) = abap_false.
      " Drawing for comment
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                       parent = lo_document ).

      ADD 1 TO lv_relation_id.
      ADD 1 TO lv_comment_index.

      lv_value = lv_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                    value = lc_xml_node_rid_drawing_cmt_tp ).

      lv_index_str = iv_comment_index.
      CONDENSE lv_index_str NO-GAPS.
      lv_value = me->cl_xl_drawing_for_comments.
      REPLACE 'xl' WITH '..' INTO lv_value.
      REPLACE '#' WITH lv_index_str INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                    value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).

      " Comment
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                       parent = lo_document ).
      ADD 1 TO lv_relation_id.

      lv_value = lv_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                    value = lc_xml_node_rid_comment_tp ).

      lv_index_str = iv_comment_index.
      CONDENSE lv_index_str NO-GAPS.
      lv_value = me->c_xl_comments.
      REPLACE 'xl' WITH '..' INTO lv_value.
      REPLACE '#' WITH lv_index_str INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDIF.
* End   - Add - Issue #180

**********************************************************************
* header footer image
    DATA: lt_drawings TYPE zexcel_t_drawings.
    lt_drawings = io_worksheet->get_header_footer_drawings( ).
    IF lines( lt_drawings ) > 0. "Header or footer image exist
      ADD 1 TO lv_relation_id.
      " Drawing for comment/header/footer
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                       parent = lo_document ).
      lv_value = lv_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                    value = lc_xml_node_rid_drawing_cmt_tp ).

      lv_index_str = lv_comment_index.
      CONDENSE lv_index_str NO-GAPS.
      lv_value = me->cl_xl_drawing_for_comments.
      REPLACE 'xl' WITH '..' INTO lv_value.
      REPLACE '#' WITH lv_index_str INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                    value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDIF.
*** End Header Footer
**********************************************************************


    lo_iterator = io_worksheet->get_tables_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_table ?= lo_iterator->get_next( ).
      ADD 1 TO lv_relation_id.

      lv_value = lv_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.

      lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                       parent = lo_document ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                    value = lv_value ).
      lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                    value = lc_xml_node_rid_table_tp ).

      lv_value = lo_table->get_name( ).
      CONCATENATE '../tables/' lv_value '.xml' INTO lv_value.
      lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDWHILE.

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_sheet_sheet_data.

    TYPES: BEGIN OF lty_table_area,
             left   TYPE i,
             right  TYPE i,
             top    TYPE i,
             bottom TYPE i,
           END OF lty_table_area.

    CONSTANTS: lc_dummy_cell_content       TYPE zexcel_s_cell_data-cell_value VALUE '})~~~ This is a dummy value for ABAP2XLSX and you should never find this in a real excelsheet Ihope'.

    CONSTANTS: lc_xml_node_sheetdata TYPE string VALUE 'sheetData',   " SheetData tag
               lc_xml_node_row       TYPE string VALUE 'row',         " Row tag
               lc_xml_attr_r         TYPE string VALUE 'r',           " Cell:  row-attribute
               lc_xml_attr_spans     TYPE string VALUE 'spans',       " Cell: spans-attribute
               lc_xml_node_c         TYPE string VALUE 'c',           " Cell tag
               lc_xml_node_v         TYPE string VALUE 'v',           " Cell: value
               lc_xml_node_f         TYPE string VALUE 'f',           " Cell: formula
               lc_xml_attr_s         TYPE string VALUE 's',           " Cell: style
               lc_xml_attr_t         TYPE string VALUE 't'.           " Cell: type

    DATA: col_count              TYPE int4,
          lo_autofilters         TYPE REF TO Lcl_excel_autofilters,
          lo_autofilter          TYPE REF TO Lcl_excel_autofilter,
          l_autofilter_hidden    TYPE flag,
          lt_values              TYPE zexcel_t_autofilter_values,
          ls_values              TYPE zexcel_s_autofilter_values,
          ls_area                TYPE zexcel_s_autofilter_area,

          lo_iterator            TYPE REF TO Lcl_excel_collection_iterator,
          lo_table               TYPE REF TO Lcl_excel_table,
          lt_table_areas         TYPE SORTED TABLE OF lty_table_area WITH NON-UNIQUE KEY left right top bottom,
          ls_table_area          LIKE LINE OF lt_table_areas,
          lo_column              TYPE REF TO Lcl_excel_column,

          ls_sheet_content       LIKE LINE OF io_worksheet->sheet_content,
          ls_sheet_content_empty LIKE LINE OF io_worksheet->sheet_content,
          lv_current_row         TYPE i,
          lv_next_row            TYPE i,
          lv_last_row            TYPE i,

*        lts_row_dimensions     TYPE zexcel_t_worksheet_rowdimensio,
          lo_row_iterator        TYPE REF TO Lcl_excel_collection_iterator,
          lo_row                 TYPE REF TO Lcl_excel_row,
          lo_row_empty           TYPE REF TO Lcl_excel_row,
          lts_row_outlines       TYPE Lcl_excel_worksheet=>mty_ts_outlines_row,

          ls_last_row            TYPE zexcel_s_cell_data,
          ls_style_mapping       TYPE zexcel_s_styles_mapping,

          lo_element_2           TYPE REF TO if_ixml_element,
          lo_element_3           TYPE REF TO if_ixml_element,
          lo_element_4           TYPE REF TO if_ixml_element,

          lv_value               TYPE string,
          lv_style_guid          TYPE zexcel_cell_style.
    DATA: lt_column_formulas_used TYPE mty_column_formulas_used,
          lv_si                   TYPE i.

    FIELD-SYMBOLS: <ls_sheet_content> TYPE zexcel_s_cell_data,
                   <ls_row_outline>   LIKE LINE OF lts_row_outlines.


    " sheetData node
    rv_ixml_sheet_data_root = io_document->create_simple_element( name   = lc_xml_node_sheetdata
                                                                  parent = io_document ).

    " Get column count
    col_count      = io_worksheet->get_highest_column( ).
    " Get autofilter
    lo_autofilters = excel->get_autofilters_reference( ).
    lo_autofilter  = lo_autofilters->get( io_worksheet = io_worksheet ) .
    IF lo_autofilter IS BOUND.
      lt_values           = lo_autofilter->get_values( ) .
      ls_area             = lo_autofilter->get_filter_area( ) .
      l_autofilter_hidden = abap_true. " First defautl is not showing
    ENDIF.
*--------------------------------------------------------------------*
*issue #220 - If cell in tables-area don't use default from row or column or sheet - Coding 1 - start
*--------------------------------------------------------------------*
*Build table to hold all table-areas attached to this sheet
    lo_iterator = io_worksheet->get_tables_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_table ?= lo_iterator->get_next( ).
      ls_table_area-left   = Lcl_excel_common=>convert_column2int( lo_table->settings-top_left_column ).
      ls_table_area-right  = lo_table->get_right_column_integer( ).
      ls_table_area-top    = lo_table->settings-top_left_row.
      ls_table_area-bottom = lo_table->get_bottom_row_integer( ).
      INSERT ls_table_area INTO TABLE lt_table_areas.
    ENDWHILE.
*--------------------------------------------------------------------*
*issue #220 - If cell in tables-area don't use default from row or column or sheet - Coding 1 - end
*--------------------------------------------------------------------*
*We have problems when the first rows or trailing rows are not set but we have rowinformation
*to solve this we add dummycontent into first and last line that will not be set
*Set first line if necessary
    READ TABLE io_worksheet->sheet_content TRANSPORTING NO FIELDS WITH KEY cell_row = 1.
    IF sy-subrc <> 0.
      ls_sheet_content_empty-cell_row      = 1.
      ls_sheet_content_empty-cell_column   = 1.
      ls_sheet_content_empty-cell_value    = lc_dummy_cell_content.
      INSERT ls_sheet_content_empty INTO TABLE io_worksheet->sheet_content.
    ENDIF.
*Set last line if necessary
*Last row with cell content
    lv_last_row = io_worksheet->get_highest_row( ).
*Last line with row-information set directly ( like line height, hidden-status ... )

    lo_row_iterator = io_worksheet->get_rows_iterator( ).
    WHILE lo_row_iterator->has_next( ) = abap_true.
      lo_row ?= lo_row_iterator->get_next( ).
      IF lo_row->get_row_index( ) > lv_last_row.
        lv_last_row = lo_row->get_row_index( ).
      ENDIF.
    ENDWHILE.

*Last line with row-information set indirectly by row outline
    lts_row_outlines = io_worksheet->get_row_outlines( ).
    LOOP AT lts_row_outlines ASSIGNING <ls_row_outline>.
      IF <ls_row_outline>-collapsed = 'X'.
        lv_current_row = <ls_row_outline>-row_to + 1.  " collapsed-status may be set on following row
      ELSE.
        lv_current_row = <ls_row_outline>-row_to.  " collapsed-status may be set on following row
      ENDIF.
      IF lv_current_row > lv_last_row.
        lv_last_row = lv_current_row.
      ENDIF.
    ENDLOOP.
    READ TABLE io_worksheet->sheet_content TRANSPORTING NO FIELDS WITH KEY cell_row = lv_last_row.
    IF sy-subrc <> 0.
      ls_sheet_content_empty-cell_row      = lv_last_row.
      ls_sheet_content_empty-cell_column   = 1.
      ls_sheet_content_empty-cell_value    = lc_dummy_cell_content.
      INSERT ls_sheet_content_empty INTO TABLE io_worksheet->sheet_content.
    ENDIF.

    CLEAR ls_sheet_content.
    LOOP AT io_worksheet->sheet_content INTO ls_sheet_content.
      IF lt_values IS INITIAL. " no values attached to autofilter  " issue #368 autofilter filtering too much
        CLEAR l_autofilter_hidden.
      ELSE.
        READ TABLE lt_values INTO ls_values WITH KEY column = ls_last_row-cell_column.
        IF sy-subrc = 0 AND ls_values-value = ls_last_row-cell_value.
          CLEAR l_autofilter_hidden.
        ENDIF.
      ENDIF.
      CLEAR ls_style_mapping.
*Create row element
*issues #346,#154, #195  - problems when we have information in row_dimension but no cell content in that row
*Get next line that may have to be added.  If we have empty lines this is the next line after previous cell content
*Otherwise it is the line of the current cell content
      lv_current_row = ls_last_row-cell_row + 1.
      IF lv_current_row > ls_sheet_content-cell_row.
        lv_current_row = ls_sheet_content-cell_row.
      ENDIF.
*Fill in empty lines if necessary - assign an emtpy sheet content
      lv_next_row = lv_current_row.
      WHILE lv_next_row <= ls_sheet_content-cell_row.
        lv_current_row = lv_next_row.
        lv_next_row = lv_current_row + 1.
        IF lv_current_row = ls_sheet_content-cell_row. " cell value found in this row
          ASSIGN ls_sheet_content TO <ls_sheet_content>.
        ELSE.
*Check if empty row is really necessary - this is basically the case when we have information in row_dimension
          lo_row_empty = io_worksheet->get_row( lv_current_row ).
          CHECK lo_row_empty->get_row_height( )                 >= 0          OR
                lo_row_empty->get_collapsed( io_worksheet )      = abap_true  OR
                lo_row_empty->get_outline_level( io_worksheet )  > 0          OR
                lo_row_empty->get_xf_index( )                   <> 0.
          " Dummyentry A1
          ls_sheet_content_empty-cell_row      = lv_current_row.
          ls_sheet_content_empty-cell_column   = 1.
          ASSIGN ls_sheet_content_empty TO <ls_sheet_content>.
        ENDIF.

        IF ls_last_row-cell_row NE <ls_sheet_content>-cell_row.
          IF lo_autofilter IS BOUND.
            IF ls_area-row_start >=  ls_last_row-cell_row OR " One less for header
              ls_area-row_end   < ls_last_row-cell_row .
              CLEAR l_autofilter_hidden.
            ENDIF.
          ELSE.
            CLEAR l_autofilter_hidden.
          ENDIF.
          IF ls_last_row-cell_row IS NOT INITIAL.
            " Row visibility of previos row.
            IF lo_row->get_visible( io_worksheet ) = abap_false OR
               l_autofilter_hidden = abap_true.
              lo_element_2->set_attribute_ns( name  = 'hidden' value = 'true' ).
            ENDIF.
            rv_ixml_sheet_data_root->append_child( new_child = lo_element_2 ). " row node
          ENDIF.
          " Add new row
          lo_element_2 = io_document->create_simple_element( name   = lc_xml_node_row
                                                             parent = io_document ).
          " r
          lv_value = <ls_sheet_content>-cell_row.
          SHIFT lv_value RIGHT DELETING TRAILING space.
          SHIFT lv_value LEFT DELETING LEADING space.

          lo_element_2->set_attribute_ns( name  = lc_xml_attr_r
                                          value = lv_value ).
          " Spans
          lv_value = col_count.
          CONCATENATE '1:' lv_value INTO lv_value.
          SHIFT lv_value RIGHT DELETING TRAILING space.
          SHIFT lv_value LEFT DELETING LEADING space.
          lo_element_2->set_attribute_ns( name  = lc_xml_attr_spans
                                          value = lv_value ).
          lo_row = io_worksheet->get_row( <ls_sheet_content>-cell_row ).
          " Row dimensions
          IF lo_row->get_custom_height( ) = abap_true.
            lo_element_2->set_attribute_ns( name  = 'customHeight' value = '1' ).
          ENDIF.
          IF lo_row->get_row_height( ) > 0.
            lv_value = lo_row->get_row_height( ).
            lo_element_2->set_attribute_ns( name  = 'ht' value = lv_value ).
          ENDIF.
          " Collapsed
          IF lo_row->get_collapsed( io_worksheet ) = abap_true.
            lo_element_2->set_attribute_ns( name  = 'collapsed' value = 'true' ).
          ENDIF.
          " Outline level
          IF lo_row->get_outline_level( io_worksheet ) > 0.
            lv_value = lo_row->get_outline_level( io_worksheet ).
            SHIFT lv_value RIGHT DELETING TRAILING space.
            SHIFT lv_value LEFT DELETING LEADING space.
            lo_element_2->set_attribute_ns( name  = 'outlineLevel' value = lv_value ).
          ENDIF.
          " Style
          IF lo_row->get_xf_index( ) <> 0.
            lv_value = lo_row->get_xf_index( ).
            lo_element_2->set_attribute_ns( name  = 's' value = lv_value ).
            lo_element_2->set_attribute_ns( name  = 'customFormat'  value = '1' ).
          ENDIF.
          IF lt_values IS INITIAL. " no values attached to autofilter  " issue #368 autofilter filtering too much
            CLEAR l_autofilter_hidden.
          ELSE.
            l_autofilter_hidden = abap_true. " First default is not showing
          ENDIF.
        ELSE.

        ENDIF.
      ENDWHILE.

      lo_element_3 = io_document->create_simple_element( name   = lc_xml_node_c
                                                         parent = io_document ).

      lo_element_3->set_attribute_ns( name  = lc_xml_attr_r
                                      value = <ls_sheet_content>-cell_coords ).

*begin of change issue #157 - allow column cellstyle
*if no cellstyle is set, look into column, then into sheet
      IF <ls_sheet_content>-cell_style IS NOT INITIAL.
        lv_style_guid = <ls_sheet_content>-cell_style.
      ELSE.
*--------------------------------------------------------------------*
*issue #220 - If cell in tables-area don't use default from row or column or sheet - Coding 2 - start
*--------------------------------------------------------------------*
*Check if cell in any of the table areas
        LOOP AT lt_table_areas TRANSPORTING NO FIELDS WHERE top    <= <ls_sheet_content>-cell_row
                                                        AND bottom >= <ls_sheet_content>-cell_row
                                                        AND left   <= <ls_sheet_content>-cell_column
                                                        AND right  >= <ls_sheet_content>-cell_column.
          EXIT.
        ENDLOOP.
        IF sy-subrc = 0.
          CLEAR lv_style_guid.     " No style --> EXCEL will use built-in-styles as declared in the tables-section
        ELSE.
*--------------------------------------------------------------------*
*issue #220 - If cell in tables-area don't use default from row or column or sheet - Coding 2 - end
*--------------------------------------------------------------------*
          lv_style_guid = io_worksheet->Lif_excel_sheet_properties~get_style( ).
          lo_column ?= io_worksheet->get_column( <ls_sheet_content>-cell_column ).
          IF lo_column->get_column_index( ) = <ls_sheet_content>-cell_column.
            lv_style_guid = lo_column->get_column_style_guid( ).
            IF lv_style_guid IS INITIAL.
              lv_style_guid = io_worksheet->Lif_excel_sheet_properties~get_style( ).
            ENDIF.
          ENDIF.

*--------------------------------------------------------------------*
*issue #220 - If cell in tables-area don't use default from row or column or sheet - Coding 3 - start
*--------------------------------------------------------------------*
        ENDIF.
*--------------------------------------------------------------------*
*issue #220 - If cell in tables-area don't use default from row or column or sheet - Coding 3 - end
*--------------------------------------------------------------------*
      ENDIF.
      IF lv_style_guid IS NOT INITIAL.
        READ TABLE styles_mapping INTO ls_style_mapping WITH KEY guid = lv_style_guid.
*end of change issue #157 - allow column cellstyles
        lv_value = ls_style_mapping-style.
        SHIFT lv_value RIGHT DELETING TRAILING space.
        SHIFT lv_value LEFT DELETING LEADING space.
        lo_element_3->set_attribute_ns( name  = lc_xml_attr_s
                                        value = lv_value ).
      ENDIF.

      " For cells with formula ignore the value - Excel will calculate it
      IF <ls_sheet_content>-cell_formula IS NOT INITIAL.
        " fomula node
        lo_element_4 = io_document->create_simple_element( name   = lc_xml_node_f
                                                           parent = io_document ).
        lo_element_4->set_value( value = <ls_sheet_content>-cell_formula ).
        lo_element_3->append_child( new_child = lo_element_4 ). " formula node
      ELSEIF <ls_sheet_content>-column_formula_id <> 0.
        create_xl_sheet_column_formula(
          EXPORTING
            io_document             = io_document
            it_column_formulas      = io_worksheet->column_formulas
            is_sheet_content        = <ls_sheet_content>
          IMPORTING
            eo_element              = lo_element_4
          CHANGING
            ct_column_formulas_used = lt_column_formulas_used
            cv_si                   = lv_si ).
        lo_element_3->append_child( new_child = lo_element_4 ).
      ELSEIF <ls_sheet_content>-cell_value IS NOT INITIAL           "cell can have just style or formula
         AND <ls_sheet_content>-cell_value <> lc_dummy_cell_content.
        IF <ls_sheet_content>-data_type IS NOT INITIAL.
          IF <ls_sheet_content>-data_type EQ 's_leading_blanks'.
            lo_element_3->set_attribute_ns( name  = lc_xml_attr_t
                                            value = 's' ).
          ELSE.
            lo_element_3->set_attribute_ns( name  = lc_xml_attr_t
                                            value = <ls_sheet_content>-data_type ).
          ENDIF.
        ENDIF.

        " value node
        lo_element_4 = io_document->create_simple_element( name   = lc_xml_node_v
                                                           parent = io_document ).

        IF <ls_sheet_content>-data_type EQ 's' OR <ls_sheet_content>-data_type EQ 's_leading_blanks'.
          lv_value = me->get_shared_string_index( ip_cell_value = <ls_sheet_content>-cell_value
                                                  it_rtf        = <ls_sheet_content>-rtf_tab ).
          CONDENSE lv_value.
          lo_element_4->set_value( value = lv_value ).
        ELSE.
          lv_value = <ls_sheet_content>-cell_value.
          CONDENSE lv_value.
          lo_element_4->set_value( value = lv_value ).
        ENDIF.

        lo_element_3->append_child( new_child = lo_element_4 ). " value node
      ENDIF.

      lo_element_2->append_child( new_child = lo_element_3 ). " column node
      ls_last_row = <ls_sheet_content>.
    ENDLOOP.
    IF sy-subrc = 0.
      READ TABLE lt_values INTO ls_values WITH KEY column = ls_last_row-cell_column.
      IF sy-subrc = 0 AND ls_values-value = ls_last_row-cell_value.
        CLEAR l_autofilter_hidden.
      ENDIF.
      IF lo_autofilter IS BOUND.
        IF ls_area-row_start >=  ls_last_row-cell_row OR " One less for header
          ls_area-row_end   < ls_last_row-cell_row .
          CLEAR l_autofilter_hidden.
        ENDIF.
      ELSE.
        CLEAR l_autofilter_hidden.
      ENDIF.
      " Row visibility of previos row.
      IF lo_row->get_visible( ) = abap_false OR
         l_autofilter_hidden = abap_true.
        lo_element_2->set_attribute_ns( name  = 'hidden' value = 'true' ).
      ENDIF.
      rv_ixml_sheet_data_root->append_child( new_child = lo_element_2 ). " row node
    ENDIF.
    DELETE io_worksheet->sheet_content WHERE cell_value = lc_dummy_cell_content.  " Get rid of dummyentries

  ENDMETHOD.
  METHOD create_xl_styles.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   dxfs-cellstyles are used in conditional formats:
*                CellIs, Expression, top10 ( forthcoming above average as well )
*                create own method to write dsfx-cellstyle to be reuseable by all these
*--------------------------------------------------------------------*


** Constant node name
    CONSTANTS: lc_xml_node_stylesheet        TYPE string VALUE 'styleSheet',
               " font
               lc_xml_node_fonts             TYPE string VALUE 'fonts',
               lc_xml_node_font              TYPE string VALUE 'font',
               lc_xml_node_color             TYPE string VALUE 'color',
               " fill
               lc_xml_node_fills             TYPE string VALUE 'fills',
               lc_xml_node_fill              TYPE string VALUE 'fill',
               lc_xml_node_patternfill       TYPE string VALUE 'patternFill',
               lc_xml_node_fgcolor           TYPE string VALUE 'fgColor',
               lc_xml_node_bgcolor           TYPE string VALUE 'bgColor',
               lc_xml_node_gradientfill      TYPE string VALUE 'gradientFill',
               lc_xml_node_stop              TYPE string VALUE 'stop',
               " borders
               lc_xml_node_borders           TYPE string VALUE 'borders',
               lc_xml_node_border            TYPE string VALUE 'border',
               lc_xml_node_left              TYPE string VALUE 'left',
               lc_xml_node_right             TYPE string VALUE 'right',
               lc_xml_node_top               TYPE string VALUE 'top',
               lc_xml_node_bottom            TYPE string VALUE 'bottom',
               lc_xml_node_diagonal          TYPE string VALUE 'diagonal',
               " numfmt
               lc_xml_node_numfmts           TYPE string VALUE 'numFmts',
               lc_xml_node_numfmt            TYPE string VALUE 'numFmt',
               " Styles
               lc_xml_node_cellstylexfs      TYPE string VALUE 'cellStyleXfs',
               lc_xml_node_xf                TYPE string VALUE 'xf',
               lc_xml_node_cellxfs           TYPE string VALUE 'cellXfs',
               lc_xml_node_cellstyles        TYPE string VALUE 'cellStyles',
               lc_xml_node_cellstyle         TYPE string VALUE 'cellStyle',
               lc_xml_node_dxfs              TYPE string VALUE 'dxfs',
               lc_xml_node_tablestyles       TYPE string VALUE 'tableStyles',
               " Colors
               lc_xml_node_colors            TYPE string VALUE 'colors',
               lc_xml_node_indexedcolors     TYPE string VALUE 'indexedColors',
               lc_xml_node_rgbcolor          TYPE string VALUE 'rgbColor',
               lc_xml_node_mrucolors         TYPE string VALUE 'mruColors',
               " Alignment
               lc_xml_node_alignment         TYPE string VALUE 'alignment',
               " Protection
               lc_xml_node_protection        TYPE string VALUE 'protection',
               " Node attributes
               lc_xml_attr_count             TYPE string VALUE 'count',
               lc_xml_attr_val               TYPE string VALUE 'val',
               lc_xml_attr_theme             TYPE string VALUE 'theme',
               lc_xml_attr_rgb               TYPE string VALUE 'rgb',
               lc_xml_attr_indexed           TYPE string VALUE 'indexed',
               lc_xml_attr_tint              TYPE string VALUE 'tint',
               lc_xml_attr_style             TYPE string VALUE 'style',
               lc_xml_attr_position          TYPE string VALUE 'position',
               lc_xml_attr_degree            TYPE string VALUE 'degree',
               lc_xml_attr_patterntype       TYPE string VALUE 'patternType',
               lc_xml_attr_numfmtid          TYPE string VALUE 'numFmtId',
               lc_xml_attr_fontid            TYPE string VALUE 'fontId',
               lc_xml_attr_fillid            TYPE string VALUE 'fillId',
               lc_xml_attr_borderid          TYPE string VALUE 'borderId',
               lc_xml_attr_xfid              TYPE string VALUE 'xfId',
               lc_xml_attr_applynumberformat TYPE string VALUE 'applyNumberFormat',
               lc_xml_attr_applyprotection   TYPE string VALUE 'applyProtection',
               lc_xml_attr_applyfont         TYPE string VALUE 'applyFont',
               lc_xml_attr_applyfill         TYPE string VALUE 'applyFill',
               lc_xml_attr_applyborder       TYPE string VALUE 'applyBorder',
               lc_xml_attr_name              TYPE string VALUE 'name',
               lc_xml_attr_builtinid         TYPE string VALUE 'builtinId',
               lc_xml_attr_defaulttablestyle TYPE string VALUE 'defaultTableStyle',
               lc_xml_attr_defaultpivotstyle TYPE string VALUE 'defaultPivotStyle',
               lc_xml_attr_applyalignment    TYPE string VALUE 'applyAlignment',
               lc_xml_attr_horizontal        TYPE string VALUE 'horizontal',
               lc_xml_attr_formatcode        TYPE string VALUE 'formatCode',
               lc_xml_attr_vertical          TYPE string VALUE 'vertical',
               lc_xml_attr_wraptext          TYPE string VALUE 'wrapText',
               lc_xml_attr_textrotation      TYPE string VALUE 'textRotation',
               lc_xml_attr_shrinktofit       TYPE string VALUE 'shrinkToFit',
               lc_xml_attr_indent            TYPE string VALUE 'indent',
               lc_xml_attr_locked            TYPE string VALUE 'locked',
               lc_xml_attr_hidden            TYPE string VALUE 'hidden',
               lc_xml_attr_diagonalup        TYPE string VALUE 'diagonalUp',
               lc_xml_attr_diagonaldown      TYPE string VALUE 'diagonalDown',
               " Node namespace
               lc_xml_node_ns                TYPE string VALUE 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
               lc_xml_attr_type              TYPE string VALUE 'type',
               lc_xml_attr_bottom            TYPE string VALUE 'bottom',
               lc_xml_attr_top               TYPE string VALUE 'top',
               lc_xml_attr_right             TYPE string VALUE 'right',
               lc_xml_attr_left              TYPE string VALUE 'left'.

    DATA: lo_document        TYPE REF TO if_ixml_document,
          lo_element_root    TYPE REF TO if_ixml_element,
          lo_element_fonts   TYPE REF TO if_ixml_element,
          lo_element_font    TYPE REF TO if_ixml_element,
          lo_element_fills   TYPE REF TO if_ixml_element,
          lo_element_fill    TYPE REF TO if_ixml_element,
          lo_element_borders TYPE REF TO if_ixml_element,
          lo_element_border  TYPE REF TO if_ixml_element,
          lo_element_numfmts TYPE REF TO if_ixml_element,
          lo_element_numfmt  TYPE REF TO if_ixml_element,
          lo_element_cellxfs TYPE REF TO if_ixml_element,
          lo_element         TYPE REF TO if_ixml_element,
          lo_sub_element     TYPE REF TO if_ixml_element,
          lo_sub_element_2   TYPE REF TO if_ixml_element,
          lo_iterator        TYPE REF TO Lcl_excel_collection_iterator,
          lo_iterator2       TYPE REF TO Lcl_excel_collection_iterator,
          lo_worksheet       TYPE REF TO Lcl_excel_worksheet,
          lo_style_cond      TYPE REF TO Lcl_excel_style_cond,
          lo_style           TYPE REF TO Lcl_excel_style.


    DATA: lt_fonts          TYPE zexcel_t_style_font,
          ls_font           TYPE zexcel_s_style_font,
          lt_fills          TYPE zexcel_t_style_fill,
          ls_fill           TYPE zexcel_s_style_fill,
          lt_borders        TYPE zexcel_t_style_border,
          ls_border         TYPE zexcel_s_style_border,
          lt_numfmts        TYPE zexcel_t_style_numfmt,
          ls_numfmt         TYPE zexcel_s_style_numfmt,
          lt_protections    TYPE zexcel_t_style_protection,
          ls_protection     TYPE zexcel_s_style_protection,
          lt_alignments     TYPE zexcel_t_style_alignment,
          ls_alignment      TYPE zexcel_s_style_alignment,
          lt_cellxfs        TYPE zexcel_t_cellxfs,
          ls_cellxfs        TYPE zexcel_s_cellxfs,
          ls_styles_mapping TYPE zexcel_s_styles_mapping,
          lt_colors         TYPE zexcel_t_style_color_argb,
          ls_color          LIKE LINE OF lt_colors.

    DATA: lv_value         TYPE string,
          lv_dfx_count     TYPE i,
          lv_fonts_count   TYPE i,
          lv_fills_count   TYPE i,
          lv_borders_count TYPE i,
          lv_cellxfs_count TYPE i.

    TYPES: BEGIN OF ts_built_in_format,
             num_format TYPE zexcel_number_format,
             id         TYPE i,
           END OF ts_built_in_format.

    DATA: lt_built_in_num_formats TYPE HASHED TABLE OF ts_built_in_format WITH UNIQUE KEY num_format,
          ls_built_in_num_format  LIKE LINE OF lt_built_in_num_formats.
    FIELD-SYMBOLS: <ls_built_in_format> LIKE LINE OF lt_built_in_num_formats,
                   <ls_reader_built_in> LIKE LINE OF Lcl_excel_style_number_format=>mt_built_in_num_formats.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

***********************************************************************
* STEP 3: Create main node relationships
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_stylesheet
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_ns ).

**********************************************************************
* STEP 4: Create subnodes

    lo_element_fonts = lo_document->create_simple_element( name   = lc_xml_node_fonts
                                                           parent = lo_document ).

    lo_element_fills = lo_document->create_simple_element( name   = lc_xml_node_fills
                                                           parent = lo_document ).

    lo_element_borders = lo_document->create_simple_element( name   = lc_xml_node_borders
                                                             parent = lo_document ).

    lo_element_cellxfs = lo_document->create_simple_element( name   = lc_xml_node_cellxfs
                                                             parent = lo_document ).

    lo_element_numfmts = lo_document->create_simple_element( name   = lc_xml_node_numfmts
                                                             parent = lo_document ).

* Prepare built-in number formats.
    LOOP AT Lcl_excel_style_number_format=>mt_built_in_num_formats ASSIGNING <ls_reader_built_in>.
      ls_built_in_num_format-id         = <ls_reader_built_in>-id.
      ls_built_in_num_format-num_format = <ls_reader_built_in>-format->format_code.
      INSERT ls_built_in_num_format INTO TABLE lt_built_in_num_formats.
    ENDLOOP.
* Compress styles
    lo_iterator = excel->get_styles_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_style ?= lo_iterator->get_next( ).
      ls_font       = lo_style->font->get_structure( ).
      ls_fill       = lo_style->fill->get_structure( ).
      ls_border     = lo_style->borders->get_structure( ).
      ls_alignment  = lo_style->alignment->get_structure( ).
      ls_protection = lo_style->protection->get_structure( ).
      ls_numfmt     = lo_style->number_format->get_structure( ).

      CLEAR ls_cellxfs.


* Compress fonts
      READ TABLE lt_fonts FROM ls_font TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        ls_cellxfs-fontid = sy-tabix.
      ELSE.
        APPEND ls_font TO lt_fonts.
        DESCRIBE TABLE lt_fonts LINES ls_cellxfs-fontid.
      ENDIF.
      SUBTRACT 1 FROM ls_cellxfs-fontid.

* Compress alignment
      READ TABLE lt_alignments FROM ls_alignment TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        ls_cellxfs-alignmentid = sy-tabix.
      ELSE.
        APPEND ls_alignment TO lt_alignments.
        DESCRIBE TABLE lt_alignments LINES ls_cellxfs-alignmentid.
      ENDIF.
      SUBTRACT 1 FROM ls_cellxfs-alignmentid.

* Compress fills
      READ TABLE lt_fills FROM ls_fill TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        ls_cellxfs-fillid = sy-tabix.
      ELSE.
        APPEND ls_fill TO lt_fills.
        DESCRIBE TABLE lt_fills LINES ls_cellxfs-fillid.
      ENDIF.
      SUBTRACT 1 FROM ls_cellxfs-fillid.

* Compress borders
      READ TABLE lt_borders FROM ls_border TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        ls_cellxfs-borderid = sy-tabix.
      ELSE.
        APPEND ls_border TO lt_borders.
        DESCRIBE TABLE lt_borders LINES ls_cellxfs-borderid.
      ENDIF.
      SUBTRACT 1 FROM ls_cellxfs-borderid.

* Compress protection
      IF ls_protection-locked EQ c_on AND ls_protection-hidden EQ c_off.
        ls_cellxfs-applyprotection    = 0.
      ELSE.
        READ TABLE lt_protections FROM ls_protection TRANSPORTING NO FIELDS.
        IF sy-subrc EQ 0.
          ls_cellxfs-protectionid = sy-tabix.
        ELSE.
          APPEND ls_protection TO lt_protections.
          DESCRIBE TABLE lt_protections LINES ls_cellxfs-protectionid.
        ENDIF.
        ls_cellxfs-applyprotection    = 1.
      ENDIF.
      SUBTRACT 1 FROM ls_cellxfs-protectionid.

* Compress number formats

      "-----------
      IF ls_numfmt-numfmt NE Lcl_excel_style_number_format=>c_format_date_std." and ls_numfmt-NUMFMT ne 'STD_NDEC'. " ALE Changes on going
        "---
        IF ls_numfmt IS NOT INITIAL.
* issue  #389 - Problem with built-in format ( those are not being taken account of )
* There are some internal number formats built-in into EXCEL
* Use these instead of duplicating the entries here, since they seem to be language-dependant and adjust to user settings in excel
          READ TABLE lt_built_in_num_formats ASSIGNING <ls_built_in_format> WITH TABLE KEY num_format = ls_numfmt-numfmt.
          IF sy-subrc = 0.
            ls_cellxfs-numfmtid = <ls_built_in_format>-id.
          ELSE.
            READ TABLE lt_numfmts FROM ls_numfmt TRANSPORTING NO FIELDS.
            IF sy-subrc EQ 0.
              ls_cellxfs-numfmtid = sy-tabix.
            ELSE.
              APPEND ls_numfmt TO lt_numfmts.
              DESCRIBE TABLE lt_numfmts LINES ls_cellxfs-numfmtid.
            ENDIF.
            ADD Lcl_excel_common=>c_excel_numfmt_offset TO ls_cellxfs-numfmtid. " Add OXML offset for custom styles
          ENDIF.
          ls_cellxfs-applynumberformat    = 1.
        ELSE.
          ls_cellxfs-applynumberformat    = 0.
        ENDIF.
        "----------- " ALE changes on going
      ELSE.
        ls_cellxfs-applynumberformat    = 1.
        IF ls_numfmt-numfmt EQ Lcl_excel_style_number_format=>c_format_date_std.
          ls_cellxfs-numfmtid = 14.
        ENDIF.
      ENDIF.
      "---

      IF ls_cellxfs-fontid NE 0.
        ls_cellxfs-applyfont    = 1.
      ELSE.
        ls_cellxfs-applyfont    = 0.
      ENDIF.
      IF ls_cellxfs-alignmentid NE 0.
        ls_cellxfs-applyalignment = 1.
      ELSE.
        ls_cellxfs-applyalignment = 0.
      ENDIF.
      IF ls_cellxfs-fillid NE 0.
        ls_cellxfs-applyfill    = 1.
      ELSE.
        ls_cellxfs-applyfill    = 0.
      ENDIF.
      IF ls_cellxfs-borderid NE 0.
        ls_cellxfs-applyborder    = 1.
      ELSE.
        ls_cellxfs-applyborder    = 0.
      ENDIF.

* Remap styles
      READ TABLE lt_cellxfs FROM ls_cellxfs TRANSPORTING NO FIELDS.
      IF sy-subrc EQ 0.
        ls_styles_mapping-style = sy-tabix.
      ELSE.
        APPEND ls_cellxfs TO lt_cellxfs.
        DESCRIBE TABLE lt_cellxfs LINES ls_styles_mapping-style.
      ENDIF.
      SUBTRACT 1 FROM ls_styles_mapping-style.
      ls_styles_mapping-guid = lo_style->get_guid( ).
      APPEND ls_styles_mapping TO me->styles_mapping.
    ENDWHILE.

    " create numfmt elements
    LOOP AT lt_numfmts INTO ls_numfmt.
      lo_element_numfmt = lo_document->create_simple_element( name   = lc_xml_node_numfmt
                                                              parent = lo_document ).
      lv_value = sy-tabix + Lcl_excel_common=>c_excel_numfmt_offset.
      CONDENSE lv_value.
      lo_element_numfmt->set_attribute_ns( name  = lc_xml_attr_numfmtid
                                        value = lv_value ).
      lv_value = ls_numfmt-numfmt.
      lo_element_numfmt->set_attribute_ns( name  = lc_xml_attr_formatcode
                                           value = lv_value ).
      lo_element_numfmts->append_child( new_child = lo_element_numfmt ).
    ENDLOOP.

    " create font elements
    LOOP AT lt_fonts INTO ls_font.
      lo_element_font = lo_document->create_simple_element( name   = lc_xml_node_font
                                                            parent = lo_document ).
      create_xl_styles_font_node( io_document = lo_document
                                  io_parent   = lo_element_font
                                  is_font     = ls_font ).
      lo_element_fonts->append_child( new_child = lo_element_font ).
    ENDLOOP.

    " create fill elements
    LOOP AT lt_fills INTO ls_fill.
      lo_element_fill = lo_document->create_simple_element( name   = lc_xml_node_fill
                                                            parent = lo_document ).

      IF ls_fill-gradtype IS NOT INITIAL.
        "gradient

        lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_gradientfill
                                                            parent = lo_document ).
        IF ls_fill-gradtype-degree IS NOT INITIAL.
          lv_value = ls_fill-gradtype-degree.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_degree  value = lv_value ).
        ENDIF.
        IF ls_fill-gradtype-type IS NOT INITIAL.
          lv_value = ls_fill-gradtype-type.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_type  value = lv_value ).
        ENDIF.
        IF ls_fill-gradtype-bottom IS NOT INITIAL.
          lv_value = ls_fill-gradtype-bottom.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_bottom  value = lv_value ).
        ENDIF.
        IF ls_fill-gradtype-top IS NOT INITIAL.
          lv_value = ls_fill-gradtype-top.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_top  value = lv_value ).
        ENDIF.
        IF ls_fill-gradtype-right IS NOT INITIAL.
          lv_value = ls_fill-gradtype-right.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_right  value = lv_value ).
        ENDIF.
        IF ls_fill-gradtype-left IS NOT INITIAL.
          lv_value = ls_fill-gradtype-left.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_left  value = lv_value ).
        ENDIF.

        IF ls_fill-gradtype-position3 IS NOT INITIAL.
          "create <stop> elements for gradients, we can have 2 or 3 stops in each gradient
          lo_sub_element_2 =  lo_document->create_simple_element( name   = lc_xml_node_stop
                                                                  parent = lo_sub_element ).
          lv_value = ls_fill-gradtype-position1.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_position value = lv_value ).

          create_xl_styles_color_node(
              io_document        = lo_document
              io_parent          = lo_sub_element_2
              is_color           = ls_fill-bgcolor
              iv_color_elem_name = lc_xml_node_color ).
          lo_sub_element->append_child( new_child = lo_sub_element_2 ).

          lo_sub_element_2 = lo_document->create_simple_element( name   = lc_xml_node_stop
                                                                 parent = lo_sub_element ).

          lv_value = ls_fill-gradtype-position2.

          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_position
                                              value = lv_value ).

          create_xl_styles_color_node(
              io_document        = lo_document
              io_parent          = lo_sub_element_2
              is_color           = ls_fill-fgcolor
              iv_color_elem_name = lc_xml_node_color ).
          lo_sub_element->append_child( new_child = lo_sub_element_2 ).

          lo_sub_element_2 = lo_document->create_simple_element( name   = lc_xml_node_stop
                                                                 parent = lo_sub_element ).

          lv_value = ls_fill-gradtype-position3.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_position
                                              value = lv_value ).

          create_xl_styles_color_node(
              io_document        = lo_document
              io_parent          = lo_sub_element_2
              is_color           = ls_fill-bgcolor
              iv_color_elem_name = lc_xml_node_color ).
          lo_sub_element->append_child( new_child = lo_sub_element_2 ).

        ELSE.
          "create <stop> elements for gradients, we can have 2 or 3 stops in each gradient
          lo_sub_element_2 =  lo_document->create_simple_element( name   = lc_xml_node_stop
                                                                  parent = lo_sub_element ).
          lv_value = ls_fill-gradtype-position1.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_position value = lv_value ).

          create_xl_styles_color_node(
              io_document        = lo_document
              io_parent          = lo_sub_element_2
              is_color           = ls_fill-bgcolor
              iv_color_elem_name = lc_xml_node_color ).
          lo_sub_element->append_child( new_child = lo_sub_element_2 ).

          lo_sub_element_2 = lo_document->create_simple_element( name   = lc_xml_node_stop
                                                                 parent = lo_sub_element ).

          lv_value = ls_fill-gradtype-position2.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_position
                                              value = lv_value ).

          create_xl_styles_color_node(
              io_document        = lo_document
              io_parent          = lo_sub_element_2
              is_color           = ls_fill-fgcolor
              iv_color_elem_name = lc_xml_node_color ).
          lo_sub_element->append_child( new_child = lo_sub_element_2 ).
        ENDIF.

      ELSE.
        "pattern
        lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_patternfill
                                                             parent = lo_document ).
        lv_value = ls_fill-filltype.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_patterntype
                                          value = lv_value ).
        " fgcolor
        create_xl_styles_color_node(
            io_document        = lo_document
            io_parent          = lo_sub_element
            is_color           = ls_fill-fgcolor
            iv_color_elem_name = lc_xml_node_fgcolor ).

        IF  ls_fill-fgcolor-rgb IS INITIAL AND
            ls_fill-fgcolor-indexed EQ Lcl_excel_style_color=>c_indexed_not_set AND
            ls_fill-fgcolor-theme EQ Lcl_excel_style_color=>c_theme_not_set AND
            ls_fill-fgcolor-tint IS INITIAL AND ls_fill-bgcolor-indexed EQ Lcl_excel_style_color=>c_indexed_sys_foreground.

          " bgcolor
          create_xl_styles_color_node(
              io_document        = lo_document
              io_parent          = lo_sub_element
              is_color           = ls_fill-bgcolor
              iv_color_elem_name = lc_xml_node_bgcolor ).

        ENDIF.
      ENDIF.

      lo_element_fill->append_child( new_child = lo_sub_element )."pattern
      lo_element_fills->append_child( new_child = lo_element_fill ).
    ENDLOOP.

    " create border elements
    LOOP AT lt_borders INTO ls_border.
      lo_element_border = lo_document->create_simple_element( name   = lc_xml_node_border
                                                              parent = lo_document ).

      IF ls_border-diagonalup IS NOT INITIAL.
        lv_value = ls_border-diagonalup.
        CONDENSE lv_value.
        lo_element_border->set_attribute_ns( name  = lc_xml_attr_diagonalup
                                          value = lv_value ).
      ENDIF.

      IF ls_border-diagonaldown IS NOT INITIAL.
        lv_value = ls_border-diagonaldown.
        CONDENSE lv_value.
        lo_element_border->set_attribute_ns( name  = lc_xml_attr_diagonaldown
                                          value = lv_value ).
      ENDIF.

      "left
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_left
                                                           parent = lo_document ).
      IF ls_border-left_style IS NOT INITIAL.
        lv_value = ls_border-left_style.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_style
                                          value = lv_value ).
      ENDIF.

      create_xl_styles_color_node(
          io_document        = lo_document
          io_parent          = lo_sub_element
          is_color           = ls_border-left_color ).

      lo_element_border->append_child( new_child = lo_sub_element ).

      "right
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_right
                                                           parent = lo_document ).
      IF ls_border-right_style IS NOT INITIAL.
        lv_value = ls_border-right_style.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_style
                                          value = lv_value ).
      ENDIF.

      create_xl_styles_color_node(
          io_document        = lo_document
          io_parent          = lo_sub_element
          is_color           = ls_border-right_color ).

      lo_element_border->append_child( new_child = lo_sub_element ).

      "top
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_top
                                                           parent = lo_document ).
      IF ls_border-top_style IS NOT INITIAL.
        lv_value = ls_border-top_style.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_style
                                          value = lv_value ).
      ENDIF.

      create_xl_styles_color_node(
          io_document        = lo_document
          io_parent          = lo_sub_element
          is_color           = ls_border-top_color ).

      lo_element_border->append_child( new_child = lo_sub_element ).

      "bottom
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_bottom
                                                           parent = lo_document ).
      IF ls_border-bottom_style IS NOT INITIAL.
        lv_value = ls_border-bottom_style.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_style
                                          value = lv_value ).
      ENDIF.

      create_xl_styles_color_node(
          io_document        = lo_document
          io_parent          = lo_sub_element
          is_color           = ls_border-bottom_color ).

      lo_element_border->append_child( new_child = lo_sub_element ).

      "diagonal
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_diagonal
                                                           parent = lo_document ).
      IF ls_border-diagonal_style IS NOT INITIAL.
        lv_value = ls_border-diagonal_style.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_style
                                          value = lv_value ).
      ENDIF.

      create_xl_styles_color_node(
          io_document        = lo_document
          io_parent          = lo_sub_element
          is_color           = ls_border-diagonal_color ).

      lo_element_border->append_child( new_child = lo_sub_element ).
      lo_element_borders->append_child( new_child = lo_element_border ).
    ENDLOOP.

    " update attribute "count"
    DESCRIBE TABLE lt_fonts LINES lv_fonts_count.
    lv_value = lv_fonts_count.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_element_fonts->set_attribute_ns( name  = lc_xml_attr_count
                                        value = lv_value ).
    DESCRIBE TABLE lt_fills LINES lv_fills_count.
    lv_value = lv_fills_count.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_element_fills->set_attribute_ns( name  = lc_xml_attr_count
                                        value = lv_value ).
    DESCRIBE TABLE lt_borders LINES lv_borders_count.
    lv_value = lv_borders_count.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_element_borders->set_attribute_ns( name  = lc_xml_attr_count
                                          value = lv_value ).
    DESCRIBE TABLE lt_cellxfs LINES lv_cellxfs_count.
    lv_value = lv_cellxfs_count.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_element_cellxfs->set_attribute_ns( name  = lc_xml_attr_count
                                          value = lv_value ).

    " Append to root node
    lo_element_root->append_child( new_child = lo_element_numfmts ).
    lo_element_root->append_child( new_child = lo_element_fonts ).
    lo_element_root->append_child( new_child = lo_element_fills ).
    lo_element_root->append_child( new_child = lo_element_borders ).

    " cellstylexfs node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_cellstylexfs
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_count
                                  value = '1' ).
    lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_xf
                                                         parent = lo_document ).

    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_numfmtid
                                      value = c_off ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_fontid
                                      value = c_off ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_fillid
                                      value = c_off ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_borderid
                                      value = c_off ).

    lo_element->append_child( new_child = lo_sub_element ).
    lo_element_root->append_child( new_child = lo_element ).

    LOOP AT lt_cellxfs INTO ls_cellxfs.
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_xf
                                                          parent = lo_document ).
      lv_value = ls_cellxfs-numfmtid.
      SHIFT lv_value RIGHT DELETING TRAILING space.
      SHIFT lv_value LEFT DELETING LEADING space.
      lo_element->set_attribute_ns( name  = lc_xml_attr_numfmtid
                                    value = lv_value ).
      lv_value = ls_cellxfs-fontid.
      SHIFT lv_value RIGHT DELETING TRAILING space.
      SHIFT lv_value LEFT DELETING LEADING space.
      lo_element->set_attribute_ns( name  = lc_xml_attr_fontid
                                    value = lv_value ).
      lv_value = ls_cellxfs-fillid.
      SHIFT lv_value RIGHT DELETING TRAILING space.
      SHIFT lv_value LEFT DELETING LEADING space.
      lo_element->set_attribute_ns( name  = lc_xml_attr_fillid
                                    value = lv_value ).
      lv_value = ls_cellxfs-borderid.
      SHIFT lv_value RIGHT DELETING TRAILING space.
      SHIFT lv_value LEFT DELETING LEADING space.
      lo_element->set_attribute_ns( name  = lc_xml_attr_borderid
                                    value = lv_value ).
      lv_value = ls_cellxfs-xfid.
      SHIFT lv_value RIGHT DELETING TRAILING space.
      SHIFT lv_value LEFT DELETING LEADING space.
      lo_element->set_attribute_ns( name  = lc_xml_attr_xfid
                                    value = lv_value ).
      IF ls_cellxfs-applynumberformat EQ 1.
        lv_value = ls_cellxfs-applynumberformat.
        SHIFT lv_value RIGHT DELETING TRAILING space.
        SHIFT lv_value LEFT DELETING LEADING space.
        lo_element->set_attribute_ns( name  = lc_xml_attr_applynumberformat
                                      value = lv_value ).
      ENDIF.
      IF ls_cellxfs-applyfont EQ 1.
        lv_value = ls_cellxfs-applyfont.
        SHIFT lv_value RIGHT DELETING TRAILING space.
        SHIFT lv_value LEFT DELETING LEADING space.
        lo_element->set_attribute_ns( name  = lc_xml_attr_applyfont
                                      value = lv_value ).
      ENDIF.
      IF ls_cellxfs-applyfill EQ 1.
        lv_value = ls_cellxfs-applyfill.
        SHIFT lv_value RIGHT DELETING TRAILING space.
        SHIFT lv_value LEFT DELETING LEADING space.
        lo_element->set_attribute_ns( name  = lc_xml_attr_applyfill
                                      value = lv_value ).
      ENDIF.
      IF ls_cellxfs-applyborder EQ 1.
        lv_value = ls_cellxfs-applyborder.
        SHIFT lv_value RIGHT DELETING TRAILING space.
        SHIFT lv_value LEFT DELETING LEADING space.
        lo_element->set_attribute_ns( name  = lc_xml_attr_applyborder
                                      value = lv_value ).
      ENDIF.
      IF ls_cellxfs-applyalignment EQ 1. " depends on each style not for all the sheet
        lv_value = ls_cellxfs-applyalignment.
        SHIFT lv_value RIGHT DELETING TRAILING space.
        SHIFT lv_value LEFT DELETING LEADING space.
        lo_element->set_attribute_ns( name  = lc_xml_attr_applyalignment
                                      value = lv_value ).
        lo_sub_element_2 = lo_document->create_simple_element( name   = lc_xml_node_alignment
                                                               parent = lo_document ).
        ADD 1 TO ls_cellxfs-alignmentid. "Table index starts from 1
        READ TABLE lt_alignments INTO ls_alignment INDEX ls_cellxfs-alignmentid.
        SUBTRACT 1 FROM ls_cellxfs-alignmentid.
        IF ls_alignment-horizontal IS NOT INITIAL.
          lv_value = ls_alignment-horizontal.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_horizontal
                                              value = lv_value ).
        ENDIF.
        IF ls_alignment-vertical IS NOT INITIAL.
          lv_value = ls_alignment-vertical.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_vertical
                                              value = lv_value ).
        ENDIF.
        IF ls_alignment-wraptext EQ abap_true.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_wraptext
                                              value = c_on ).
        ENDIF.
        IF ls_alignment-textrotation IS NOT INITIAL.
          lv_value = ls_alignment-textrotation.
          SHIFT lv_value RIGHT DELETING TRAILING space.
          SHIFT lv_value LEFT DELETING LEADING space.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_textrotation
                                              value = lv_value ).
        ENDIF.
        IF ls_alignment-shrinktofit EQ abap_true.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_shrinktofit
                                              value = c_on ).
        ENDIF.
        IF ls_alignment-indent IS NOT INITIAL.
          lv_value = ls_alignment-indent.
          SHIFT lv_value RIGHT DELETING TRAILING space.
          SHIFT lv_value LEFT DELETING LEADING space.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_indent
                                              value = lv_value ).
        ENDIF.

        lo_element->append_child( new_child = lo_sub_element_2 ).
      ENDIF.
      IF ls_cellxfs-applyprotection EQ 1.
        lv_value = ls_cellxfs-applyprotection.
        CONDENSE lv_value NO-GAPS.
        lo_element->set_attribute_ns( name  = lc_xml_attr_applyprotection
                                      value = lv_value ).
        lo_sub_element_2 = lo_document->create_simple_element( name   = lc_xml_node_protection
                                                               parent = lo_document ).
        ADD 1 TO ls_cellxfs-protectionid. "Table index starts from 1
        READ TABLE lt_protections INTO ls_protection INDEX ls_cellxfs-protectionid.
        SUBTRACT 1 FROM ls_cellxfs-protectionid.
        IF ls_protection-locked IS NOT INITIAL.
          lv_value = ls_protection-locked.
          CONDENSE lv_value.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_locked
                                              value = lv_value ).
        ENDIF.
        IF ls_protection-hidden IS NOT INITIAL.
          lv_value = ls_protection-hidden.
          CONDENSE lv_value.
          lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_hidden
                                              value = lv_value ).
        ENDIF.
        lo_element->append_child( new_child = lo_sub_element_2 ).
      ENDIF.
      lo_element_cellxfs->append_child( new_child = lo_element ).
    ENDLOOP.

    lo_element_root->append_child( new_child = lo_element_cellxfs ).

    " cellStyles node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_cellstyles
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_count
                                  value = '1' ).
    lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_cellstyle
                                                         parent = lo_document ).

    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_name
                                      value = 'Normal' ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_xfid
                                      value = c_off ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_builtinid
                                      value = c_off ).

    lo_element->append_child( new_child = lo_sub_element ).
    lo_element_root->append_child( new_child = lo_element ).

    " dxfs node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_dxfs
                                                     parent = lo_document ).

    lo_iterator = me->excel->get_worksheets_iterator( ).
    " get sheets
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).
      " Conditional formatting styles into exch sheet
      lo_iterator2 = lo_worksheet->get_style_cond_iterator( ).
      WHILE lo_iterator2->has_next( ) EQ abap_true.
        lo_style_cond ?= lo_iterator2->get_next( ).
        CASE lo_style_cond->rule.
* begin of change issue #366 - missing conditional rules: top10, move dfx-styles to own method
          WHEN Lcl_excel_style_cond=>c_rule_cellis.
            me->create_dxf_style( EXPORTING
                                    iv_cell_style    = lo_style_cond->mode_cellis-cell_style
                                    io_dxf_element   = lo_element
                                    io_ixml_document = lo_document
                                    it_cellxfs       = lt_cellxfs
                                    it_fonts         = lt_fonts
                                    it_fills         = lt_fills
                                  CHANGING
                                    cv_dfx_count     = lv_dfx_count ).

          WHEN Lcl_excel_style_cond=>c_rule_expression.
            me->create_dxf_style( EXPORTING
                          iv_cell_style    = lo_style_cond->mode_expression-cell_style
                          io_dxf_element   = lo_element
                          io_ixml_document = lo_document
                          it_cellxfs       = lt_cellxfs
                          it_fonts         = lt_fonts
                          it_fills         = lt_fills
                        CHANGING
                          cv_dfx_count     = lv_dfx_count ).



          WHEN Lcl_excel_style_cond=>c_rule_top10.
            me->create_dxf_style( EXPORTING
                                    iv_cell_style    = lo_style_cond->mode_top10-cell_style
                                    io_dxf_element   = lo_element
                                    io_ixml_document = lo_document
                                    it_cellxfs       = lt_cellxfs
                                    it_fonts         = lt_fonts
                                    it_fills         = lt_fills
                                  CHANGING
                                    cv_dfx_count     = lv_dfx_count ).

          WHEN Lcl_excel_style_cond=>c_rule_above_average.
            me->create_dxf_style( EXPORTING
                                    iv_cell_style    = lo_style_cond->mode_above_average-cell_style
                                    io_dxf_element   = lo_element
                                    io_ixml_document = lo_document
                                    it_cellxfs       = lt_cellxfs
                                    it_fonts         = lt_fonts
                                    it_fills         = lt_fills
                                  CHANGING
                                    cv_dfx_count     = lv_dfx_count ).
* begin of change issue #366 - missing conditional rules: top10, move dfx-styles to own method

          WHEN OTHERS.
            CONTINUE.
        ENDCASE.
      ENDWHILE.
    ENDWHILE.

    lv_value = lv_dfx_count.
    CONDENSE lv_value.
    lo_element->set_attribute_ns( name  = lc_xml_attr_count
                                  value = lv_value ).
    lo_element_root->append_child( new_child = lo_element ).

    " tableStyles node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_tablestyles
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_count
                                  value = '0' ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_defaulttablestyle
                                  value = Lcl_excel_table=>builtinstyle_medium9 ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_defaultpivotstyle
                                  value = Lcl_excel_table=>builtinstyle_pivot_light16 ).
    lo_element_root->append_child( new_child = lo_element ).

    "write legacy color palette in case any indexed color was changed
    IF excel->legacy_palette->is_modified( ) = abap_true.
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_colors
                                                     parent   = lo_document ).
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_indexedcolors
                                                         parent   = lo_document ).
      lo_element->append_child( new_child = lo_sub_element ).

      lt_colors = excel->legacy_palette->get_colors( ).
      LOOP AT lt_colors INTO ls_color.
        lo_sub_element_2 = lo_document->create_simple_element( name   = lc_xml_node_rgbcolor
                                                               parent = lo_document ).
        lv_value = ls_color.
        lo_sub_element_2->set_attribute_ns( name  = lc_xml_attr_rgb
                                            value = lv_value ).
        lo_sub_element->append_child( new_child = lo_sub_element_2 ).
      ENDLOOP.

      lo_element_root->append_child( new_child = lo_element ).
    ENDIF.

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_styles_color_node.
    DATA: lo_sub_element TYPE REF TO if_ixml_element,
          lv_value       TYPE string.

    CONSTANTS: lc_xml_attr_theme   TYPE string VALUE 'theme',
               lc_xml_attr_rgb     TYPE string VALUE 'rgb',
               lc_xml_attr_indexed TYPE string VALUE 'indexed',
               lc_xml_attr_tint    TYPE string VALUE 'tint'.

    "add node only if at least one attribute is set
    CHECK is_color-rgb IS NOT INITIAL OR
          is_color-indexed <> Lcl_excel_style_color=>c_indexed_not_set OR
          is_color-theme <> Lcl_excel_style_color=>c_theme_not_set OR
          is_color-tint IS NOT INITIAL.

    lo_sub_element = io_document->create_simple_element(
        name      = iv_color_elem_name
        parent    = io_parent ).

    IF is_color-rgb IS NOT INITIAL.
      lv_value = is_color-rgb.
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_rgb
                                        value = lv_value ).
    ENDIF.

    IF is_color-indexed <> Lcl_excel_style_color=>c_indexed_not_set.
      lv_value = Lcl_excel_common=>number_to_excel_string( is_color-indexed ).
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_indexed
                                        value = lv_value ).
    ENDIF.

    IF is_color-theme <> Lcl_excel_style_color=>c_theme_not_set.
      lv_value = Lcl_excel_common=>number_to_excel_string( is_color-theme ).
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_theme
                                        value = lv_value ).
    ENDIF.

    IF is_color-tint IS NOT INITIAL.
      lv_value = Lcl_excel_common=>number_to_excel_string( is_color-tint ).
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_tint
                                        value = lv_value ).
    ENDIF.

    io_parent->append_child( new_child = lo_sub_element ).
  ENDMETHOD.
  METHOD create_xl_styles_font_node.

    CONSTANTS: lc_xml_node_b      TYPE string VALUE 'b',            "bold
               lc_xml_node_i      TYPE string VALUE 'i',            "italic
               lc_xml_node_u      TYPE string VALUE 'u',            "underline
               lc_xml_node_strike TYPE string VALUE 'strike',       "strikethrough
               lc_xml_node_sz     TYPE string VALUE 'sz',
               lc_xml_node_name   TYPE string VALUE 'name',
               lc_xml_node_rfont  TYPE string VALUE 'rFont',
               lc_xml_node_family TYPE string VALUE 'family',
               lc_xml_node_scheme TYPE string VALUE 'scheme',
               lc_xml_attr_val    TYPE string VALUE 'val'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_font TYPE REF TO if_ixml_element,
          ls_font         TYPE zexcel_s_style_font,
          lo_sub_element  TYPE REF TO if_ixml_element,
          lv_value        TYPE string.

    lo_document = io_document.
    lo_element_font = io_parent.
    ls_font = is_font.

    IF ls_font-bold EQ abap_true.
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_b
                                                           parent = lo_document ).
      lo_element_font->append_child( new_child = lo_sub_element ).
    ENDIF.
    IF ls_font-italic EQ abap_true.
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_i
                                                           parent = lo_document ).
      lo_element_font->append_child( new_child = lo_sub_element ).
    ENDIF.
    IF ls_font-underline EQ abap_true.
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_u
                                                           parent = lo_document ).
      lv_value = ls_font-underline_mode.
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_val
                                        value = lv_value ).
      lo_element_font->append_child( new_child = lo_sub_element ).
    ENDIF.
    IF ls_font-strikethrough EQ abap_true.
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_strike
                                                           parent = lo_document ).
      lo_element_font->append_child( new_child = lo_sub_element ).
    ENDIF.
    "size
    lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_sz
                                                         parent = lo_document ).
    lv_value = ls_font-size.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_val
                                      value = lv_value ).
    lo_element_font->append_child( new_child = lo_sub_element ).
    "color
    create_xl_styles_color_node(
        io_document        = lo_document
        io_parent          = lo_element_font
        is_color           = ls_font-color ).

    "name
    IF iv_use_rtf = abap_false.
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_name
                                                           parent = lo_document ).
    ELSE.
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_rfont
                                                           parent = lo_document ).
    ENDIF.
    lv_value = ls_font-name.
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_val
                                      value = lv_value ).
    lo_element_font->append_child( new_child = lo_sub_element ).
    "family
    lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_family
                                                         parent = lo_document ).
    lv_value = ls_font-family.
    SHIFT lv_value RIGHT DELETING TRAILING space.
    SHIFT lv_value LEFT DELETING LEADING space.
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_val
                                      value = lv_value ).
    lo_element_font->append_child( new_child = lo_sub_element ).
    "scheme
    IF ls_font-scheme IS NOT INITIAL.
      lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_scheme
                                                           parent = lo_document ).
      lv_value = ls_font-scheme.
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_val
                                        value = lv_value ).
      lo_element_font->append_child( new_child = lo_sub_element ).
    ENDIF.

  ENDMETHOD.
  METHOD create_xl_table.

    DATA: lc_xml_node_table        TYPE string VALUE 'table',
          lc_xml_node_relationship TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id           TYPE string VALUE 'id',
          lc_xml_attr_name         TYPE string VALUE 'name',
          lc_xml_attr_display_name TYPE string VALUE 'displayName',
          lc_xml_attr_ref          TYPE string VALUE 'ref',
          lc_xml_attr_totals       TYPE string VALUE 'totalsRowShown',
          " Node namespace
          lc_xml_node_table_ns     TYPE string VALUE 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
          " Node id
          lc_xml_node_ridx_id      TYPE string VALUE 'rId#'.

    DATA: lo_document     TYPE REF TO if_ixml_document,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_element      TYPE REF TO if_ixml_element,
          lo_element2     TYPE REF TO if_ixml_element,
          lo_element3     TYPE REF TO if_ixml_element,
          lv_table_name   TYPE string,
          lv_id           TYPE i,
          lv_match        TYPE i,
          lv_ref          TYPE string,
          lv_value        TYPE string,
          lv_num_columns  TYPE i,
          ls_fieldcat     TYPE zexcel_s_fieldcatalog.


**********************************************************************
* STEP 1: Create xml
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node table
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_table
                                                           parent = lo_document ).

    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_table_ns  ).

    lv_id = io_table->get_id( ).
    lv_value = Lcl_excel_common=>number_to_excel_string( ip_value = lv_id ).
    lo_element_root->set_attribute_ns( name  = lc_xml_attr_id
                                       value = lv_value ).

    FIND ALL OCCURRENCES OF REGEX '[^_a-zA-Z0-9]' IN io_table->settings-table_name IGNORING CASE MATCH COUNT lv_match.
    IF io_table->settings-table_name IS NOT INITIAL AND lv_match EQ 0.
      " Name rules (https://support.microsoft.com/en-us/office/rename-an-excel-table-fbf49a4f-82a3-43eb-8ba2-44d21233b114)
      "   - You can't use "C", "c", "R", or "r" for the name, because they're already designated as a shortcut for selecting the column or row for the active cell when you enter them in the Name or Go To box.
      "   - Don't use cell references — Names can't be the same as a cell reference, such as Z$100 or R1C1
      IF ( strlen( io_table->settings-table_name ) = 1 AND io_table->settings-table_name CO 'CcRr' )
         OR Lcl_excel_common=>shift_formula(
              iv_reference_formula = io_table->settings-table_name
              iv_shift_cols        = 0
              iv_shift_rows        = 1 ) <> io_table->settings-table_name.
        lv_table_name = io_table->get_name( ).
      ELSE.
        lv_table_name = io_table->settings-table_name.
      ENDIF.
    ELSE.
      lv_table_name = io_table->get_name( ).
    ENDIF.
    lo_element_root->set_attribute_ns( name  = lc_xml_attr_name
                                       value = lv_table_name ).

    lo_element_root->set_attribute_ns( name  = lc_xml_attr_display_name
                                       value = lv_table_name ).

    lv_ref = io_table->get_reference( ).
    lo_element_root->set_attribute_ns( name  = lc_xml_attr_ref
                                       value = lv_ref ).
    IF io_table->has_totals( ) = abap_true.
      lo_element_root->set_attribute_ns( name  = 'totalsRowCount'
                                             value = '1' ).
    ELSE.
      lo_element_root->set_attribute_ns( name  = lc_xml_attr_totals
                                           value = '0' ).
    ENDIF.

**********************************************************************
* STEP 4: Create subnodes

    " autoFilter
    IF io_table->settings-nofilters EQ abap_false.
      lo_element = lo_document->create_simple_element( name   = 'autoFilter'
                                                       parent = lo_document ).

      lv_ref = io_table->get_reference( ip_include_totals_row = abap_false ).
      lo_element->set_attribute_ns( name  = 'ref'
                                    value = lv_ref ).

      lo_element_root->append_child( new_child = lo_element ).
    ENDIF.

    "columns
    lo_element = lo_document->create_simple_element( name   = 'tableColumns'
                                                     parent = lo_document ).

    LOOP AT io_table->fieldcat INTO ls_fieldcat WHERE dynpfld = abap_true.
      ADD 1 TO lv_num_columns.
    ENDLOOP.

    lv_value = lv_num_columns.
    CONDENSE lv_value.
    lo_element->set_attribute_ns( name  = 'count'
                                  value = lv_value ).

    lo_element_root->append_child( new_child = lo_element ).

    LOOP AT io_table->fieldcat INTO ls_fieldcat WHERE dynpfld = abap_true.
      lo_element2 = lo_document->create_simple_element_ns( name   = 'tableColumn'
                                                                  parent = lo_element ).

      lv_value = ls_fieldcat-position.
      SHIFT lv_value LEFT DELETING LEADING '0'.
      lo_element2->set_attribute_ns( name  = 'id'
                                    value = lv_value ).

      lv_value = ls_fieldcat-column_name.

      " The text "_x...._", with "_x" not "_X", with exactly 4 ".", each being 0-9 a-f or A-F (case insensitive), is interpreted
      " like Unicode character U+.... (e.g. "_x0041_" is rendered like "A") is for characters.
      " To not interpret it, Excel replaces the first "_" is to be replaced with "_x005f_".
      IF lv_value CS '_x'.
        REPLACE ALL OCCURRENCES OF REGEX '_(x[0-9a-fA-F]{4}_)' IN lv_value WITH '_x005f_$1' RESPECTING CASE.
      ENDIF.

      " XML chapter 2.2: Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
      " NB: although Excel supports _x0009_, it's not rendered except if you edit the text.
      " Excel considers _x000d_ as being an error (_x000a_ is sufficient and rendered).
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>newline IN lv_value WITH '_x000a_'.
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf(1) IN lv_value WITH ``.
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>horizontal_tab IN lv_value WITH '_x0009_'.

      lo_element2->set_attribute_ns( name  = 'name'
                                    value = lv_value ).

      IF ls_fieldcat-totals_function IS NOT INITIAL.
        lo_element2->set_attribute_ns( name  = 'totalsRowFunction'
                                          value = ls_fieldcat-totals_function ).
      ENDIF.

      IF ls_fieldcat-column_formula IS NOT INITIAL.
        lv_value = ls_fieldcat-column_formula.
        CONDENSE lv_value.
        lo_element3 = lo_document->create_simple_element_ns( name   = 'calculatedColumnFormula'
                                                             parent = lo_element2 ).
        lo_element3->set_value( lv_value ).
        lo_element2->append_child( new_child = lo_element3 ).
      ENDIF.

      lo_element->append_child( new_child = lo_element2 ).
    ENDLOOP.


    lo_element = lo_document->create_simple_element( name   = 'tableStyleInfo'
                                                          parent = lo_element_root ).

    lo_element->set_attribute_ns( name  = 'name'
                                       value = io_table->settings-table_style  ).

    lo_element->set_attribute_ns( name  = 'showFirstColumn'
                                       value = '0' ).

    lo_element->set_attribute_ns( name  = 'showLastColumn'
                                       value = '0' ).

    IF io_table->settings-show_row_stripes = abap_true.
      lv_value = '1'.
    ELSE.
      lv_value = '0'.
    ENDIF.

    lo_element->set_attribute_ns( name  = 'showRowStripes'
                                       value = lv_value ).

    IF io_table->settings-show_column_stripes = abap_true.
      lv_value = '1'.
    ELSE.
      lv_value = '0'.
    ENDIF.

    lo_element->set_attribute_ns( name  = 'showColumnStripes'
                                       value = lv_value ).

    lo_element_root->append_child( new_child = lo_element ).
**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xl_theme.
    DATA: lo_theme TYPE REF TO Lcl_excel_theme.

    excel->get_theme(
    IMPORTING
      eo_theme = lo_theme
      ).
    IF lo_theme IS INITIAL.
      CREATE OBJECT lo_theme.
    ENDIF.
    ep_content = lo_theme->write_theme( ).

  ENDMETHOD.
  METHOD create_xl_workbook.
*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-07
*              - ...
* changes: aligning code
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns
*           - Stefan Schmoecker,                             2012-12-01
* changes:  correction of pointer to localSheetId
*--------------------------------------------------------------------*

** Constant node name
    DATA: lc_xml_node_workbook           TYPE string VALUE 'workbook',
          lc_xml_node_fileversion        TYPE string VALUE 'fileVersion',
          lc_xml_node_workbookpr         TYPE string VALUE 'workbookPr',
          lc_xml_node_bookviews          TYPE string VALUE 'bookViews',
          lc_xml_node_workbookview       TYPE string VALUE 'workbookView',
          lc_xml_node_sheets             TYPE string VALUE 'sheets',
          lc_xml_node_sheet              TYPE string VALUE 'sheet',
          lc_xml_node_calcpr             TYPE string VALUE 'calcPr',
          lc_xml_node_workbookprotection TYPE string VALUE 'workbookProtection',
          lc_xml_node_definednames       TYPE string VALUE 'definedNames',
          lc_xml_node_definedname        TYPE string VALUE 'definedName',
          " Node attributes
          lc_xml_attr_appname            TYPE string VALUE 'appName',
          lc_xml_attr_lastedited         TYPE string VALUE 'lastEdited',
          lc_xml_attr_lowestedited       TYPE string VALUE 'lowestEdited',
          lc_xml_attr_rupbuild           TYPE string VALUE 'rupBuild',
          lc_xml_attr_xwindow            TYPE string VALUE 'xWindow',
          lc_xml_attr_ywindow            TYPE string VALUE 'yWindow',
          lc_xml_attr_windowwidth        TYPE string VALUE 'windowWidth',
          lc_xml_attr_windowheight       TYPE string VALUE 'windowHeight',
          lc_xml_attr_activetab          TYPE string VALUE 'activeTab',
          lc_xml_attr_name               TYPE string VALUE 'name',
          lc_xml_attr_sheetid            TYPE string VALUE 'sheetId',
          lc_xml_attr_state              TYPE string VALUE 'state',
          lc_xml_attr_id                 TYPE string VALUE 'id',
          lc_xml_attr_calcid             TYPE string VALUE 'calcId',
          lc_xml_attr_lockrevision       TYPE string VALUE 'lockRevision',
          lc_xml_attr_lockstructure      TYPE string VALUE 'lockStructure',
          lc_xml_attr_lockwindows        TYPE string VALUE 'lockWindows',
          lc_xml_attr_revisionspassword  TYPE string VALUE 'revisionsPassword',
          lc_xml_attr_workbookpassword   TYPE string VALUE 'workbookPassword',
          lc_xml_attr_hidden             TYPE string VALUE 'hidden',
          lc_xml_attr_localsheetid       TYPE string VALUE 'localSheetId',
          " Node namespace
          lc_r_ns                        TYPE string VALUE 'r',
          lc_xml_node_ns                 TYPE string VALUE 'http://schemas.openxmlformats.org/spreadsheetml/2006/main',
          lc_xml_node_r_ns               TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships',
          " Node id
          lc_xml_node_ridx_id            TYPE string VALUE 'rId#'.

    DATA: lo_document       TYPE REF TO if_ixml_document,
          lo_element_root   TYPE REF TO if_ixml_element,
          lo_element        TYPE REF TO if_ixml_element,
          lo_element_range  TYPE REF TO if_ixml_element,
          lo_sub_element    TYPE REF TO if_ixml_element,
          lo_iterator       TYPE REF TO Lcl_excel_collection_iterator,
          lo_iterator_range TYPE REF TO Lcl_excel_collection_iterator,
          lo_worksheet      TYPE REF TO Lcl_excel_worksheet,
          lo_range          TYPE REF TO Lcl_excel_range,
          lo_autofilters    TYPE REF TO Lcl_excel_autofilters,
          lo_autofilter     TYPE REF TO Lcl_excel_autofilter.

    DATA: lv_xml_node_ridx_id TYPE string,
          lv_value            TYPE string,
          lv_syindex          TYPE string,
          lv_active_sheet     TYPE zexcel_active_worksheet.

**********************************************************************
* STEP 1: Create [Content_Types].xml into the root of the ZIP
    lo_document = create_xml_document( ).

**********************************************************************
* STEP 3: Create main node
    lo_element_root  = lo_document->create_simple_element( name   = lc_xml_node_workbook
                                                           parent = lo_document ).
    lo_element_root->set_attribute_ns( name  = 'xmlns'
                                       value = lc_xml_node_ns ).
    lo_element_root->set_attribute_ns( name  = 'xmlns:r'
                                       value = lc_xml_node_r_ns ).

**********************************************************************
* STEP 4: Create subnode
    " fileVersion node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_fileversion
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_appname
                                  value = 'xl' ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_lastedited
                                  value = '4' ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_lowestedited
                                  value = '4' ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_rupbuild
                                  value = '4506' ).
    lo_element_root->append_child( new_child = lo_element ).

    " fileVersion node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_workbookpr
                                                     parent = lo_document ).
    lo_element_root->append_child( new_child = lo_element ).

    " workbookProtection node
    IF me->excel->Lif_excel_book_protection~protected EQ abap_true.
      lo_element = lo_document->create_simple_element( name   = lc_xml_node_workbookprotection
                                                       parent = lo_document ).
      lv_value = me->excel->Lif_excel_book_protection~workbookpassword.
      IF lv_value IS NOT INITIAL.
        lo_element->set_attribute_ns( name  = lc_xml_attr_workbookpassword
                                      value = lv_value ).
      ENDIF.
      lv_value = me->excel->Lif_excel_book_protection~revisionspassword.
      IF lv_value IS NOT INITIAL.
        lo_element->set_attribute_ns( name  = lc_xml_attr_revisionspassword
                                      value = lv_value ).
      ENDIF.
      lv_value = me->excel->Lif_excel_book_protection~lockrevision.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_lockrevision
                                    value = lv_value ).
      lv_value = me->excel->Lif_excel_book_protection~lockstructure.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_lockstructure
                                    value = lv_value ).
      lv_value = me->excel->Lif_excel_book_protection~lockwindows.
      CONDENSE lv_value NO-GAPS.
      lo_element->set_attribute_ns( name  = lc_xml_attr_lockwindows
                                    value = lv_value ).
      lo_element_root->append_child( new_child = lo_element ).
    ENDIF.

    " bookviews node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_bookviews
                                                     parent = lo_document ).
    " bookview node
    lo_sub_element = lo_document->create_simple_element( name   = lc_xml_node_workbookview
                                                         parent = lo_document ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_xwindow
                                      value = '120' ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_ywindow
                                      value = '120' ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_windowwidth
                                      value = '19035' ).
    lo_sub_element->set_attribute_ns( name  = lc_xml_attr_windowheight
                                      value = '8445' ).
    " Set Active Sheet
    lv_active_sheet = excel->get_active_sheet_index( ).
* issue #365 - test if sheet exists - otherwise set active worksheet to 1
    lo_worksheet = excel->get_worksheet_by_index( lv_active_sheet ).
    IF lo_worksheet IS NOT BOUND.
      lv_active_sheet = 1.
      excel->set_active_sheet_index( lv_active_sheet ).
    ENDIF.
    IF lv_active_sheet > 1.
      lv_active_sheet = lv_active_sheet - 1.
      lv_value = lv_active_sheet.
      CONDENSE lv_value.
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_activetab
                                        value = lv_value ).
    ENDIF.
    lo_element->append_child( new_child = lo_sub_element )." bookview node
    lo_element_root->append_child( new_child = lo_element )." bookviews node

    " sheets node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_sheets
                                                     parent = lo_document ).
    lo_iterator = excel->get_worksheets_iterator( ).

    " ranges node
    lo_element_range = lo_document->create_simple_element( name   = lc_xml_node_definednames " issue 163 +
                                                           parent = lo_document ).           " issue 163 +

    WHILE lo_iterator->has_next( ) EQ abap_true.
      " sheet node
      lo_sub_element = lo_document->create_simple_element_ns( name   = lc_xml_node_sheet
                                                              parent = lo_document ).
      lo_worksheet ?= lo_iterator->get_next( ).
      lv_syindex = sy-index.                                                                  " question by Stefan SchmÃ¶cker 2012-12-02:  sy-index seems to do the job - but is it proven to work or purely coincedence
      lv_value = lo_worksheet->get_title( ).
      SHIFT lv_syindex RIGHT DELETING TRAILING space.
      SHIFT lv_syindex LEFT DELETING LEADING space.
      lv_xml_node_ridx_id = lc_xml_node_ridx_id.
      REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_ridx_id WITH lv_syindex.
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_name
                                        value = lv_value ).
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_sheetid
                                        value = lv_syindex ).
      IF lo_worksheet->Lif_excel_sheet_properties~hidden EQ Lif_excel_sheet_properties=>c_hidden.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_state
                                          value = 'hidden' ).
      ELSEIF lo_worksheet->Lif_excel_sheet_properties~hidden EQ Lif_excel_sheet_properties=>c_veryhidden.
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_state
                                          value = 'veryHidden' ).
      ENDIF.
      lo_sub_element->set_attribute_ns( name    = lc_xml_attr_id
                                        prefix  = lc_r_ns
                                        value   = lv_xml_node_ridx_id ).
      lo_element->append_child( new_child = lo_sub_element ). " sheet node

      " issue 163 >>>
      lo_iterator_range = lo_worksheet->get_ranges_iterator( ).

*--------------------------------------------------------------------*
* Defined names sheetlocal:  Ranges, Repeat rows and columns
*--------------------------------------------------------------------*
      WHILE lo_iterator_range->has_next( ) EQ abap_true.
        " range node
        lo_sub_element = lo_document->create_simple_element_ns( name   = lc_xml_node_definedname
                                                                parent = lo_document ).
        lo_range ?= lo_iterator_range->get_next( ).
        lv_value = lo_range->name.

        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_name
                                          value = lv_value ).

*      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_localsheetid           "del #235 Repeat rows/cols - EXCEL starts couting from zero
*                                        value = lv_xml_node_ridx_id ).             "del #235 Repeat rows/cols - and needs absolute referencing to localSheetId
        lv_value   = lv_syindex - 1.                                                  "ins #235 Repeat rows/cols
        CONDENSE lv_value NO-GAPS.                                                    "ins #235 Repeat rows/cols
        lo_sub_element->set_attribute_ns( name  = lc_xml_attr_localsheetid
                                          value = lv_value ).

        lv_value = lo_range->get_value( ).
        lo_sub_element->set_value( value = lv_value ).
        lo_element_range->append_child( new_child = lo_sub_element ). " range node

      ENDWHILE.
      " issue 163 <<<

    ENDWHILE.
    lo_element_root->append_child( new_child = lo_element )." sheets node


*--------------------------------------------------------------------*
* Defined names workbookgolbal:  Ranges
*--------------------------------------------------------------------*
*  " ranges node
*  lo_element = lo_document->create_simple_element( name   = lc_xml_node_definednames " issue 163 -
*                                                   parent = lo_document ).           " issue 163 -
    lo_iterator = excel->get_ranges_iterator( ).

    WHILE lo_iterator->has_next( ) EQ abap_true.
      " range node
      lo_sub_element = lo_document->create_simple_element_ns( name   = lc_xml_node_definedname
                                                              parent = lo_document ).
      lo_range ?= lo_iterator->get_next( ).
      lv_value = lo_range->name.
      lo_sub_element->set_attribute_ns( name  = lc_xml_attr_name
                                        value = lv_value ).
      lv_value = lo_range->get_value( ).
      lo_sub_element->set_value( value = lv_value ).
      lo_element_range->append_child( new_child = lo_sub_element ). " range node

    ENDWHILE.

*--------------------------------------------------------------------*
* Defined names - Autofilters ( also sheetlocal )
*--------------------------------------------------------------------*
    lo_autofilters = excel->get_autofilters_reference( ).
    IF lo_autofilters->is_empty( ) = abap_false.
      lo_iterator = excel->get_worksheets_iterator( ).
      WHILE lo_iterator->has_next( ) EQ abap_true.

        lo_worksheet ?= lo_iterator->get_next( ).
        lv_syindex = sy-index - 1 .
        lo_autofilter = lo_autofilters->get( io_worksheet = lo_worksheet ).
        IF lo_autofilter IS BOUND.
          lo_sub_element = lo_document->create_simple_element_ns( name   = lc_xml_node_definedname
                                                                  parent = lo_document ).
          lv_value = lo_autofilters->c_autofilter.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_name
                                            value = lv_value ).
          lv_value = lv_syindex.
          CONDENSE lv_value NO-GAPS.
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_localsheetid
                                            value = lv_value ).
          lv_value = '1'. " Always hidden
          lo_sub_element->set_attribute_ns( name  = lc_xml_attr_hidden
                                            value = lv_value ).
          lv_value = lo_autofilter->get_filter_reference( ).
          lo_sub_element->set_value( value = lv_value ).
          lo_element_range->append_child( new_child = lo_sub_element ). " range node
        ENDIF.

      ENDWHILE.
    ENDIF.
    lo_element_root->append_child( new_child = lo_element_range ).                      " ranges node


    " calcPr node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_calcpr
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_calcid
                                  value = '125725' ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 5: Create xstring stream
    ep_content = render_xml_document( lo_document ).

  ENDMETHOD.
  METHOD create_xml_document.
    DATA lo_encoding TYPE REF TO if_ixml_encoding.
    lo_encoding = me->ixml->create_encoding( byte_order = if_ixml_encoding=>co_platform_endian
                                             character_set = 'utf-8' ).
    ro_document = me->ixml->create_document( ).
    ro_document->set_encoding( lo_encoding ).
    ro_document->set_standalone( abap_true ).
  ENDMETHOD.
  METHOD flag2bool.


    IF ip_flag EQ abap_true.
      ep_boolean = 'true'.
    ELSE.
      ep_boolean = 'false'.
    ENDIF.
  ENDMETHOD.
  METHOD get_shared_string_index.


    DATA ls_shared_string TYPE zexcel_s_shared_string.

    IF it_rtf IS INITIAL.
      READ TABLE shared_strings INTO ls_shared_string WITH TABLE KEY string_value = ip_cell_value.
      ep_index = ls_shared_string-string_no.
    ELSE.
      LOOP AT shared_strings INTO ls_shared_string WHERE string_value = ip_cell_value
                                                     AND rtf_tab = it_rtf.

        ep_index = ls_shared_string-string_no.
        EXIT.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD is_formula_shareable.
    DATA: lv_test_shared TYPE string.

    ep_shareable = abap_false.
    IF ip_formula NA '!'.
      lv_test_shared = Lcl_excel_common=>shift_formula(
          iv_reference_formula = ip_formula
          iv_shift_cols        = 1
          iv_shift_rows        = 1 ).
      IF lv_test_shared <> ip_formula.
        ep_shareable = abap_true.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD render_xml_document.
    DATA lo_streamfactory TYPE REF TO if_ixml_stream_factory.
    DATA lo_ostream       TYPE REF TO if_ixml_ostream.
    DATA lo_renderer      TYPE REF TO if_ixml_renderer.
    DATA lv_string        TYPE string.

    " So that the rendering of io_document to a XML text in UTF-8 XSTRING works for all Unicode characters (Chinese,
    " emoticons, etc.) the method CREATE_OSTREAM_CSTRING must be used instead of CREATE_OSTREAM_XSTRING as explained
    " in note 2922674 below (original there: https://launchpad.support.sap.com/#/notes/2922674), and then the STRING
    " variable can be converted into UTF-8.
    "
    " Excerpt from Note 2922674 - Support for Unicode Characters U+10000 to U+10FFFF in the iXML kernel library / ABAP package SIXML.
    "
    "   You are running a unicode system with SAP Netweaver / SAP_BASIS release equal or lower than 7.51.
    "
    "   Some functions in the iXML kernel library / ABAP package SIXML does not fully or incorrectly support unicode
    "   characters of the supplementary planes. This is caused by using UCS-2 in codepage conversion functions.
    "   Therefore, when reading from iXML input steams, the characters from the supplementary planes, that are not
    "   supported by UCS-2, might be replaced by the character #. When writing to iXML output streams, UTF-16 surrogate
    "   pairs, representing characters from the supplementary planes, might be incorrectly encoded in UTF-8.
    "
    "   The characters incorrectly encoded in UTF-8, might be accepted as input for the iXML parser or external parsers,
    "   but might also be rejected.
    "
    "   Support for unicode characters of the supplementary planes was introduced for SAP_BASIS 7.51 or lower with note
    "   2220720, but later withdrawn with note 2346627 for functional issues.
    "
    "   Characters of the supplementary planes are supported with ABAP Platform 1709 / SAP_BASIS 7.52 and higher.
    "
    "   Please note, that the iXML runtime behaves like the ABAP runtime concerning the handling of unicode characters of
    "   the supplementary planes. In iXML and ABAP, these characters have length 2 (as returned by ABAP build-in function
    "   STRLEN), and string processing functions like SUBSTRING might split these characters into 2 invalid characters
    "   with length 1. These invalid characters are commonly referred to as broken surrogate pairs.
    "
    "   A workaround for the incorrect UTF-8 encoding in SAP_BASIS 7.51 or lower is to render the document to an ABAP
    "   variable with type STRING using a output stream created with factory method IF_IXML_STREAM_FACTORY=>CREATE_OSTREAM_CSTRING
    "   and then to convert the STRING variable to UTF-8 using method CL_ABAP_CODEPAGE=>CONVERT_TO.

    " 1) RENDER TO XML STRING
    lo_streamfactory = me->ixml->create_stream_factory( ).
    lo_ostream = lo_streamfactory->create_ostream_cstring( string = lv_string ).
    lo_renderer = me->ixml->create_renderer( ostream  = lo_ostream document = io_document ).
    lo_renderer->render( ).

    " 2) CONVERT IT TO UTF-8
    "-----------------
    " The beginning of the XML string has these 57 characters:
    "   X<?xml version="1.0" encoding="utf-16" standalone="yes"?>
    "   (where "X" is the special character corresponding to the utf-16 BOM, hexadecimal FFFE or FEFF,
    "   but there's no "X" in non-Unicode SAP systems)
    " The encoding must be removed otherwise Excel would fail to decode correctly the UTF-8 XML.
    " For a better performance, it's assumed that "encoding" is in the first 100 characters.
    IF strlen( lv_string ) < 100.
      REPLACE REGEX 'encoding="[^"]+"' IN lv_string WITH ``.
    ELSE.
      REPLACE REGEX 'encoding="[^"]+"' IN SECTION LENGTH 100 OF lv_string WITH ``.
    ENDIF.
    " Convert XML text to UTF-8 (NB: if 2 first bytes are the UTF-16 BOM, they are converted into 3 bytes of UTF-8 BOM)
    ep_content = cl_abap_codepage=>convert_to( source = lv_string ).
    " Add the UTF-8 Byte Order Mark if missing (NB: that serves as substitute of "encoding")
    IF xstrlen( ep_content ) >= 3 AND ep_content(3) <> cl_abap_char_utilities=>byte_order_mark_utf8.
      CONCATENATE cl_abap_char_utilities=>byte_order_mark_utf8 ep_content INTO ep_content IN BYTE MODE.
    ENDIF.

  ENDMETHOD.
  METHOD set_vml_shape_footer.

    CONSTANTS: lc_shape               TYPE string VALUE '<v:shape id="{ID}" o:spid="_x0000_s1025" type="#_x0000_t75" style=''position:absolute;margin-left:0;margin-top:0;width:{WIDTH}pt;height:{HEIGHT}pt; z-index:1''>',
               lc_shape_image         TYPE string VALUE '<v:imagedata o:relid="{RID}" o:title="Logo Title"/><o:lock v:ext="edit" rotation="t"/></v:shape>',
               lc_shape_header_center TYPE string VALUE 'CH',
               lc_shape_header_left   TYPE string VALUE 'LH',
               lc_shape_header_right  TYPE string VALUE 'RH',
               lc_shape_footer_center TYPE string VALUE 'CF',
               lc_shape_footer_left   TYPE string VALUE 'LF',
               lc_shape_footer_right  TYPE string VALUE 'RF'.

    DATA: lv_content_left         TYPE string,
          lv_content_center       TYPE string,
          lv_content_right        TYPE string,
          lv_content_image_left   TYPE string,
          lv_content_image_center TYPE string,
          lv_content_image_right  TYPE string,
          lv_value                TYPE string,
          ls_drawing_position     TYPE zexcel_drawing_position.

    IF is_footer-left_image IS NOT INITIAL.
      lv_content_left = lc_shape.
      REPLACE '{ID}' IN lv_content_left WITH lc_shape_footer_left.
      ls_drawing_position = is_footer-left_image->get_position( ).
      IF ls_drawing_position-size-height IS NOT INITIAL.
        lv_value = ls_drawing_position-size-height.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{HEIGHT}' IN lv_content_left WITH lv_value.
      IF ls_drawing_position-size-width IS NOT INITIAL.
        lv_value = ls_drawing_position-size-width.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{WIDTH}' IN lv_content_left WITH lv_value.
      lv_content_image_left = lc_shape_image.
      lv_value = is_footer-left_image->get_index( ).
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      REPLACE '{RID}' IN lv_content_image_left WITH lv_value.
    ENDIF.
    IF is_footer-center_image IS NOT INITIAL.
      lv_content_center = lc_shape.
      REPLACE '{ID}' IN lv_content_center WITH lc_shape_footer_center.
      ls_drawing_position = is_footer-left_image->get_position( ).
      IF ls_drawing_position-size-height IS NOT INITIAL.
        lv_value = ls_drawing_position-size-height.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{HEIGHT}' IN lv_content_center WITH lv_value.
      IF ls_drawing_position-size-width IS NOT INITIAL.
        lv_value = ls_drawing_position-size-width.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{WIDTH}' IN lv_content_center WITH lv_value.
      lv_content_image_center = lc_shape_image.
      lv_value = is_footer-center_image->get_index( ).
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      REPLACE '{RID}' IN lv_content_image_center WITH lv_value.
    ENDIF.
    IF is_footer-right_image IS NOT INITIAL.
      lv_content_right = lc_shape.
      REPLACE '{ID}' IN lv_content_right WITH lc_shape_footer_right.
      ls_drawing_position = is_footer-left_image->get_position( ).
      IF ls_drawing_position-size-height IS NOT INITIAL.
        lv_value = ls_drawing_position-size-height.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{HEIGHT}' IN lv_content_right WITH lv_value.
      IF ls_drawing_position-size-width IS NOT INITIAL.
        lv_value = ls_drawing_position-size-width.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{WIDTH}' IN lv_content_right WITH lv_value.
      lv_content_image_right = lc_shape_image.
      lv_value = is_footer-right_image->get_index( ).
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      REPLACE '{RID}' IN lv_content_image_right WITH lv_value.
    ENDIF.

    CONCATENATE lv_content_left
                lv_content_image_left
                lv_content_center
                lv_content_image_center
                lv_content_right
                lv_content_image_right
           INTO ep_content.

  ENDMETHOD.
  METHOD set_vml_shape_header.

*  CONSTANTS: lc_shape TYPE string VALUE '<v:shape id="{ID}" o:spid="_x0000_s1025" type="#_x0000_t75" style=''position:absolute;margin-left:0;margin-top:0;width:198.75pt;height:48.75pt; z-index:1''>',
    CONSTANTS: lc_shape               TYPE string VALUE '<v:shape id="{ID}" o:spid="_x0000_s1025" type="#_x0000_t75" style=''position:absolute;margin-left:0;margin-top:0;width:{WIDTH}pt;height:{HEIGHT}pt; z-index:1''>',
               lc_shape_image         TYPE string VALUE '<v:imagedata o:relid="{RID}" o:title="Logo Title"/><o:lock v:ext="edit" rotation="t"/></v:shape>',
               lc_shape_header_center TYPE string VALUE 'CH',
               lc_shape_header_left   TYPE string VALUE 'LH',
               lc_shape_header_right  TYPE string VALUE 'RH',
               lc_shape_footer_center TYPE string VALUE 'CF',
               lc_shape_footer_left   TYPE string VALUE 'LF',
               lc_shape_footer_right  TYPE string VALUE 'RF'.

    DATA: lv_content_left         TYPE string,
          lv_content_center       TYPE string,
          lv_content_right        TYPE string,
          lv_content_image_left   TYPE string,
          lv_content_image_center TYPE string,
          lv_content_image_right  TYPE string,
          lv_value                TYPE string,
          ls_drawing_position     TYPE zexcel_drawing_position.

    CLEAR ep_content.

    IF is_header-left_image IS NOT INITIAL.
      lv_content_left = lc_shape.
      REPLACE '{ID}' IN lv_content_left WITH lc_shape_header_left.
      ls_drawing_position = is_header-left_image->get_position( ).
      IF ls_drawing_position-size-height IS NOT INITIAL.
        lv_value = ls_drawing_position-size-height.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{HEIGHT}' IN lv_content_left WITH lv_value.
      IF ls_drawing_position-size-width IS NOT INITIAL.
        lv_value = ls_drawing_position-size-width.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{WIDTH}' IN lv_content_left WITH lv_value.
      lv_content_image_left = lc_shape_image.
      lv_value = is_header-left_image->get_index( ).
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      REPLACE '{RID}' IN lv_content_image_left WITH lv_value.
    ENDIF.
    IF is_header-center_image IS NOT INITIAL.
      lv_content_center = lc_shape.
      REPLACE '{ID}' IN lv_content_center WITH lc_shape_header_center.
      ls_drawing_position = is_header-center_image->get_position( ).
      IF ls_drawing_position-size-height IS NOT INITIAL.
        lv_value = ls_drawing_position-size-height.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{HEIGHT}' IN lv_content_center WITH lv_value.
      IF ls_drawing_position-size-width IS NOT INITIAL.
        lv_value = ls_drawing_position-size-width.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{WIDTH}' IN lv_content_center WITH lv_value.
      lv_content_image_center = lc_shape_image.
      lv_value = is_header-center_image->get_index( ).
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      REPLACE '{RID}' IN lv_content_image_center WITH lv_value.
    ENDIF.
    IF is_header-right_image IS NOT INITIAL.
      lv_content_right = lc_shape.
      REPLACE '{ID}' IN lv_content_right WITH lc_shape_header_right.
      ls_drawing_position = is_header-right_image->get_position( ).
      IF ls_drawing_position-size-height IS NOT INITIAL.
        lv_value = ls_drawing_position-size-height.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{HEIGHT}' IN lv_content_right WITH lv_value.
      IF ls_drawing_position-size-width IS NOT INITIAL.
        lv_value = ls_drawing_position-size-width.
      ELSE.
        lv_value = '100'.
      ENDIF.
      CONDENSE lv_value.
      REPLACE '{WIDTH}' IN lv_content_right WITH lv_value.
      lv_content_image_right = lc_shape_image.
      lv_value = is_header-right_image->get_index( ).
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO lv_value.
      REPLACE '{RID}' IN lv_content_image_right WITH lv_value.
    ENDIF.

    CONCATENATE lv_content_left
                lv_content_image_left
                lv_content_center
                lv_content_image_center
                lv_content_right
                lv_content_image_right
           INTO ep_content.

  ENDMETHOD.
  METHOD set_vml_string.

    DATA:
      ld_1           TYPE string,
      ld_2           TYPE string,
      ld_3           TYPE string,
      ld_4           TYPE string,
      ld_5           TYPE string,
      ld_7           TYPE string,

      lv_relation_id TYPE i,
      lo_iterator    TYPE REF TO Lcl_excel_collection_iterator,
      lo_worksheet   TYPE REF TO Lcl_excel_worksheet,
      ls_odd_header  TYPE zexcel_s_worksheet_head_foot,
      ls_odd_footer  TYPE zexcel_s_worksheet_head_foot,
      ls_even_header TYPE zexcel_s_worksheet_head_foot,
      ls_even_footer TYPE zexcel_s_worksheet_head_foot.


* INIT_RESULT
    CLEAR ep_content.


* BODY
    ld_1 = '<xml xmlns:v="urn:schemas-microsoft-com:vml"  xmlns:o="urn:schemas-microsoft-com:office:office"  xmlns:x="urn:schemas-microsoft-com:office:excel"><o:shapelayout v:ext="edit"><o:idmap v:ext="edit" data="1"/></o:shapelayout>'.
    ld_2 = '<v:shapetype id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><v:stroke joinstyle="miter"/><v:formulas><v:f eqn="if lineDrawn pixelLineWidth 0"/>'.
    ld_3 = '<v:f eqn="sum @0 1 0"/><v:f eqn="sum 0 0 @1"/><v:f eqn="prod @2 1 2"/><v:f eqn="prod @3 21600 pixelWidth"/><v:f eqn="prod @3 21600 pixelHeight"/><v:f eqn="sum @0 0 1"/><v:f eqn="prod @6 1 2"/><v:f eqn="prod @7 21600 pixelWidth"/>'.
    ld_4 = '<v:f eqn="sum @8 21600 0"/><v:f eqn="prod @7 21600 pixelHeight"/><v:f eqn="sum @10 21600 0"/></v:formulas><v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/><o:lock v:ext="edit" aspectratio="t"/></v:shapetype>'.


    CONCATENATE ld_1
                ld_2
                ld_3
                ld_4
         INTO ep_content.

    lv_relation_id = 0.
    lo_iterator = me->excel->get_worksheets_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).

      lo_worksheet->sheet_setup->get_header_footer( IMPORTING ep_odd_header = ls_odd_header
                                                              ep_odd_footer = ls_odd_footer
                                                              ep_even_header = ls_even_header
                                                              ep_even_footer = ls_even_footer ).

      ld_5 = me->set_vml_shape_header( ls_odd_header ).
      CONCATENATE ep_content
                  ld_5
             INTO ep_content.
      ld_5 = me->set_vml_shape_header( ls_even_header ).
      CONCATENATE ep_content
                  ld_5
             INTO ep_content.
      ld_5 = me->set_vml_shape_footer( ls_odd_footer ).
      CONCATENATE ep_content
                  ld_5
             INTO ep_content.
      ld_5 = me->set_vml_shape_footer( ls_even_footer ).
      CONCATENATE ep_content
                  ld_5
             INTO ep_content.
    ENDWHILE.

    ld_7 = '</xml>'.

    CONCATENATE ep_content
                ld_7
           INTO ep_content.

  ENDMETHOD.
  METHOD Lif_excel_writer~write_file.
    me->excel = io_excel.

    ep_file = me->create( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_WRITER_2007 implementation

*>>>>>>> LCL_EXCEL_WRITER_HUGE_FILE <<<<<<<*

*"* macro definitions
*include Lcl_excel_writer_huge_file====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_writer_huge_file====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_WRITER_HUGE_FILE implementation.
*"* method's implementations
*include methods.
  METHOD create_xl_sharedstrings.
*
* Redefinition using simple transformation instead of CL_IXML
*
** Constant node name

    TYPES:
      BEGIN OF ts_root,
        count        TYPE string,
        unique_count TYPE string,
      END OF ts_root.

    DATA:
      lo_iterator  TYPE REF TO Lcl_excel_collection_iterator,
      lo_worksheet TYPE REF TO Lcl_excel_worksheet.

    DATA:
      ls_root           TYPE ts_root,
      lt_cell_data      TYPE zexcel_t_cell_data_unsorted,
      ls_shared_string  TYPE zexcel_s_shared_string,
      lv_sytabix        TYPE i,
      lt_shared_strings TYPE TABLE OF zexcel_s_shared_string.

    FIELD-SYMBOLS:
      <sheet_content>     TYPE zexcel_s_cell_data.

**********************************************************************
* STEP 1: Collect strings from each worksheet

    lo_iterator = excel->get_worksheets_iterator( ).

    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).
      APPEND LINES OF lo_worksheet->sheet_content TO lt_cell_data.
    ENDWHILE.

    DELETE lt_cell_data WHERE cell_formula IS NOT INITIAL " delete formula content
                           OR data_type    NE 's'.        " MvC: Only shared strings

    ls_root-count = lines( lt_cell_data ).
    CONDENSE ls_root-count.

    SORT lt_cell_data BY cell_value data_type.
    DELETE ADJACENT DUPLICATES FROM lt_cell_data COMPARING cell_value data_type.

    ls_root-unique_count = lines( lt_cell_data ).
    CONDENSE ls_root-unique_count.

    LOOP AT lt_cell_data ASSIGNING <sheet_content>.

      lv_sytabix = sy-tabix - 1.
      ls_shared_string-string_no = lv_sytabix.
      ls_shared_string-string_value = <sheet_content>-cell_value.
      INSERT ls_shared_string INTO TABLE shared_strings.

    ENDLOOP.

**********************************************************************
* STEP 2: Create XML

    " Escape the string values, use of standard table in order to keep same sort order as in sorted table SHARED_STRINGS.
    CLEAR lt_shared_strings.
    LOOP AT shared_strings INTO ls_shared_string.
      ls_shared_string-string_value = escape_string_value( ls_shared_string-string_value ).
      APPEND ls_shared_string TO lt_shared_strings.
    ENDLOOP.

    CALL TRANSFORMATION ZSHRINKER_DEMO_ABAP2XLSX_TR_S1
      SOURCE root = ls_root
             shared_strings = lt_shared_strings
      OPTIONS xml_header = 'full'
      RESULT XML ep_content.


  ENDMETHOD.
  METHOD create_xl_sheet.
*
* Build Sheet#.xml with Simple Transformation ZSHRINKER_DEMO_ABAP2XLSX_TR_S2
*
* This is an adaption of LCL_EXCEL_WRITER_2007.
* Not all features are supported, notably the autofilter settings,
* conditional formatting and sheet protection.
*
* Bug reports to marcus.voncube AT deutschebahn.com
*
    TYPES:
      lty_bool TYPE c LENGTH 5.

    CONSTANTS:
      lc_true              TYPE lty_bool   VALUE 'true',
      lc_zero              TYPE c LENGTH 1 VALUE '0',
      lc_one               TYPE c LENGTH 1 VALUE '1',
      lc_default_col_width TYPE f      VALUE '9.10'.

    TYPES:
      BEGIN OF lty_column,
        min          TYPE i,
        max          TYPE i,
        width        TYPE f,
        hidden       TYPE lty_bool,
        customwidth  TYPE lty_bool,
        bestfit      TYPE lty_bool,
        collapsed    TYPE lty_bool,
        outlinelevel TYPE i,
        style        TYPE i,
      END OF lty_column,

      BEGIN OF lty_row,
        row          TYPE i,
        index        TYPE i,
        spans        TYPE c LENGTH 11,  "12345:12345"
        hidden       TYPE lty_bool,
        customheight TYPE lty_bool,
        height       TYPE f,
        collapsed    TYPE lty_bool,
        outlinelevel TYPE i,
        customformat TYPE lty_bool,
        style        TYPE i,
      END OF lty_row,

      BEGIN OF lty_mergecell,
        ref TYPE c LENGTH 21, "AAA1234567:BBB1234567"
      END OF lty_mergecell,

      BEGIN OF lty_hyperlink,
        ref      TYPE string,
        location TYPE string,
        r_id     TYPE string,
      END OF lty_hyperlink,

      BEGIN OF lty_table,
        r_id TYPE string,
      END OF lty_table,

      BEGIN OF lty_table_area,
        left   TYPE i,
        right  TYPE i,
        top    TYPE i,
        bottom TYPE i,
      END OF lty_table_area,

      BEGIN OF ty_missing_columns,
        first_column TYPE zexcel_cell_column,
        last_column  TYPE zexcel_cell_column,
      END OF ty_missing_columns.

*
* Root node for transformation
*
    DATA:
      BEGIN OF l_worksheet,
        dimension          TYPE string,
        tabcolor           TYPE string,
        summarybelow       TYPE c,
        summaryright       TYPE c,
        fittopage          TYPE c,
        showzeros          TYPE c,
        tabselected        TYPE c,
        zoomscale          TYPE i,
        zoomscalenormal    TYPE i,
        zoomscalepageview  TYPE i,
        zoomscalesheetview TYPE i,
        righttoleft        TYPE i,
        workbookviewid     TYPE c,
        showgridlines      TYPE c,
        showrowcolheaders  TYPE c,
        activepane         TYPE string,
        state              TYPE string,
        ysplit             TYPE i,
        xsplit             TYPE i,
        topleftcell        TYPE c LENGTH 10,
        activecell         TYPE c LENGTH 10,
        customheight       TYPE lty_bool,
        defaultrowheight   TYPE f,
        defaultcolwidth    TYPE f,
        outlinelevelrow    TYPE i,
        outlinelevelcol    TYPE i,
        cols               TYPE STANDARD TABLE OF lty_column,
        rows               TYPE STANDARD TABLE OF lty_row,
        mergecells_count   TYPE i,
        mergecells         TYPE STANDARD TABLE OF lty_mergecell,
        hyperlinks_count   TYPE i,
        hyperlinks         TYPE STANDARD TABLE OF lty_hyperlink,
        BEGIN OF printoptions,
          gridlines          TYPE lty_bool,
          horizontalcentered TYPE lty_bool,
          verticalcentered   TYPE lty_bool,
        END OF printoptions,
        BEGIN OF pagemargins,
          left   TYPE zexcel_dec_8_2,
          right  TYPE zexcel_dec_8_2,
          top    TYPE zexcel_dec_8_2,
          bottom TYPE zexcel_dec_8_2,
          header TYPE zexcel_dec_8_2,
          footer TYPE zexcel_dec_8_2,
        END OF pagemargins,
        BEGIN OF pagesetup,
          blackandwhite      TYPE c,
          cellcomments       TYPE string,
          copies             TYPE i,
          draft              TYPE c,
          errors             TYPE string,
          firstpagenumber    TYPE i,
          fittoheight        TYPE i,
          fittowidth         TYPE i,
          horizontaldpi      TYPE i,
          orientation        TYPE string,
          pageorder          TYPE string,
          paperheight        TYPE string,
          papersize          TYPE i,
          paperwidth         TYPE string,
          scale              TYPE i,
          usefirstpagenumber TYPE c,
          useprinterdefaults TYPE c,
          verticaldpi        TYPE i,
        END OF pagesetup,
        BEGIN OF headerfooter,
          differentoddeven TYPE c,
          oddheader        TYPE string,
          oddfooter        TYPE string,
          evenheader       TYPE string,
          evenfooter       TYPE string,
        END OF headerfooter,
        drawings           TYPE string,
        tables_count       TYPE i,
        tables             TYPE STANDARD TABLE OF lty_table,
      END OF l_worksheet.

*
* Local data
*
    DATA:
      lo_iterator                 TYPE REF TO Lcl_excel_collection_iterator,
      lo_table                    TYPE REF TO Lcl_excel_table,
      lo_column_default           TYPE REF TO Lcl_excel_column,
      lo_row_default              TYPE REF TO Lcl_excel_row,
      lv_value                    TYPE string,
      lv_index                    TYPE i,
      lv_spans                    TYPE string,
      lt_range_merge              TYPE string_table,
      lv_column                   TYPE zexcel_cell_column,
      lv_style_guid               TYPE zexcel_cell_style,
      ls_last_row                 TYPE zexcel_s_cell_data,
      lv_freeze_cell_row          TYPE zexcel_cell_row,
      lv_freeze_cell_column       TYPE zexcel_cell_column,
      lv_freeze_cell_column_alpha TYPE zexcel_cell_column_alpha,
      lo_column_iterator          TYPE REF TO Lcl_excel_collection_iterator,
      lo_column                   TYPE REF TO Lcl_excel_column,
      lo_row_iterator             TYPE REF TO Lcl_excel_collection_iterator,
      lo_row                      TYPE REF TO Lcl_excel_row,
      lv_relation_id              TYPE i VALUE 0,
      outline_level_row           TYPE i VALUE 0,
      outline_level_col           TYPE i VALUE 0,
      col_count                   TYPE int4,
      lt_table_areas              TYPE SORTED TABLE OF lty_table_area
                                       WITH NON-UNIQUE KEY left right top bottom,
      ls_table_area               LIKE LINE OF lt_table_areas,
      lts_sorted_columns          TYPE SORTED TABLE OF zexcel_cell_column
                                       WITH UNIQUE KEY table_line,
      t_missing_columns           TYPE STANDARD TABLE OF ty_missing_columns
                                       WITH NON-UNIQUE DEFAULT KEY,
      missing_column              LIKE LINE OF t_missing_columns,
      lo_link                     TYPE REF TO Lcl_excel_hyperlink,
      lo_drawings                 TYPE REF TO Lcl_excel_drawings.

    FIELD-SYMBOLS:
      <sheet_content> TYPE zexcel_s_cell_data,
      <range_merge>   LIKE LINE OF lt_range_merge,
      <col>           TYPE lty_column,
      <row>           TYPE lty_row,
      <hyperlink>     TYPE lty_hyperlink,
      <mergecell>     TYPE lty_mergecell,
      <table>         TYPE lty_table.

**********************************************************************
* STEP 1: Fill root node
*
    l_worksheet-tabcolor      = io_worksheet->tabcolor-rgb.
    l_worksheet-summarybelow  = io_worksheet->Lif_excel_sheet_properties~summarybelow.
    l_worksheet-summaryright  = io_worksheet->Lif_excel_sheet_properties~summaryright.

    IF io_worksheet->sheet_setup->fit_to_page IS NOT INITIAL.
      l_worksheet-fittopage   = lc_one.
    ENDIF.

    l_worksheet-dimension     = io_worksheet->get_dimension_range( ).

    IF io_worksheet->Lif_excel_sheet_properties~show_zeros EQ abap_true.
      l_worksheet-showzeros   = lc_one.
    ELSE.
      l_worksheet-showzeros   = lc_zero.
    ENDIF.

    IF iv_active = abap_true
      OR io_worksheet->Lif_excel_sheet_properties~selected EQ abap_true.
      l_worksheet-tabselected = lc_one.
    ELSE.
      l_worksheet-tabselected = lc_zero.
    ENDIF.

    IF io_worksheet->Lif_excel_sheet_properties~zoomscale GT 400.
      io_worksheet->Lif_excel_sheet_properties~zoomscale = 400.
    ELSEIF io_worksheet->Lif_excel_sheet_properties~zoomscale LT 10.
      io_worksheet->Lif_excel_sheet_properties~zoomscale = 10.
    ENDIF.
    l_worksheet-zoomscale = io_worksheet->Lif_excel_sheet_properties~zoomscale.

    IF io_worksheet->Lif_excel_sheet_properties~zoomscale_normal NE 0.
      IF io_worksheet->Lif_excel_sheet_properties~zoomscale_normal GT 400.
        io_worksheet->Lif_excel_sheet_properties~zoomscale_normal = 400.
      ELSEIF io_worksheet->Lif_excel_sheet_properties~zoomscale_normal LT 10.
        io_worksheet->Lif_excel_sheet_properties~zoomscale_normal = 10.
      ENDIF.
      l_worksheet-zoomscalenormal = io_worksheet->Lif_excel_sheet_properties~zoomscale_normal.
    ENDIF.

    IF io_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview NE 0.
      IF io_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview GT 400.
        io_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview = 400.
      ELSEIF io_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview LT 10.
        io_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview = 10.
      ENDIF.
      l_worksheet-zoomscalepageview = io_worksheet->Lif_excel_sheet_properties~zoomscale_pagelayoutview.
    ENDIF.

    IF io_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview NE 0.
      IF io_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview GT 400.
        io_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview = 400.
      ELSEIF io_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview LT 10.
        io_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview = 10.
      ENDIF.
      l_worksheet-zoomscalesheetview = io_worksheet->Lif_excel_sheet_properties~zoomscale_sheetlayoutview.
    ENDIF.

    IF io_worksheet->Lif_excel_sheet_properties~get_right_to_left( ) EQ abap_true.
      l_worksheet-righttoleft = lc_one.
    ELSE.
      l_worksheet-righttoleft = lc_zero.
    ENDIF.

    l_worksheet-workbookviewid = lc_zero.

    IF io_worksheet->show_gridlines = abap_true.
      l_worksheet-showgridlines = lc_one.
    ELSE.
      l_worksheet-showgridlines = lc_zero.
    ENDIF.

    IF io_worksheet->show_rowcolheaders = abap_true.
      l_worksheet-showrowcolheaders = lc_one.
    ELSE.
      l_worksheet-showrowcolheaders = lc_zero.
    ENDIF.

*
* Freeze
*
    io_worksheet->get_freeze_cell(
      IMPORTING ep_row    = lv_freeze_cell_row
                ep_column = lv_freeze_cell_column ).

    IF lv_freeze_cell_row IS NOT INITIAL AND lv_freeze_cell_column IS NOT INITIAL.
      IF lv_freeze_cell_row > 1.
        l_worksheet-ysplit = lv_freeze_cell_row - 1.
      ENDIF.

      IF lv_freeze_cell_column > 1.
        lv_value = lv_freeze_cell_column - 1.
        l_worksheet-xsplit = lv_freeze_cell_column - 1.
      ENDIF.

      lv_freeze_cell_column_alpha = Lcl_excel_common=>convert_column2alpha( ip_column = lv_freeze_cell_column ).
      lv_value = Lcl_excel_common=>number_to_excel_string( ip_value = lv_freeze_cell_row  ).
      CONCATENATE lv_freeze_cell_column_alpha lv_value INTO lv_value.
      l_worksheet-topleftcell = lv_value.

      l_worksheet-activepane = 'bottomRight'.
      l_worksheet-state      = 'frozen'.
    ENDIF.

    l_worksheet-activecell = io_worksheet->get_active_cell( ).

*
* Row and column info
*
    lo_column_iterator = io_worksheet->get_columns_iterator( ).
    IF NOT lo_column_iterator IS BOUND.
      io_worksheet->calculate_column_widths( ).
      lo_column_iterator = io_worksheet->get_columns_iterator( ).
    ENDIF.

    lo_column_default = io_worksheet->get_default_column( ).
    IF lo_column_default IS BOUND AND lo_column_default->get_width( ) >= 0.
      l_worksheet-defaultcolwidth = lo_column_default->get_width( ).
    ENDIF.

    lo_row_default = io_worksheet->get_default_row( ).
    IF lo_row_default IS BOUND.
      IF lo_row_default->get_row_height( ) >= 0.
        l_worksheet-customheight = lc_true.
        lv_value = lo_row_default->get_row_height( ).
      ELSE.
        lv_value = '12.75'.
      ENDIF.
    ELSE.
      lv_value = '12.75'.
    ENDIF.
    CONDENSE lv_value.
    l_worksheet-defaultrowheight = lv_value.

    lo_row_iterator = io_worksheet->get_rows_iterator( ).
    WHILE lo_row_iterator->has_next( ) = abap_true.
      lo_row ?= lo_row_iterator->get_next( ).
      IF lo_row->get_outline_level( ) > outline_level_row.
        l_worksheet-outlinelevelrow = lo_row->get_outline_level( ).
      ENDIF.
    ENDWHILE.

* Set column information (width, style, ...)
    WHILE lo_column_iterator->has_next( ) = abap_true.
      lo_column ?= lo_column_iterator->get_next( ).
      IF lo_column->get_outline_level( ) > outline_level_col.
        l_worksheet-outlinelevelcol = lo_column->get_outline_level( ).
      ENDIF.
      APPEND INITIAL LINE TO l_worksheet-cols ASSIGNING <col>.
      <col>-min = <col>-max = lo_column->get_column_index( ).
      <col>-width = lo_column->get_width( ).
      IF <col>-width < 0.
        <col>-width = lc_default_col_width.
      ENDIF.
      IF lo_column->get_visible( ) = abap_false.
        <col>-hidden = lc_true.
      ENDIF.
      IF lo_column->get_auto_size( ) = abap_true.
        <col>-bestfit = lc_true.
      ENDIF.
      IF lo_column_default IS BOUND.
        IF lo_column->get_width( ) <> lo_column_default->get_width( ).
          <col>-customwidth = lc_true.
        ENDIF.
      ELSE.
        <col>-customwidth = lc_true.
      ENDIF.
      IF lo_column->get_collapsed( ) = abap_true.
        <col>-collapsed = lc_true.
      ENDIF.
      <col>-outlinelevel = lo_column->get_outline_level( ).
      lv_style_guid = lo_column->get_column_style_guid( ).
      <col>-style = me->excel->get_style_index_in_styles( lv_style_guid ) - 1.
*
* Missing columns
*
* First collect columns that were already handled before.
* The rest has to be inserted now.
*

      lv_column = Lcl_excel_common=>convert_column2int( lo_column->get_column_index( ) ).
      INSERT lv_column INTO TABLE lts_sorted_columns.
    ENDWHILE.

*
* Now find all columns that were missing so far
*
    missing_column-first_column = 1.

    LOOP AT lts_sorted_columns INTO lv_column.
      IF lv_column > missing_column-first_column.
        missing_column-last_column = lv_column - 1.
        APPEND missing_column TO t_missing_columns.
      ENDIF.
      missing_column-first_column = lv_column + 1.
    ENDLOOP.

    missing_column-last_column = Lcl_excel_common=>c_excel_sheet_max_col.
    APPEND missing_column TO t_missing_columns.

*
* Now apply stylesetting and other defaults
*
    LOOP AT t_missing_columns INTO missing_column.
      APPEND INITIAL LINE TO l_worksheet-cols ASSIGNING <col>.
      <col>-min = missing_column-first_column.
      <col>-max = missing_column-last_column.
      IF lo_column_default IS BOUND AND lo_column_default->get_width( ) >= 0.
        <col>-width = lo_column_default->get_width( ).
      ELSE.
        <col>-width = lc_default_col_width.
      ENDIF.
      lv_style_guid = io_worksheet->Lif_excel_sheet_properties~get_style( ).
      <col>-style = me->excel->get_style_index_in_styles( lv_style_guid ) - 1.
    ENDLOOP.

*
* Build table to hold all table-areas attached to this sheet
*
    lo_iterator = io_worksheet->get_tables_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_table ?= lo_iterator->get_next( ).
      ls_table_area-left   = Lcl_excel_common=>convert_column2int( lo_table->settings-top_left_column ).
      ls_table_area-right  = lo_table->get_right_column_integer( ).
      ls_table_area-top    = lo_table->settings-top_left_row.
      ls_table_area-bottom = lo_table->get_bottom_row_integer( ).
      INSERT ls_table_area INTO TABLE lt_table_areas.
    ENDWHILE.

*
* Build sheet data node
*
* Spans is constant amongst all rows
*
    col_count = io_worksheet->get_highest_column( ).
    lv_spans = col_count.
    CONCATENATE '1:' lv_spans INTO lv_spans.
    CONDENSE lv_spans.

    LOOP AT io_worksheet->sheet_content ASSIGNING <sheet_content>.

      IF ls_last_row-cell_row NE <sheet_content>-cell_row.
*
*     Fill row information.
*     Cell data is filled in by callback GET_CELLS called from transformation
*
        lv_index = sy-tabix.
        APPEND INITIAL LINE TO l_worksheet-rows ASSIGNING <row>.
        <row>-row   = <sheet_content>-cell_row.
        <row>-index = lv_index.
        <row>-spans = lv_spans.

*
*     Row dimension attributes
*
        lo_row = io_worksheet->get_row( <sheet_content>-cell_row ).
        IF lo_row->get_visible( ) = abap_false.
          <row>-hidden = lc_true.
        ENDIF.

        IF lo_row->get_row_height( ) >= 0.
          <row>-customheight = lc_one.
          <row>-height       = lo_row->get_row_height( ).
        ENDIF.

*
*     Collapsed
*
        IF lo_row->get_collapsed( ) = abap_true.
          <row>-collapsed = lc_true.
        ENDIF.

*
*     Outline level
*
        <row>-outlinelevel = lo_row->get_outline_level( ).

*
*     Style
*
        <row>-style = lo_row->get_xf_index( ).
        IF <row>-style <> 0.
          <row>-customformat = lc_one.
        ENDIF.
      ENDIF.

      ls_last_row = <sheet_content>.
    ENDLOOP.

*
* Merged cells
*
    lt_range_merge = io_worksheet->get_merge( ).
    IF lt_range_merge IS NOT INITIAL.
      l_worksheet-mergecells_count = lines( lt_range_merge ).

      LOOP AT lt_range_merge ASSIGNING <range_merge>.
        APPEND INITIAL LINE TO l_worksheet-mergecells ASSIGNING <mergecell>.
        <mergecell>-ref = <range_merge>.
        io_worksheet->delete_merge( ).
      ENDLOOP.
    ENDIF.

*
* Hyperlinks
*
    l_worksheet-hyperlinks_count = io_worksheet->get_hyperlinks_size( ).
    IF l_worksheet-hyperlinks_count > 0.
      lo_iterator = io_worksheet->get_hyperlinks_iterator( ).
      WHILE lo_iterator->has_next( ) EQ abap_true.
        lo_link ?= lo_iterator->get_next( ).

        APPEND INITIAL LINE TO l_worksheet-hyperlinks ASSIGNING <hyperlink>.
        <hyperlink>-ref = lo_link->get_ref( ).
        IF lo_link->is_internal( ) = abap_true.
          <hyperlink>-location = lo_link->get_url( ).
        ELSE.
          ADD 1 TO lv_relation_id.
          lv_value = lv_relation_id.
          CONDENSE lv_value.
          CONCATENATE 'rId' lv_value INTO lv_value.
          <hyperlink>-r_id = lv_value.
        ENDIF.
      ENDWHILE.
    ENDIF.

*
* Print options
*
    IF io_worksheet->print_gridlines = abap_true.
      l_worksheet-printoptions-gridlines = lc_true.
    ENDIF.

    IF io_worksheet->sheet_setup->horizontal_centered = abap_true.
      l_worksheet-printoptions-horizontalcentered = lc_true.
    ENDIF.

    IF io_worksheet->sheet_setup->vertical_centered = abap_true.
      l_worksheet-printoptions-verticalcentered = lc_true.
    ENDIF.

*
* Page margins
*
    l_worksheet-pagemargins-left   = io_worksheet->sheet_setup->margin_left.
    l_worksheet-pagemargins-right  = io_worksheet->sheet_setup->margin_right.
    l_worksheet-pagemargins-top    = io_worksheet->sheet_setup->margin_top.
    l_worksheet-pagemargins-bottom = io_worksheet->sheet_setup->margin_bottom.
    l_worksheet-pagemargins-header = io_worksheet->sheet_setup->margin_header.
    l_worksheet-pagemargins-footer = io_worksheet->sheet_setup->margin_footer.

*
* Page setup
*
    l_worksheet-pagesetup-cellcomments       = io_worksheet->sheet_setup->cell_comments.
    l_worksheet-pagesetup-copies             = io_worksheet->sheet_setup->copies.
    l_worksheet-pagesetup-firstpagenumber    = io_worksheet->sheet_setup->first_page_number.
    l_worksheet-pagesetup-fittoheight        = io_worksheet->sheet_setup->fit_to_height.
    l_worksheet-pagesetup-fittowidth         = io_worksheet->sheet_setup->fit_to_width.
    l_worksheet-pagesetup-horizontaldpi      = io_worksheet->sheet_setup->horizontal_dpi.
    l_worksheet-pagesetup-orientation        = io_worksheet->sheet_setup->orientation.
    l_worksheet-pagesetup-pageorder          = io_worksheet->sheet_setup->page_order.
    l_worksheet-pagesetup-paperheight        = io_worksheet->sheet_setup->paper_height.
    l_worksheet-pagesetup-papersize          = io_worksheet->sheet_setup->paper_size.
    l_worksheet-pagesetup-paperwidth         = io_worksheet->sheet_setup->paper_width.
    l_worksheet-pagesetup-scale              = io_worksheet->sheet_setup->scale.
    l_worksheet-pagesetup-usefirstpagenumber = io_worksheet->sheet_setup->use_first_page_num.
    l_worksheet-pagesetup-verticaldpi        = io_worksheet->sheet_setup->vertical_dpi.

    IF io_worksheet->sheet_setup->black_and_white IS NOT INITIAL.
      l_worksheet-pagesetup-blackandwhite = lc_one.
    ENDIF.

    IF io_worksheet->sheet_setup->draft IS NOT INITIAL.
      l_worksheet-pagesetup-draft = lc_one.
    ENDIF.

    IF io_worksheet->sheet_setup->errors IS NOT INITIAL.
      l_worksheet-pagesetup-errors = io_worksheet->sheet_setup->errors.
    ENDIF.

    IF io_worksheet->sheet_setup->use_printer_defaults IS NOT INITIAL.
      l_worksheet-pagesetup-useprinterdefaults = lc_one.
    ENDIF.

*
* Header and footer
*
    IF io_worksheet->sheet_setup->diff_oddeven_headerfooter = abap_true.
      l_worksheet-headerfooter-differentoddeven = lc_one.
    ENDIF.

    io_worksheet->sheet_setup->get_header_footer_string(
      IMPORTING
        ep_odd_header  = l_worksheet-headerfooter-oddheader
        ep_odd_footer  = l_worksheet-headerfooter-oddfooter
        ep_even_header = l_worksheet-headerfooter-evenheader
        ep_even_footer = l_worksheet-headerfooter-evenfooter ).

*
* Drawings
*
    lo_drawings = io_worksheet->get_drawings( ).
    IF lo_drawings->is_empty( ) = abap_false.
      ADD 1 TO lv_relation_id.
      lv_value = lv_relation_id.
      CONDENSE lv_value.
      CONCATENATE 'rId' lv_value INTO l_worksheet-drawings.
    ENDIF.

*
* Tables
*
    l_worksheet-tables_count = io_worksheet->get_tables_size( ).
    IF l_worksheet-tables_count > 0.
      lo_iterator = io_worksheet->get_tables_iterator( ).
      WHILE lo_iterator->has_next( ) EQ abap_true.
        lo_table ?= lo_iterator->get_next( ).
        APPEND INITIAL LINE TO l_worksheet-tables ASSIGNING <table>.
        ADD 1 TO lv_relation_id.
        lv_value = lv_relation_id.
        CONDENSE lv_value.
        CONCATENATE 'rId' lv_value INTO <table>-r_id.
      ENDWHILE.
    ENDIF.

**********************************************************************
* STEP 2: Create XML

    me->worksheet = io_worksheet. "Neccessary for callback GET_CELL

    CALL TRANSFORMATION ZSHRINKER_DEMO_ABAP2XLSX_TR_S2
      SOURCE worksheet = l_worksheet
             cells     = me->cells
             writer    = me
      OPTIONS xml_header = 'full'
      RESULT XML ep_content.

  ENDMETHOD.                    "CREATE_XL_SHEET
  METHOD get_cells.
*
* Callback method from transformation ZSHRINKER_DEMO_ABAP2XLSX_TR_S2
*
* The method fills the data cells for each row.
* This saves memory if there are many rows.
*
    DATA:
      lv_cell_style TYPE zexcel_cell_style.

    FIELD-SYMBOLS:
      <cell>    TYPE ty_cell,
      <content> TYPE zexcel_s_cell_data,
      <style>   TYPE zexcel_s_styles_mapping.

    CLEAR cells.

    LOOP AT worksheet->sheet_content FROM i_index ASSIGNING <content>.
      IF <content>-cell_row <> i_row.
*
*     End of row
*
        EXIT.
      ENDIF.

*
*   Determine style index
*
      IF lv_cell_style <> <content>-cell_style.
        lv_cell_style = <content>-cell_style.
        UNASSIGN <style>.
        IF lv_cell_style IS NOT INITIAL.
          READ TABLE styles_mapping ASSIGNING <style> WITH KEY guid = lv_cell_style.
        ENDIF.
      ENDIF.
*
*   Add a new cell
*
      APPEND INITIAL LINE TO cells ASSIGNING <cell>.
      <cell>-name    = <content>-cell_coords.
      <cell>-formula = <content>-cell_formula.
      <cell>-type    = <content>-data_type.
      IF <cell>-type = 's'.
        <cell>-value = me->get_shared_string_index( ip_cell_value = <content>-cell_value ).
      ELSE.
        <cell>-value = <content>-cell_value.
      ENDIF.
      IF <style> IS ASSIGNED.
        <cell>-style = <style>-style.
      ELSE.
        <cell>-style = -1.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
endclass. "LCL_EXCEL_WRITER_HUGE_FILE implementation

*>>>>>>> LCL_EXCEL_WRITER_XLSM <<<<<<<*

*"* macro definitions
*include Lcl_excel_writer_xlsm=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_writer_xlsm=========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_WRITER_XLSM implementation.
*"* method's implementations
*include methods.
  METHOD add_further_data_to_zip.

    super->add_further_data_to_zip( io_zip = io_zip ).

* Add vbaProject.bin to zip
    io_zip->add( name    = me->c_xl_vbaproject
                 content = me->excel->Lif_excel_book_vba_project~vbaproject ).

  ENDMETHOD.
  METHOD create.


* Office 2007 file format is a cab of several xml files with extension .xlsx

    DATA: lo_zip              TYPE REF TO cl_abap_zip,
          lo_worksheet        TYPE REF TO Lcl_excel_worksheet,
          lo_active_worksheet TYPE REF TO Lcl_excel_worksheet,
          lo_iterator         TYPE REF TO Lcl_excel_collection_iterator,
          lo_nested_iterator  TYPE REF TO Lcl_excel_collection_iterator,
          lo_table            TYPE REF TO Lcl_excel_table,
          lo_drawing          TYPE REF TO Lcl_excel_drawing,
          lo_drawings         TYPE REF TO Lcl_excel_drawings.

    DATA: lv_content         TYPE xstring,
          lv_active          TYPE flag,
          lv_xl_sheet        TYPE string,
          lv_xl_sheet_rels   TYPE string,
          lv_xl_drawing      TYPE string,
          lv_xl_drawing_rels TYPE string,
          lv_syindex         TYPE string,
          lv_value           TYPE string,
          lv_drawing_index   TYPE i,
          lv_comment_index   TYPE i. " (+) Issue 588

**********************************************************************
* Start of insertion # issue 139 - Dateretention of cellstyles
    me->excel->add_static_styles( ).
* End of insertion # issue 139 - Dateretention of cellstyles

**********************************************************************
* STEP 1: Create archive object file (ZIP)
    CREATE OBJECT lo_zip.

**********************************************************************
* STEP 2: Add [Content_Types].xml to zip
    lv_content = me->create_content_types( ).
    lo_zip->add( name    = me->c_content_types
                 content = lv_content ).

**********************************************************************
* STEP 3: Add _rels/.rels to zip
    lv_content = me->create_relationships( ).
    lo_zip->add( name    = me->c_relationships
                 content = lv_content ).

**********************************************************************
* STEP 4: Add docProps/app.xml to zip
    lv_content = me->create_docprops_app( ).
    lo_zip->add( name    = me->c_docprops_app
                 content = lv_content ).

**********************************************************************
* STEP 5: Add docProps/core.xml to zip
    lv_content = me->create_docprops_core( ).
    lo_zip->add( name    = me->c_docprops_core
                 content = lv_content ).

**********************************************************************
* STEP 6: Add xl/_rels/workbook.xml.rels to zip
    lv_content = me->create_xl_relationships( ).
    lo_zip->add( name    = me->c_xl_relationships
                 content = lv_content ).

**********************************************************************
* STEP 6: Add xl/_rels/workbook.xml.rels to zip
    lv_content = me->create_xl_theme( ).
    lo_zip->add( name    = me->c_xl_theme
                 content = lv_content ).

**********************************************************************
* STEP 7: Add xl/workbook.xml to zip
    lv_content = me->create_xl_workbook( ).
    lo_zip->add( name    = me->c_xl_workbook
                 content = lv_content ).

**********************************************************************
* STEP 8: Add xl/workbook.xml to zip
    lv_content = me->create_xl_styles( ).
    lo_zip->add( name    = me->c_xl_styles
                 content = lv_content ).

**********************************************************************
* STEP 9: Add sharedStrings.xml to zip
    lv_content = me->create_xl_sharedstrings( ).
    lo_zip->add( name    = me->c_xl_sharedstrings
                 content = lv_content ).

**********************************************************************
* STEP 10: Add sheet#.xml and drawing#.xml to zip
    lo_iterator = me->excel->get_worksheets_iterator( ).
    lo_active_worksheet = me->excel->get_active_worksheet( ).
    lv_drawing_index = 1.

    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).
      IF lo_active_worksheet->get_guid( ) EQ lo_worksheet->get_guid( ).
        lv_active = abap_true.
      ELSE.
        lv_active = abap_false.
      ENDIF.

      lv_content = me->create_xl_sheet( io_worksheet = lo_worksheet
                                        iv_active    = lv_active ).
      lv_xl_sheet = me->c_xl_sheet.
      lv_syindex = sy-index.
      lv_comment_index = sy-index. " (+) Issue 588
      SHIFT lv_syindex RIGHT DELETING TRAILING space.
      SHIFT lv_syindex LEFT DELETING LEADING space.
      REPLACE ALL OCCURRENCES OF '#' IN lv_xl_sheet WITH lv_syindex.
      lo_zip->add( name    = lv_xl_sheet
                   content = lv_content ).

      lv_xl_sheet_rels = me->c_xl_sheet_rels.
      lv_content = me->create_xl_sheet_rels( io_worksheet = lo_worksheet
                                             iv_drawing_index = lv_drawing_index
                                             iv_comment_index = lv_comment_index ). " (+) Issue 588
      REPLACE ALL OCCURRENCES OF '#' IN lv_xl_sheet_rels WITH lv_syindex.
      lo_zip->add( name    = lv_xl_sheet_rels
                   content = lv_content ).

      lo_nested_iterator = lo_worksheet->get_tables_iterator( ).

      WHILE lo_nested_iterator->has_next( ) EQ abap_true.
        lo_table ?= lo_nested_iterator->get_next( ).
        lv_content = me->create_xl_table( lo_table ).

        lv_value = lo_table->get_name( ).
        CONCATENATE 'xl/tables/' lv_value '.xml' INTO lv_value.
        lo_zip->add( name = lv_value
                      content = lv_content ).
      ENDWHILE.

* Add drawings **********************************
      lo_drawings = lo_worksheet->get_drawings( ).
      IF lo_drawings->is_empty( ) = abap_false.
        lv_syindex = lv_drawing_index.
        SHIFT lv_syindex RIGHT DELETING TRAILING space.
        SHIFT lv_syindex LEFT DELETING LEADING space.

        lv_content = me->create_xl_drawings( lo_worksheet ).
        lv_xl_drawing = me->c_xl_drawings.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_drawing WITH lv_syindex.
        lo_zip->add( name    = lv_xl_drawing
                     content = lv_content ).

        lv_content = me->create_xl_drawings_rels( lo_worksheet ).
        lv_xl_drawing_rels = me->c_xl_drawings_rels.
        REPLACE ALL OCCURRENCES OF '#' IN lv_xl_drawing_rels WITH lv_syindex.
        lo_zip->add( name    = lv_xl_drawing_rels
                     content = lv_content ).
        ADD 1 TO lv_drawing_index.
      ENDIF.
    ENDWHILE.

**********************************************************************
* STEP 11: Add media
    lo_iterator = me->excel->get_drawings_iterator( Lcl_excel_drawing=>type_image ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_drawing ?= lo_iterator->get_next( ).

      lv_content = lo_drawing->get_media( ).
      lv_value = lo_drawing->get_media_name( ).
      CONCATENATE 'xl/media/' lv_value INTO lv_value.
      lo_zip->add( name    = lv_value
                   content = lv_content ).
    ENDWHILE.

**********************************************************************
* STEP 12: Add charts
    lo_iterator = me->excel->get_drawings_iterator( Lcl_excel_drawing=>type_chart ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_drawing ?= lo_iterator->get_next( ).

      lv_content = lo_drawing->get_media( ).
      lv_value = lo_drawing->get_media_name( ).
      CONCATENATE 'xl/charts/' lv_value INTO lv_value.
      lo_zip->add( name    = lv_value
                   content = lv_content ).
    ENDWHILE.

**********************************************************************
* STEP 9: Add vbaProject.bin to zip
    lo_zip->add( name    = me->c_xl_vbaproject
                 content = me->excel->Lif_excel_book_vba_project~vbaproject ).

**********************************************************************
* STEP 12: Create the final zip
    ep_excel = lo_zip->save( ).

  ENDMETHOD.
  METHOD create_content_types.
** Constant node name
    DATA: lc_xml_node_workb_ct    TYPE string VALUE 'application/vnd.ms-excel.sheet.macroEnabled.main+xml',
          lc_xml_node_default     TYPE string VALUE 'Default',
          " Node attributes
          lc_xml_attr_partname    TYPE string VALUE 'PartName',
          lc_xml_attr_extension   TYPE string VALUE 'Extension',
          lc_xml_attr_contenttype TYPE string VALUE 'ContentType',
          lc_xml_node_workb_pn    TYPE string VALUE '/xl/workbook.xml',
          lc_xml_node_bin_ext     TYPE string VALUE 'bin',
          lc_xml_node_bin_ct      TYPE string VALUE 'application/vnd.ms-office.vbaProject'.


    DATA: lo_ixml          TYPE REF TO if_ixml,
          lo_document      TYPE REF TO if_ixml_document,
          lo_document_xml  TYPE REF TO cl_xml_document,
          lo_element_root  TYPE REF TO if_ixml_node,
          lo_element       TYPE REF TO if_ixml_element,
          lo_collection    TYPE REF TO if_ixml_node_collection,
          lo_iterator      TYPE REF TO if_ixml_node_iterator,
          lo_streamfactory TYPE REF TO if_ixml_stream_factory,
          lo_ostream       TYPE REF TO if_ixml_ostream,
          lo_renderer      TYPE REF TO if_ixml_renderer.

    DATA: lv_subrc       TYPE sysubrc,
          lv_contenttype TYPE string.

**********************************************************************
* STEP 3: Create standard contentType
    ep_content = super->create_content_types( ).

**********************************************************************
* STEP 2: modify XML adding the extension bin definition

    CREATE OBJECT lo_document_xml.
    lv_subrc = lo_document_xml->parse_xstring( ep_content ).

    lo_document ?= lo_document_xml->m_document.
    lo_element_root = lo_document->if_ixml_node~get_first_child( ).

    " extension node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_default
                                                     parent = lo_document ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_extension
                                  value = lc_xml_node_bin_ext ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                  value = lc_xml_node_bin_ct ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 3: modify XML changing the contentType of node Override /xl/workbook.xml

    lo_collection = lo_document->get_elements_by_tag_name( 'Override' ).
    lo_iterator = lo_collection->create_iterator( ).
    lo_element ?= lo_iterator->get_next( ).
    WHILE lo_element IS BOUND.
      lv_contenttype = lo_element->get_attribute_ns( lc_xml_attr_partname ).
      IF lv_contenttype EQ lc_xml_node_workb_pn.
        lo_element->remove_attribute_ns( lc_xml_attr_contenttype ).
        lo_element->set_attribute_ns( name  = lc_xml_attr_contenttype
                                      value = lc_xml_node_workb_ct ).
        EXIT.
      ENDIF.
      lo_element ?= lo_iterator->get_next( ).
    ENDWHILE.

**********************************************************************
* STEP 3: Create xstring stream
    CLEAR ep_content.
    lo_ixml = cl_ixml=>create( ).
    lo_streamfactory = lo_ixml->create_stream_factory( ).
    lo_ostream = lo_streamfactory->create_ostream_xstring( string = ep_content ).
    lo_renderer = lo_ixml->create_renderer( ostream  = lo_ostream document = lo_document ).
    lo_renderer->render( ).

  ENDMETHOD.
  METHOD create_xl_relationships.

** Constant node name
    DATA: lc_xml_node_relationship TYPE string VALUE 'Relationship',
          " Node attributes
          lc_xml_attr_id           TYPE string VALUE 'Id',
          lc_xml_attr_type         TYPE string VALUE 'Type',
          lc_xml_attr_target       TYPE string VALUE 'Target',
          " Node id
          lc_xml_node_ridx_id      TYPE string VALUE 'rId#',
          " Node type
          lc_xml_node_rid_vba_tp   TYPE string VALUE 'http://schemas.microsoft.com/office/2006/relationships/vbaProject',
          " Node target
          lc_xml_node_rid_vba_tg   TYPE string VALUE 'vbaProject.bin'.

    DATA: lo_ixml          TYPE REF TO if_ixml,
          lo_document      TYPE REF TO if_ixml_document,
          lo_document_xml  TYPE REF TO cl_xml_document,
          lo_element_root  TYPE REF TO if_ixml_node,
          lo_element       TYPE REF TO if_ixml_element,
          lo_streamfactory TYPE REF TO if_ixml_stream_factory,
          lo_ostream       TYPE REF TO if_ixml_ostream,
          lo_renderer      TYPE REF TO if_ixml_renderer.

    DATA: lv_xml_node_ridx_id TYPE string,
          lv_size             TYPE i,
          lv_subrc            TYPE sysubrc,
          lv_syindex(2)       TYPE c.

**********************************************************************
* STEP 3: Create standard relationship
    ep_content = super->create_xl_relationships( ).

**********************************************************************
* STEP 2: modify XML adding the vbaProject relation

    CREATE OBJECT lo_document_xml.
    lv_subrc = lo_document_xml->parse_xstring( ep_content ).

    lo_document ?= lo_document_xml->m_document.
    lo_element_root = lo_document->if_ixml_node~get_first_child( ).


    lv_size = excel->get_worksheets_size( ).

    " Relationship node
    lo_element = lo_document->create_simple_element( name   = lc_xml_node_relationship
                                                     parent = lo_document ).
    ADD 4 TO lv_size.
    lv_syindex = lv_size.
    SHIFT lv_syindex RIGHT DELETING TRAILING space.
    SHIFT lv_syindex LEFT DELETING LEADING space.
    lv_xml_node_ridx_id = lc_xml_node_ridx_id.
    REPLACE ALL OCCURRENCES OF '#' IN lv_xml_node_ridx_id WITH lv_syindex.
    lo_element->set_attribute_ns( name  = lc_xml_attr_id
                                  value = lv_xml_node_ridx_id ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_type
                                  value = lc_xml_node_rid_vba_tp ).
    lo_element->set_attribute_ns( name  = lc_xml_attr_target
                                  value = lc_xml_node_rid_vba_tg ).
    lo_element_root->append_child( new_child = lo_element ).

**********************************************************************
* STEP 3: Create xstring stream
    CLEAR ep_content.
    lo_ixml = cl_ixml=>create( ).
    lo_streamfactory = lo_ixml->create_stream_factory( ).
    lo_ostream = lo_streamfactory->create_ostream_xstring( string = ep_content ).
    lo_renderer = lo_ixml->create_renderer( ostream  = lo_ostream document = lo_document ).
    lo_renderer->render( ).

  ENDMETHOD.
  METHOD create_xl_sheet.

** Constant node name
    DATA: lc_xml_attr_codename      TYPE string VALUE 'codeName'.

    DATA: lo_ixml          TYPE REF TO if_ixml,
          lo_document      TYPE REF TO if_ixml_document,
          lo_document_xml  TYPE REF TO cl_xml_document,
          lo_element_root  TYPE REF TO if_ixml_node,
          lo_element       TYPE REF TO if_ixml_element,
          lo_collection    TYPE REF TO if_ixml_node_collection,
          lo_iterator      TYPE REF TO if_ixml_node_iterator,
          lo_streamfactory TYPE REF TO if_ixml_stream_factory,
          lo_ostream       TYPE REF TO if_ixml_ostream,
          lo_renderer      TYPE REF TO if_ixml_renderer.

    DATA: lv_subrc      TYPE sysubrc.

**********************************************************************
* STEP 3: Create standard relationship
    ep_content = super->create_xl_sheet( io_worksheet = io_worksheet
                                         iv_active    = iv_active ).

**********************************************************************
* STEP 2: modify XML adding the vbaProject relation

    CREATE OBJECT lo_document_xml.
    lv_subrc = lo_document_xml->parse_xstring( ep_content ).

    lo_document ?= lo_document_xml->m_document.
    lo_element_root = lo_document->if_ixml_node~get_first_child( ).

    lo_collection = lo_document->get_elements_by_tag_name( 'sheetPr' ).
    lo_iterator = lo_collection->create_iterator( ).
    lo_element ?= lo_iterator->get_next( ).
    WHILE lo_element IS BOUND.
      lo_element->set_attribute_ns( name  = lc_xml_attr_codename
                                    value = io_worksheet->Lif_excel_sheet_vba_project~codename_pr ).
      lo_element ?= lo_iterator->get_next( ).
    ENDWHILE.

**********************************************************************
* STEP 3: Create xstring stream
    CLEAR ep_content.
    lo_ixml = cl_ixml=>create( ).
    lo_streamfactory = lo_ixml->create_stream_factory( ).
    lo_ostream = lo_streamfactory->create_ostream_xstring( string = ep_content ).
    lo_renderer = lo_ixml->create_renderer( ostream  = lo_ostream document = lo_document ).
    lo_renderer->render( ).
  ENDMETHOD.
  METHOD create_xl_workbook.

** Constant node name
    DATA: lc_xml_attr_codename      TYPE string VALUE 'codeName'.

    DATA: lo_ixml          TYPE REF TO if_ixml,
          lo_document      TYPE REF TO if_ixml_document,
          lo_document_xml  TYPE REF TO cl_xml_document,
          lo_element_root  TYPE REF TO if_ixml_node,
          lo_element       TYPE REF TO if_ixml_element,
          lo_collection    TYPE REF TO if_ixml_node_collection,
          lo_iterator      TYPE REF TO if_ixml_node_iterator,
          lo_streamfactory TYPE REF TO if_ixml_stream_factory,
          lo_ostream       TYPE REF TO if_ixml_ostream,
          lo_renderer      TYPE REF TO if_ixml_renderer.

    DATA: lv_subrc      TYPE sysubrc.

**********************************************************************
* STEP 3: Create standard relationship
    ep_content = super->create_xl_workbook( ).

**********************************************************************
* STEP 2: modify XML adding the vbaProject relation

    CREATE OBJECT lo_document_xml.
    lv_subrc = lo_document_xml->parse_xstring( ep_content ).

    lo_document ?= lo_document_xml->m_document.
    lo_element_root = lo_document->if_ixml_node~get_first_child( ).

    lo_collection = lo_document->get_elements_by_tag_name( 'fileVersion' ).
    lo_iterator = lo_collection->create_iterator( ).
    lo_element ?= lo_iterator->get_next( ).
    WHILE lo_element IS BOUND.
      lo_element->set_attribute_ns( name  = lc_xml_attr_codename
                                    value = me->excel->Lif_excel_book_vba_project~codename ).
      lo_element ?= lo_iterator->get_next( ).
    ENDWHILE.

    lo_collection = lo_document->get_elements_by_tag_name( 'workbookPr' ).
    lo_iterator = lo_collection->create_iterator( ).
    lo_element ?= lo_iterator->get_next( ).
    WHILE lo_element IS BOUND.
      lo_element->set_attribute_ns( name  = lc_xml_attr_codename
                                    value = me->excel->Lif_excel_book_vba_project~codename_pr ).
      lo_element ?= lo_iterator->get_next( ).
    ENDWHILE.

**********************************************************************
* STEP 3: Create xstring stream
    CLEAR ep_content.
    lo_ixml = cl_ixml=>create( ).
    lo_streamfactory = lo_ixml->create_stream_factory( ).
    lo_ostream = lo_streamfactory->create_ostream_xstring( string = ep_content ).
    lo_renderer = lo_ixml->create_renderer( ostream  = lo_ostream document = lo_document ).
    lo_renderer->render( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_WRITER_XLSM implementation

*>>>>>>> LCL_EXCEL_OBSOLETE_FUNC_WRAP <<<<<<<*

*"* macro definitions
*include Lcl_excel_obsolete_func_wrap==ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_obsolete_func_wrap==ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_OBSOLETE_FUNC_WRAP implementation.
*"* method's implementations
*include methods.
  METHOD guid_create.

    TRY.
        rv_guid_16 = cl_system_uuid=>if_system_uuid_static~create_uuid_x16( ).
      CATCH cx_uuid_error.
    ENDTRY.

*--------------------------------------------------------------------*
* If you are on a release that does not yet have the class cl_system_uuid
* please use the following coding instead which is using the function
* call that was used before but which has been flagged as obsolete
* in newer SAP releases
*--------------------------------------------------------------------*
*
*Before ABAP 7.02:  CALL FUNCTION 'GUID_CREATE'
*Before ABAP 7.02:    IMPORTING
*Before ABAP 7.02:      ev_guid_16 = rv_guid_16.

  ENDMETHOD.
endclass. "LCL_EXCEL_OBSOLETE_FUNC_WRAP implementation

*>>>>>>> LCL_EXCEL <<<<<<<*

*"* macro definitions
*include Lcl_excel=====================ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel=====================ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


*"* test class
*include Lcl_excel=====================ccau.
*CLASS SHRITEFUH64VYIPN5I4UIDBI77WSE4 DEFINITION DEFERRED.
*CLASS Lcl_excel DEFINITION LOCAL FRIENDS SHRITEFUH64VYIPN5I4UIDBI77WSE4.

*----------------------------------------------------------------------*
*       CLASS SHRITEFUH64VYIPN5I4UIDBI77WSE4 DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*


*----------------------------------------------------------------------*
*       CLASS SHRITEFUH64VYIPN5I4UIDBI77WSE4 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*

class LCL_EXCEL implementation.
*"* method's implementations
*include methods.
  METHOD Lif_excel_book_properties~initialize.
    DATA: lv_timestamp TYPE timestampl.

    me->Lif_excel_book_properties~application     = 'Microsoft Excel'.
    me->Lif_excel_book_properties~appversion      = '12.0000'.

    GET TIME STAMP FIELD lv_timestamp.
    me->Lif_excel_book_properties~created         = lv_timestamp.
    me->Lif_excel_book_properties~creator         = sy-uname.
    me->Lif_excel_book_properties~description     = Lcl_excel=>version.
    me->Lif_excel_book_properties~modified        = lv_timestamp.
    me->Lif_excel_book_properties~lastmodifiedby  = sy-uname.
  ENDMETHOD.
  METHOD Lif_excel_book_protection~initialize.
    me->Lif_excel_book_protection~protected      = Lif_excel_book_protection=>c_unprotected.
    me->Lif_excel_book_protection~lockrevision   = Lif_excel_book_protection=>c_unlocked.
    me->Lif_excel_book_protection~lockstructure  = Lif_excel_book_protection=>c_unlocked.
    me->Lif_excel_book_protection~lockwindows    = Lif_excel_book_protection=>c_unlocked.
    CLEAR me->Lif_excel_book_protection~workbookpassword.
    CLEAR me->Lif_excel_book_protection~revisionspassword.
  ENDMETHOD.
  METHOD Lif_excel_book_vba_project~set_codename.
    me->Lif_excel_book_vba_project~codename = ip_codename.
  ENDMETHOD.
  METHOD Lif_excel_book_vba_project~set_codename_pr.
    me->Lif_excel_book_vba_project~codename_pr = ip_codename_pr.
  ENDMETHOD.
  METHOD Lif_excel_book_vba_project~set_vbaproject.
    me->Lif_excel_book_vba_project~vbaproject = ip_vbaproject.
  ENDMETHOD.
  METHOD add_new_autofilter.
* Check for autofilter reference: new or overwrite; only one per sheet
    ro_autofilter = autofilters->add( io_sheet ) .
  ENDMETHOD.
  METHOD add_new_comment.
    CREATE OBJECT eo_comment.

    comments->add( eo_comment ).
  ENDMETHOD.
  METHOD add_new_drawing.
* Create default blank worksheet
    CREATE OBJECT eo_drawing
      EXPORTING
        ip_type  = ip_type
        ip_title = ip_title.

    CASE ip_type.
      WHEN 'image'.
        drawings->add( eo_drawing ).
      WHEN 'hd_ft'.
        drawings->add( eo_drawing ).
      WHEN 'chart'.
        charts->add( eo_drawing ).
    ENDCASE.
  ENDMETHOD.
  METHOD add_new_range.
* Create default blank range
    CREATE OBJECT eo_range.
    ranges->add( eo_range ).
  ENDMETHOD.
  METHOD add_new_style.
* Start of deletion # issue 139 - Dateretention of cellstyles
*  CREATE OBJECT eo_style.
*  styles->add( eo_style ).
* End of deletion # issue 139 - Dateretention of cellstyles
* Start of insertion # issue 139 - Dateretention of cellstyles
* Create default style
    CREATE OBJECT eo_style
      EXPORTING
        ip_guid     = ip_guid
        io_clone_of = io_clone_of.
    styles->add( eo_style ).

    DATA: style2 TYPE zexcel_s_stylemapping.
* Copy to new representations
    style2 = stylemapping_dynamic_style( eo_style ).
    INSERT style2 INTO TABLE t_stylemapping1.
    INSERT style2 INTO TABLE t_stylemapping2.
* End of insertion # issue 139 - Dateretention of cellstyles

  ENDMETHOD.
  METHOD add_new_worksheet.

* Create default blank worksheet
    CREATE OBJECT eo_worksheet
      EXPORTING
        ip_excel = me
        ip_title = ip_title.

    worksheets->add( eo_worksheet ).
    worksheets->active_worksheet = worksheets->size( ).
  ENDMETHOD.
  METHOD add_static_styles.
    " # issue 139
    FIELD-SYMBOLS: <style1> LIKE LINE OF t_stylemapping1,
                   <style2> LIKE LINE OF t_stylemapping2.
    DATA: style TYPE REF TO Lcl_excel_style.

    LOOP AT me->t_stylemapping1 ASSIGNING <style1> WHERE added_to_iterator IS INITIAL.
      READ TABLE me->t_stylemapping2 ASSIGNING <style2> WITH TABLE KEY guid = <style1>-guid.
      CHECK sy-subrc = 0.  " Should always be true since these tables are being filled parallel

      style = me->add_new_style( <style1>-guid ).

      Lcl_excel_common=>recursive_struct_to_class( EXPORTING i_source  = <style1>-complete_style
                                                             i_sourcex = <style1>-complete_stylex
                                                   CHANGING  e_target  = style ).

    ENDLOOP.
  ENDMETHOD.
  METHOD constructor.
    DATA: lo_style      TYPE REF TO Lcl_excel_style.

* Inizialize instance objects
    CREATE OBJECT security.
    CREATE OBJECT worksheets.
    CREATE OBJECT ranges.
    CREATE OBJECT styles.
    CREATE OBJECT drawings
      EXPORTING
        ip_type = Lcl_excel_drawing=>type_image.
    CREATE OBJECT charts
      EXPORTING
        ip_type = Lcl_excel_drawing=>type_chart.
    CREATE OBJECT comments.
    CREATE OBJECT legacy_palette.
    CREATE OBJECT autofilters.

    me->Lif_excel_book_protection~initialize( ).
    me->Lif_excel_book_properties~initialize( ).

    TRY.
        me->add_new_worksheet( ).
      CATCH Lcx_excel. " suppress syntax check error
        ASSERT 1 = 2.  " some error processing anyway
    ENDTRY.

    me->add_new_style( ). " Standard style
    lo_style = me->add_new_style( ). " Standard style with fill gray125
    lo_style->fill->filltype = Lcl_excel_style_fill=>c_fill_pattern_gray125.

  ENDMETHOD.
  METHOD delete_worksheet.

    DATA: lo_worksheet    TYPE REF TO Lcl_excel_worksheet,
          l_size          TYPE i,
          lv_errormessage TYPE string.

    l_size = get_worksheets_size( ).
    IF l_size = 1.  " Only 1 worksheet left --> check whether this is the worksheet to be deleted
      lo_worksheet = me->get_worksheet_by_index( 1 ).
      IF lo_worksheet = io_worksheet.
        lv_errormessage = 'Deleting last remaining worksheet is not allowed'(002).
        Lcx_excel=>raise_text( lv_errormessage ).
      ENDIF.
    ENDIF.

    me->worksheets->remove( io_worksheet ).

  ENDMETHOD.
  METHOD delete_worksheet_by_index.

    DATA: lo_worksheet    TYPE REF TO Lcl_excel_worksheet,
          lv_errormessage TYPE string.

    lo_worksheet = me->get_worksheet_by_index( iv_index ).
    IF lo_worksheet IS NOT BOUND.
      lv_errormessage = 'Worksheet not existing'(001).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.
    me->delete_worksheet( lo_worksheet ).

  ENDMETHOD.
  METHOD delete_worksheet_by_name.

    DATA: lo_worksheet    TYPE REF TO Lcl_excel_worksheet,
          lv_errormessage TYPE string.

    lo_worksheet = me->get_worksheet_by_name( iv_title ).
    IF lo_worksheet IS NOT BOUND.
      lv_errormessage = 'Worksheet not existing'(001).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.
    me->delete_worksheet( lo_worksheet ).

  ENDMETHOD.
  METHOD fill_template.

    DATA: lo_template_filler TYPE REF TO Lcl_excel_fill_template.

    FIELD-SYMBOLS:
      <lv_sheet>     TYPE zexcel_sheet_title,
      <lv_data_line> TYPE Lcl_excel_template_data=>ts_template_data_sheet.


    lo_template_filler = Lcl_excel_fill_template=>create( me ).

    LOOP AT lo_template_filler->mt_sheet ASSIGNING <lv_sheet>.

      READ TABLE iv_data->mt_data ASSIGNING <lv_data_line> WITH KEY sheet = <lv_sheet>.
      CHECK sy-subrc = 0.
      lo_template_filler->fill_sheet( <lv_data_line> ).

    ENDLOOP.

  ENDMETHOD.
  METHOD get_active_sheet_index.
    r_active_worksheet = me->worksheets->active_worksheet.
  ENDMETHOD.
  METHOD get_active_worksheet.

    eo_worksheet = me->worksheets->get( me->worksheets->active_worksheet ).

  ENDMETHOD.
  METHOD get_autofilters_reference.

    ro_autofilters = autofilters.

  ENDMETHOD.
  METHOD get_default_style.
    ep_style = me->default_style.
  ENDMETHOD.
  METHOD get_drawings_iterator.

    CASE ip_type.
      WHEN Lcl_excel_drawing=>type_image.
        eo_iterator = me->drawings->get_iterator( ).
      WHEN Lcl_excel_drawing=>type_chart.
        eo_iterator = me->charts->get_iterator( ).
      WHEN OTHERS.
    ENDCASE.

  ENDMETHOD.
  METHOD get_next_table_id.
    DATA: lo_worksheet    TYPE REF TO Lcl_excel_worksheet,
          lo_iterator     TYPE REF TO Lcl_excel_collection_iterator,
          lv_tables_count TYPE i.

    lo_iterator = me->get_worksheets_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).

      lv_tables_count = lo_worksheet->get_tables_size( ).
      ADD lv_tables_count TO ep_id.

    ENDWHILE.

    ADD 1 TO ep_id.

  ENDMETHOD.
  METHOD get_ranges_iterator.

    eo_iterator = me->ranges->get_iterator( ).

  ENDMETHOD.
  METHOD get_static_cellstyle_guid.
    " # issue 139
    DATA: style LIKE LINE OF me->t_stylemapping1.

    READ TABLE me->t_stylemapping1 INTO style
      WITH TABLE KEY dynamic_style_guid = style-guid  " no dynamic style  --> look for initial guid here
                     complete_style     = ip_cstyle_complete
                     complete_stylex    = ip_cstylex_complete.
    IF sy-subrc <> 0.
      style-complete_style  = ip_cstyle_complete.
      style-complete_stylex = ip_cstylex_complete.
      style-guid = Lcl_excel_obsolete_func_wrap=>guid_create( ). " ins issue #379 - replacement for outdated function call
      INSERT style INTO TABLE me->t_stylemapping1.
      INSERT style INTO TABLE me->t_stylemapping2.

    ENDIF.

    ep_guid = style-guid.
  ENDMETHOD.
  METHOD get_styles_iterator.

    eo_iterator = me->styles->get_iterator( ).

  ENDMETHOD.
  METHOD get_style_from_guid.

    DATA: lo_style    TYPE REF TO Lcl_excel_style,
          lo_iterator TYPE REF TO Lcl_excel_collection_iterator.

    lo_iterator = styles->get_iterator( ).
    WHILE lo_iterator->has_next( ) = abap_true.
      lo_style ?= lo_iterator->get_next( ).
      IF lo_style->get_guid( ) = ip_guid.
        eo_style = lo_style.
        RETURN.
      ENDIF.
    ENDWHILE.

  ENDMETHOD.
  METHOD get_style_index_in_styles.
    DATA: index TYPE i.
    DATA: lo_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_style    TYPE REF TO Lcl_excel_style.

    CHECK ip_guid IS NOT INITIAL.


    lo_iterator = me->get_styles_iterator( ).
    WHILE lo_iterator->has_next( ) = 'X'.
      ADD 1 TO index.
      lo_style ?= lo_iterator->get_next( ).
      IF lo_style->get_guid( ) = ip_guid.
        ep_index = index.
        EXIT.
      ENDIF.
    ENDWHILE.

    IF ep_index IS INITIAL.
      Lcx_excel=>raise_text( 'Index not found' ).
    ELSE.
      SUBTRACT 1 FROM ep_index.  " In excel list starts with "0"
    ENDIF.
  ENDMETHOD.
  METHOD get_style_to_guid.
    DATA: lo_style TYPE REF TO Lcl_excel_style.
    " # issue 139
    READ TABLE me->t_stylemapping2 INTO ep_stylemapping WITH TABLE KEY guid = ip_guid.
    IF sy-subrc <> 0.
      Lcx_excel=>raise_text( 'GUID not found' ).
    ENDIF.

    IF ep_stylemapping-dynamic_style_guid IS NOT INITIAL.
      lo_style = me->get_style_from_guid( ip_guid ).
      Lcl_excel_common=>recursive_class_to_struct( EXPORTING i_source = lo_style
                                                   CHANGING  e_target =  ep_stylemapping-complete_style
                                                             e_targetx = ep_stylemapping-complete_stylex ).
    ENDIF.
  ENDMETHOD.
  METHOD get_theme.
    eo_theme = theme.
  ENDMETHOD.
  METHOD get_worksheets_iterator.

    eo_iterator = me->worksheets->get_iterator( ).

  ENDMETHOD.
  METHOD get_worksheets_name.

    ep_name = me->worksheets->name.

  ENDMETHOD.
  METHOD get_worksheets_size.

    ep_size = me->worksheets->size( ).

  ENDMETHOD.
  METHOD get_worksheet_by_index.


    DATA: lv_index TYPE zexcel_active_worksheet.

    lv_index = iv_index.
    eo_worksheet = me->worksheets->get( lv_index ).

  ENDMETHOD.
  METHOD get_worksheet_by_name.

    DATA: lv_index TYPE zexcel_active_worksheet,
          l_size   TYPE i.

    l_size = get_worksheets_size( ).

    DO l_size TIMES.
      lv_index = sy-index.
      eo_worksheet = me->worksheets->get( lv_index ).
      IF eo_worksheet->get_title( ) = ip_sheet_name.
        RETURN.
      ENDIF.
    ENDDO.

    CLEAR eo_worksheet.

  ENDMETHOD.
  METHOD set_active_sheet_index.
    DATA: lo_worksheet    TYPE REF TO Lcl_excel_worksheet,
          lv_errormessage TYPE string.

*--------------------------------------------------------------------*
* Check whether worksheet exists
*--------------------------------------------------------------------*
    lo_worksheet = me->get_worksheet_by_index( i_active_worksheet ).
    IF lo_worksheet IS NOT BOUND.
      lv_errormessage = 'Worksheet not existing'(001).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

    me->worksheets->active_worksheet = i_active_worksheet.

  ENDMETHOD.
  METHOD set_active_sheet_index_by_name.

    DATA: ws_it    TYPE REF TO Lcl_excel_collection_iterator,
          ws       TYPE REF TO Lcl_excel_worksheet,
          lv_title TYPE zexcel_sheet_title,
          count    TYPE i VALUE 1.

    ws_it = me->worksheets->get_iterator( ).

    WHILE ws_it->has_next( ) = abap_true.
      ws ?= ws_it->get_next( ).
      lv_title = ws->get_title( ).
      IF lv_title = i_worksheet_name.
        me->worksheets->active_worksheet = count.
        EXIT.
      ENDIF.
      count = count + 1.
    ENDWHILE.

  ENDMETHOD.
  METHOD set_default_style.
    me->default_style = ip_style.
  ENDMETHOD.
  METHOD set_theme.
    theme = io_theme.
  ENDMETHOD.
  METHOD stylemapping_dynamic_style.
    " # issue 139
    eo_style2-dynamic_style_guid  = ip_style->get_guid( ).
    eo_style2-guid                = eo_style2-dynamic_style_guid.
    eo_style2-added_to_iterator   = abap_true.

* don't care about attributes here, since this data may change
* dynamically

  ENDMETHOD.
endclass. "LCL_EXCEL implementation

*>>>>>>> LCL_EXCEL_AUTOFILTER <<<<<<<*

*"* macro definitions
*include Lcl_excel_autofilter==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_autofilter==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_AUTOFILTER implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    worksheet = io_sheet.
  ENDMETHOD.
  METHOD get_column_filter.

    DATA: ls_filter LIKE LINE OF me->mt_filters.

    READ TABLE me->mt_filters REFERENCE INTO rr_filter WITH TABLE KEY column = i_column.
    IF sy-subrc <> 0.
      ls_filter-column = i_column.
      INSERT ls_filter INTO TABLE me->mt_filters REFERENCE INTO rr_filter.
    ENDIF.

  ENDMETHOD.
  METHOD get_filter_area.

    validate_area( ).

    rs_area = filter_area.

  ENDMETHOD.
  METHOD get_filter_range.
    DATA: l_row_start_c TYPE string,
          l_row_end_c   TYPE string,
          l_col_start_c TYPE string,
          l_col_end_c   TYPE string.

    validate_area( ).

    l_row_end_c = filter_area-row_end.
    CONDENSE l_row_end_c NO-GAPS.

    l_row_start_c = filter_area-row_start.
    CONDENSE l_row_start_c NO-GAPS.

    l_col_start_c = Lcl_excel_common=>convert_column2alpha( ip_column = filter_area-col_start ) .
    l_col_end_c   = Lcl_excel_common=>convert_column2alpha( ip_column = filter_area-col_end ) .

    CONCATENATE l_col_start_c l_row_start_c ':' l_col_end_c l_row_end_c INTO r_range.

  ENDMETHOD.
  METHOD get_filter_reference.
    DATA: l_row_start_c TYPE string,
          l_row_end_c   TYPE string,
          l_col_start_c TYPE string,
          l_col_end_c   TYPE string,
          l_value       TYPE string.

    validate_area( ).

    l_row_end_c = filter_area-row_end.
    CONDENSE l_row_end_c NO-GAPS.

    l_row_start_c = filter_area-row_start.
    CONDENSE l_row_start_c NO-GAPS.

    l_col_start_c = Lcl_excel_common=>convert_column2alpha( ip_column = filter_area-col_start ) .
    l_col_end_c   = Lcl_excel_common=>convert_column2alpha( ip_column = filter_area-col_end ) .
    l_value = worksheet->get_title( ) .

    r_ref = Lcl_excel_common=>escape_string( ip_value = l_value ).

    CONCATENATE r_ref '!$' l_col_start_c '$' l_row_start_c ':$' l_col_end_c '$' l_row_end_c INTO r_ref.

  ENDMETHOD.
  METHOD get_values.

    FIELD-SYMBOLS: <ls_filter> LIKE LINE OF me->mt_filters,
                   <ls_value>  LIKE LINE OF <ls_filter>-t_values.

    DATA: ls_filter LIKE LINE OF rt_filter.

    LOOP AT me->mt_filters ASSIGNING <ls_filter> WHERE rule = mc_filter_rule_single_values.

      ls_filter-column = <ls_filter>-column.
      LOOP AT <ls_filter>-t_values ASSIGNING <ls_value>.
        ls_filter-value = <ls_value>.
        APPEND ls_filter TO rt_filter.
      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.
  METHOD is_row_hidden.


    DATA: lr_filter TYPE REF TO ts_filter,
          lv_col    TYPE i.

    FIELD-SYMBOLS: <ls_filter> TYPE ts_filter.

    rv_is_hidden = abap_false.

*--------------------------------------------------------------------*
* 1st row of filter area is never hidden, because here the filter
* symbol is being shown
*--------------------------------------------------------------------*
    IF iv_row = me->filter_area-row_start.
      RETURN.
    ENDIF.


    lv_col = me->filter_area-col_start.


    WHILE lv_col <= me->filter_area-col_end.

      lr_filter = me->get_column_filter( lv_col ).
      ASSIGN lr_filter->* TO <ls_filter>.

      CASE <ls_filter>-rule.

        WHEN mc_filter_rule_single_values.
          rv_is_hidden = me->is_row_hidden_single_values( iv_row    = iv_row
                                                          iv_col    = lv_col
                                                          is_filter = <ls_filter> ).

        WHEN mc_filter_rule_text_pattern.
          rv_is_hidden = me->is_row_hidden_text_pattern(  iv_row    = iv_row
                                                          iv_col    = lv_col
                                                          is_filter = <ls_filter> ).

      ENDCASE.

      IF rv_is_hidden = abap_true.
        RETURN.
      ENDIF.


      ADD 1 TO lv_col.

    ENDWHILE.


  ENDMETHOD.
  METHOD is_row_hidden_single_values.


    DATA: lv_value TYPE string.

    FIELD-SYMBOLS: <ls_sheet_content> LIKE LINE OF me->worksheet->sheet_content.

    rv_is_hidden = abap_false.   " Default setting is NOT HIDDEN = is in filter range

*--------------------------------------------------------------------*
* No filter values --> only symbol should be shown but nothing is being hidden
*--------------------------------------------------------------------*
    IF is_filter-t_values IS INITIAL.
      RETURN.
    ENDIF.

*--------------------------------------------------------------------*
* Get value of cell
*--------------------------------------------------------------------*
    READ TABLE me->worksheet->sheet_content ASSIGNING <ls_sheet_content> WITH TABLE KEY cell_row    = iv_row
                                                                                        cell_column = iv_col.
    IF sy-subrc = 0.
      lv_value = <ls_sheet_content>-cell_value.
    ELSE.
      CLEAR lv_value.
    ENDIF.

*--------------------------------------------------------------------*
* Check whether it is affected by filter
* this needs to be extended if we support other filtertypes
* other than single values
*--------------------------------------------------------------------*
    READ TABLE is_filter-t_values TRANSPORTING NO FIELDS WITH TABLE KEY table_line =  lv_value.
    IF sy-subrc <> 0.
      rv_is_hidden = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD is_row_hidden_text_pattern.



    DATA: lv_value TYPE string.

    FIELD-SYMBOLS: <ls_sheet_content> LIKE LINE OF me->worksheet->sheet_content.

    rv_is_hidden = abap_false.   " Default setting is NOT HIDDEN = is in filter range

*--------------------------------------------------------------------*
* Get value of cell
*--------------------------------------------------------------------*
    READ TABLE me->worksheet->sheet_content ASSIGNING <ls_sheet_content> WITH TABLE KEY cell_row    = iv_row
                                                                                        cell_column = iv_col.
    IF sy-subrc = 0.
      lv_value = <ls_sheet_content>-cell_value.
    ELSE.
      CLEAR lv_value.
    ENDIF.

*--------------------------------------------------------------------*
* Check whether it is affected by filter
* this needs to be extended if we support other filtertypes
* other than single values
*--------------------------------------------------------------------*
    IF lv_value NOT IN is_filter-tr_textfilter1.
      rv_is_hidden = abap_true.
    ENDIF.

  ENDMETHOD.
  METHOD set_filter_area.

    filter_area = is_area.

  ENDMETHOD.
  METHOD set_text_filter.
*  see method documentation how to use this

    DATA: lr_filter TYPE REF TO ts_filter,
          ls_value1 TYPE LINE OF ts_filter-tr_textfilter1.

    FIELD-SYMBOLS: <ls_filter> TYPE ts_filter.


    lr_filter = me->get_column_filter(  i_column ).
    ASSIGN lr_filter->* TO <ls_filter>.

    <ls_filter>-rule     = mc_filter_rule_text_pattern.
    CLEAR <ls_filter>-tr_textfilter1.

    IF iv_textfilter1 CA '*+'. " Pattern
      ls_value1-sign   = 'I'.
      ls_value1-option = 'CP'.
      ls_value1-low    = iv_textfilter1.
    ELSE.
      ls_value1-sign   = 'I'.
      ls_value1-option = 'EQ'.
      ls_value1-low    = iv_textfilter1.
    ENDIF.
    APPEND ls_value1 TO <ls_filter>-tr_textfilter1.

  ENDMETHOD.
  METHOD set_value.

    DATA: lr_filter TYPE REF TO ts_filter.

    FIELD-SYMBOLS: <ls_filter> TYPE ts_filter.


    lr_filter = me->get_column_filter(  i_column ).
    ASSIGN lr_filter->* TO <ls_filter>.

    <ls_filter>-rule     = mc_filter_rule_single_values.

    INSERT i_value INTO TABLE <ls_filter>-t_values.

  ENDMETHOD.
  METHOD set_values.

    FIELD-SYMBOLS: <ls_value> LIKE LINE OF it_values.

    LOOP AT it_values ASSIGNING <ls_value>.

      me->set_value( i_column = <ls_value>-column
                     i_value  = <ls_value>-value ).

    ENDLOOP.

  ENDMETHOD.
  METHOD validate_area.
    DATA: l_col                   TYPE zexcel_cell_column,
          ls_original_filter_area TYPE zexcel_s_autofilter_area,
          l_row                   TYPE zexcel_cell_row.

    l_row = worksheet->get_highest_row( ) .
    l_col = worksheet->get_highest_column( ) .

    IF filter_area IS INITIAL.
      filter_area-row_start = 1.
      filter_area-col_start = 1.
      filter_area-row_end   = l_row .
      filter_area-col_end   = l_col .
    ENDIF.

    IF filter_area-row_start > filter_area-row_end.
      ls_original_filter_area = filter_area.
      filter_area-row_start = ls_original_filter_area-row_end.
      filter_area-row_end = ls_original_filter_area-row_start.
    ENDIF.
    IF filter_area-row_start < 1.
      filter_area-row_start = 1.
    ENDIF.
    IF filter_area-col_start < 1.
      filter_area-col_start = 1.
    ENDIF.
    IF filter_area-row_end > l_row OR
       filter_area-row_end < 1.
      filter_area-row_end = l_row.
    ENDIF.
    IF filter_area-col_end > l_col OR
       filter_area-col_end < 1.
      filter_area-col_end = l_col.
    ENDIF.
    IF filter_area-col_start > filter_area-col_end.
      filter_area-col_start = filter_area-col_end.
    ENDIF.
  ENDMETHOD.
endclass. "LCL_EXCEL_AUTOFILTER implementation

*>>>>>>> LCL_EXCEL_AUTOFILTERS <<<<<<<*

*"* macro definitions
*include Lcl_excel_autofilters=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_autofilters=========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_AUTOFILTERS implementation.
*"* method's implementations
*include methods.
  METHOD add.

    DATA: ls_autofilter LIKE LINE OF me->mt_autofilters.

    FIELD-SYMBOLS: <ls_autofilter> LIKE LINE OF me->mt_autofilters.

    READ TABLE me->mt_autofilters ASSIGNING <ls_autofilter> WITH TABLE KEY worksheet = io_sheet.
    IF sy-subrc = 0.
      RAISE EXCEPTION TYPE Lcx_excel. " adding another autofilter to sheet is not allowed
    ENDIF.

    CREATE OBJECT ro_autofilter
      EXPORTING
        io_sheet = io_sheet.

    ls_autofilter-worksheet  = io_sheet.
    ls_autofilter-autofilter = ro_autofilter.
    INSERT ls_autofilter INTO TABLE me->mt_autofilters.


  ENDMETHOD.
  METHOD clear.

    CLEAR me->mt_autofilters.

  ENDMETHOD.
  METHOD get.

    FIELD-SYMBOLS: <ls_autofilter> LIKE LINE OF me->mt_autofilters.

    READ TABLE me->mt_autofilters ASSIGNING <ls_autofilter> WITH TABLE KEY worksheet = io_worksheet.
    IF sy-subrc = 0.
      ro_autofilter = <ls_autofilter>-autofilter.
    ELSE.
      CLEAR ro_autofilter.
    ENDIF.

  ENDMETHOD.
  METHOD is_empty.
    IF me->mt_autofilters IS INITIAL.
      r_empty = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD remove.

    DATA: lo_worksheet  TYPE REF TO Lcl_excel_worksheet.

    DELETE TABLE me->mt_autofilters WITH TABLE KEY worksheet = lo_worksheet.

  ENDMETHOD.
  METHOD size.
    DESCRIBE TABLE me->mt_autofilters LINES r_size.
  ENDMETHOD.
endclass. "LCL_EXCEL_AUTOFILTERS implementation

*>>>>>>> LCL_EXCEL_COLLECTION <<<<<<<*

*"* macro definitions
*include Lcl_excel_collection==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_collection==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


*"* test class
*include Lcl_excel_collection==========ccau.



class LCL_EXCEL_COLLECTION implementation.
*"* method's implementations
*include methods.
  METHOD add .
    APPEND element TO collection.
  ENDMETHOD.
  METHOD clear .
    CLEAR collection.
  ENDMETHOD.
  METHOD get .
    READ TABLE collection INDEX index INTO object.
  ENDMETHOD.
  METHOD get_iterator .
    CREATE OBJECT iterator
      EXPORTING
        collection = me.
  ENDMETHOD.
  METHOD is_empty.
    is_empty = boolc( size( ) = 0 ).
  ENDMETHOD.
  METHOD remove .
    DATA obj TYPE REF TO object.
    LOOP AT collection INTO obj.
      IF obj = element.
        DELETE collection.
        RETURN.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD size.
    size = lines( collection ).
  ENDMETHOD.
endclass. "LCL_EXCEL_COLLECTION implementation

*>>>>>>> LCL_EXCEL_COLLECTION_ITERATOR <<<<<<<*

*"* macro definitions
*include Lcl_excel_collection_iterator=ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_collection_iterator=ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_COLLECTION_ITERATOR implementation.
*"* method's implementations
*include methods.
  METHOD constructor .
    me->collection = collection.
  ENDMETHOD.
  METHOD get_index .
    index = me->index.
  ENDMETHOD.
  METHOD get_next .
    DATA obj TYPE REF TO object.
    index = index + 1.
    object = collection->get( index ).
  ENDMETHOD.
  METHOD has_next.
    DATA obj TYPE REF TO object.
    obj = collection->get( index + 1 ).
    has_next = boolc( obj IS NOT INITIAL ).
  ENDMETHOD.
endclass. "LCL_EXCEL_COLLECTION_ITERATOR implementation

*>>>>>>> LCL_EXCEL_COLUMN <<<<<<<*

*"* macro definitions
*include Lcl_excel_column==============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_column==============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_COLUMN implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    me->column_index = Lcl_excel_common=>convert_column2int( ip_index ).
    me->width         = -1.
    me->auto_size     = abap_false.
    me->visible       = abap_true.
    me->outline_level = 0.
    me->collapsed     = abap_false.
    me->excel         = ip_excel.        "ins issue #157 - Allow Style for columns
    me->worksheet     = ip_worksheet.    "ins issue #157 - Allow Style for columns

    " set default index to cellXf
    me->xf_index = 0.

  ENDMETHOD.
  METHOD get_auto_size.
    r_auto_size = me->auto_size.
  ENDMETHOD.
  METHOD get_collapsed.
    r_collapsed = me->collapsed.
  ENDMETHOD.
  METHOD get_column_index.
    r_column_index = me->column_index.
  ENDMETHOD.
  METHOD get_column_style_guid.
    IF me->style_guid IS NOT INITIAL.
      ep_style_guid = me->style_guid.
    ELSE.
      ep_style_guid = me->worksheet->Lif_excel_sheet_properties~get_style( ).
    ENDIF.
  ENDMETHOD.
  METHOD get_outline_level.
    r_outline_level = me->outline_level.
  ENDMETHOD.
  METHOD get_visible.
    r_visible = me->visible.
  ENDMETHOD.
  METHOD get_width.
    r_width = me->width.
  ENDMETHOD.
  METHOD get_xf_index.
    r_xf_index = me->xf_index.
  ENDMETHOD.
  METHOD set_auto_size.
    me->auto_size = ip_auto_size.
    io_column = me.
  ENDMETHOD.
  METHOD set_collapsed.
    me->collapsed = ip_collapsed.
    io_column = me.
  ENDMETHOD.
  METHOD set_column_index.
    me->column_index = Lcl_excel_common=>convert_column2int( ip_index ).
    io_column = me.
  ENDMETHOD.
  METHOD set_column_style_by_guid.
    DATA: stylemapping TYPE zexcel_s_stylemapping.

    IF me->excel IS NOT BOUND.
      Lcx_excel=>raise_text( 'Internal error - reference to LCL_EXCEL not bound' ).
    ENDIF.
    TRY.
        stylemapping = me->excel->get_style_to_guid( ip_style_guid ).
        me->style_guid = stylemapping-guid.

      CATCH Lcx_excel .
        RETURN.  " leave as is in case of error
    ENDTRY.

  ENDMETHOD.
  METHOD set_outline_level.
    me->outline_level = ip_outline_level.
  ENDMETHOD.
  METHOD set_visible.
    me->visible = ip_visible.
    io_column = me.
  ENDMETHOD.
  METHOD set_width.
    TRY.
        me->width = ip_width.
        io_column = me.
      CATCH cx_sy_conversion_no_number.
        Lcx_excel=>raise_text( 'Unable to interpret width as number' ).
    ENDTRY.
  ENDMETHOD.
  METHOD set_xf_index.
    me->xf_index = ip_xf_index.
    io_column = me.
  ENDMETHOD.
endclass. "LCL_EXCEL_COLUMN implementation

*>>>>>>> LCL_EXCEL_COLUMNS <<<<<<<*

*"* macro definitions
*include Lcl_excel_columns=============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_columns=============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_COLUMNS implementation.
*"* method's implementations
*include methods.
  METHOD add.
    DATA: ls_hashed_column TYPE mty_s_hashed_column.

    ls_hashed_column-column_index = io_column->get_column_index( ).
    ls_hashed_column-column = io_column.

    INSERT ls_hashed_column INTO TABLE columns_hashed .

    columns->add( io_column ).
  ENDMETHOD.
  METHOD clear.
    CLEAR columns_hashed.
    columns->clear( ).
  ENDMETHOD.
  METHOD constructor.

    CREATE OBJECT columns.

  ENDMETHOD.
  METHOD get.
    FIELD-SYMBOLS: <ls_hashed_column> TYPE mty_s_hashed_column.

    READ TABLE columns_hashed WITH KEY column_index = ip_index ASSIGNING <ls_hashed_column>.
    IF sy-subrc = 0.
      eo_column = <ls_hashed_column>-column.
    ENDIF.
  ENDMETHOD.
  METHOD get_iterator.
    eo_iterator ?= columns->get_iterator( ).
  ENDMETHOD.
  METHOD is_empty.
    is_empty = columns->is_empty( ).
  ENDMETHOD.
  METHOD remove.
    DELETE TABLE columns_hashed WITH TABLE KEY column_index = io_column->get_column_index( ) .
    columns->remove( io_column ).
  ENDMETHOD.
  METHOD size.
    ep_size = columns->size( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_COLUMNS implementation

*>>>>>>> LCL_EXCEL_COMMENT <<<<<<<*

*"* macro definitions
*include Lcl_excel_comment=============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_comment=============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_COMMENT implementation.
*"* method's implementations
*include methods.
  METHOD constructor.

  ENDMETHOD.
  METHOD get_index.
    rp_index = me->index.
  ENDMETHOD.
  METHOD get_name.

  ENDMETHOD.
  METHOD get_ref.
    rp_ref = me->ref.
  ENDMETHOD.
  METHOD get_text.
    rp_text = me->text.
  ENDMETHOD.
  METHOD set_text.
    me->text = ip_text.

    IF ip_ref IS SUPPLIED.
      me->ref = ip_ref.
    ENDIF.
  ENDMETHOD.
endclass. "LCL_EXCEL_COMMENT implementation

*>>>>>>> LCL_EXCEL_COMMENTS <<<<<<<*

*"* macro definitions
*include Lcl_excel_comments============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_comments============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_COMMENTS implementation.
*"* method's implementations
*include methods.
  METHOD add.
    DATA: lv_index TYPE i.

    comments->add( ip_comment ).
    lv_index = comments->size( ).

  ENDMETHOD.
  METHOD clear.
    comments->clear( ).

  ENDMETHOD.
  METHOD constructor.
    CREATE OBJECT comments.

  ENDMETHOD.
  METHOD get.
    DATA lv_index TYPE i.
    lv_index = ip_index.
    eo_comment ?= comments->get( lv_index ).

  ENDMETHOD.
  METHOD get_iterator.

    eo_iterator ?= comments->get_iterator( ).
  ENDMETHOD.
  METHOD include.
    comments->add( ip_comment ).
  ENDMETHOD.
  METHOD is_empty.

    is_empty = comments->is_empty( ).
  ENDMETHOD.
  METHOD remove.

    comments->remove( ip_comment ).
  ENDMETHOD.
  METHOD size.

    ep_size = comments->size( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_COMMENTS implementation

*>>>>>>> LCL_EXCEL_CONVERTER <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter===========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter===========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER implementation.
*"* method's implementations
*include methods.
  METHOD ask_option.
    DATA: ls_sval      TYPE sval,
          lt_sval      TYPE STANDARD TABLE OF sval,
          l_returncode TYPE string,
          lt_fields    TYPE ddfields,
          ls_fields    TYPE dfies.

    FIELD-SYMBOLS: <fs> TYPE any.

    rs_option = ws_option.

    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = 'ZEXCEL_S_CONVERTER_OPTION'
      TABLES
        dfies_tab      = lt_fields
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    LOOP AT lt_fields INTO ls_fields.
      ASSIGN COMPONENT ls_fields-fieldname OF STRUCTURE ws_option TO <fs>.
      IF sy-subrc = 0.
        CLEAR ls_sval.
        ls_sval-tabname      = ls_fields-tabname.
        ls_sval-fieldname    = ls_fields-fieldname.
        ls_sval-value        = <fs>.
        ls_sval-field_attr   = space.
        ls_sval-field_obl    = space.
        ls_sval-comp_code    = space.
        ls_sval-fieldtext    = ls_fields-scrtext_m.
        ls_sval-comp_tab     = space.
        ls_sval-comp_field   = space.
        ls_sval-novaluehlp   = space.
        INSERT ls_sval INTO TABLE lt_sval.
      ENDIF.
    ENDLOOP.

    CALL FUNCTION 'POPUP_GET_VALUES'
      EXPORTING
        popup_title     = 'Excel creation options'(008)
      IMPORTING
        returncode      = l_returncode
      TABLES
        fields          = lt_sval
      EXCEPTIONS
        error_in_fields = 1
        OTHERS          = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ELSEIF l_returncode = 'A'.
      RAISE EXCEPTION TYPE Lcx_excel.
    ELSE.
      LOOP AT lt_sval INTO ls_sval.
        ASSIGN COMPONENT ls_sval-fieldname OF STRUCTURE ws_option TO <fs>.
        IF sy-subrc = 0.
          <fs> = ls_sval-value.
        ENDIF.
      ENDLOOP.
      set_option( is_option = ws_option ) .
      rs_option = ws_option.
    ENDIF.
  ENDMETHOD.
  METHOD bind_cells.

* Do we need subtotals with grouping
    READ TABLE wt_fieldcatalog TRANSPORTING NO FIELDS WITH KEY is_subtotalled = abap_true.
    IF sy-subrc = 0  .
      r_freeze_col = loop_subtotal( i_row_int = w_row_int
                                    i_col_int  = w_col_int ) .
    ELSE.
      r_freeze_col = loop_normal( i_row_int = w_row_int
                                  i_col_int = w_col_int ) .
    ENDIF.

  ENDMETHOD.
  METHOD bind_table.
    DATA: lt_field_catalog TYPE zexcel_t_fieldcatalog,
          ls_field_catalog TYPE zexcel_s_fieldcatalog,
          ls_fcat          TYPE zexcel_s_converter_fcat,
          lo_column        TYPE REF TO Lcl_excel_column,
          lv_col_int       TYPE zexcel_cell_column,
          lv_col_alpha     TYPE zexcel_cell_column_alpha,
          ls_settings      TYPE zexcel_s_table_settings,
          lv_line          TYPE i.

    FIELD-SYMBOLS: <fs_tab>         TYPE ANY TABLE.

    ASSIGN wo_data->* TO <fs_tab> .

    ls_settings-table_style      = i_style_table.
    ls_settings-top_left_column  = Lcl_excel_common=>convert_column2alpha( ip_column = w_col_int ).
    ls_settings-top_left_row     = w_row_int.
    ls_settings-show_row_stripes = ws_layout-is_stripped.

    DESCRIBE TABLE  wt_fieldcatalog  LINES lv_line.
    lv_line = lv_line + 1 + w_col_int.
    ls_settings-bottom_right_column = Lcl_excel_common=>convert_column2alpha( ip_column = lv_line ).

    DESCRIBE TABLE <fs_tab> LINES lv_line.
    ls_settings-bottom_right_row = lv_line + 1 + w_row_int.
    SORT wt_fieldcatalog BY position.
    LOOP AT wt_fieldcatalog INTO ls_fcat.
      MOVE-CORRESPONDING ls_fcat TO ls_field_catalog.
      ls_field_catalog-dynpfld = abap_true.
      INSERT ls_field_catalog INTO TABLE lt_field_catalog.
    ENDLOOP.

    wo_worksheet->bind_table(
      EXPORTING
        ip_table          = <fs_tab>
        it_field_catalog  = lt_field_catalog
        is_table_settings = ls_settings
      IMPORTING
        es_table_settings = ls_settings
           ).
    LOOP AT wt_fieldcatalog INTO ls_fcat.
      lv_col_int = w_col_int + ls_fcat-position - 1.
      lv_col_alpha = Lcl_excel_common=>convert_column2alpha( lv_col_int ).
* Freeze panes
      IF ls_fcat-fix_column = abap_true.
        ADD 1 TO r_freeze_col.
      ENDIF.
* Now let's check for optimized
      IF ls_fcat-is_optimized = abap_true.
        lo_column = wo_worksheet->get_column( ip_column = lv_col_alpha ).
        lo_column->set_auto_size( ip_auto_size = abap_true ) .
      ENDIF.
* Now let's check for visible
      IF ls_fcat-is_hidden = abap_true.
        lo_column = wo_worksheet->get_column( ip_column = lv_col_alpha ).
        lo_column->set_visible( ip_visible = abap_false ) .
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD class_constructor.
    DATA: ls_objects TYPE SHRITEFUH64VYIPN5I4UIDBI775SE4.
    DATA: ls_option TYPE zexcel_s_converter_option,
          l_uname   TYPE sy-uname.

    GET PARAMETER ID 'ZUS' FIELD l_uname.
    IF l_uname IS INITIAL OR l_uname = space.
      l_uname = sy-uname.
    ENDIF.

    get_alv_converters( ).

    CONCATENATE 'EXCEL_' sy-uname INTO ws_indx-srtfd.

    IMPORT p1 = ls_option FROM DATABASE indx(xl) TO ws_indx ID ws_indx-srtfd.

    IF sy-subrc = 0.
      ws_option = ls_option.
    ELSE.
      init_option( ) .
    ENDIF.

  ENDMETHOD.
  METHOD clean_fieldcatalog.
    DATA: l_position TYPE tabfdpos.

    FIELD-SYMBOLS: <fs_sfcat>   TYPE zexcel_s_converter_fcat.

    SORT wt_fieldcatalog BY position col_id.

    CLEAR l_position.
    LOOP AT wt_fieldcatalog ASSIGNING <fs_sfcat>.
      ADD 1 TO l_position.
      <fs_sfcat>-position = l_position.
* Default stype with alignment and format
      <fs_sfcat>-style_hdr      = get_style( i_type      = c_type_hdr
                                             i_alignment = <fs_sfcat>-alignment ).
      IF ws_layout-is_stripped = abap_true.
        <fs_sfcat>-style_stripped = get_style( i_type      = c_type_str
                                               i_alignment = <fs_sfcat>-alignment
                                               i_inttype   = <fs_sfcat>-inttype
                                               i_decimals  = <fs_sfcat>-decimals   ).
      ENDIF.
      <fs_sfcat>-style_normal   = get_style( i_type      = c_type_nor
                                             i_alignment = <fs_sfcat>-alignment
                                             i_inttype   = <fs_sfcat>-inttype
                                             i_decimals  = <fs_sfcat>-decimals   ).
      <fs_sfcat>-style_subtotal = get_style( i_type      = c_type_sub
                                             i_alignment = <fs_sfcat>-alignment
                                             i_inttype   = <fs_sfcat>-inttype
                                             i_decimals  = <fs_sfcat>-decimals   ).
      <fs_sfcat>-style_total    = get_style( i_type      = c_type_tot
                                             i_alignment = <fs_sfcat>-alignment
                                             i_inttype   = <fs_sfcat>-inttype
                                             i_decimals  = <fs_sfcat>-decimals   ).
    ENDLOOP.

  ENDMETHOD.
  METHOD convert.

    IF is_option IS SUPPLIED.
      ws_option = is_option.
    ENDIF.

    execute_converter( EXPORTING io_object   = io_alv
                                 it_table    = it_table ) .

    IF io_worksheet IS SUPPLIED AND io_worksheet IS BOUND.
      wo_worksheet = io_worksheet.
    ENDIF.
    IF co_excel IS SUPPLIED.
      IF co_excel IS NOT BOUND.
        CREATE OBJECT co_excel.
        co_excel->Lif_excel_book_properties~creator = sy-uname.
      ENDIF.
      wo_excel = co_excel.
    ENDIF.

* Move table to data object and clean it up
    IF wt_fieldcatalog IS NOT INITIAL.
      create_table( ).
    ELSE.
      wo_data = wo_table .
    ENDIF.

    IF wo_excel IS NOT BOUND.
      CREATE OBJECT wo_excel.
      wo_excel->Lif_excel_book_properties~creator = sy-uname.
    ENDIF.
    IF wo_worksheet IS NOT BOUND.
      " Get active sheet
      wo_worksheet = wo_excel->get_active_worksheet( ).
      wo_worksheet->set_title( ip_title = 'Sheet1'(001) ).
    ENDIF.

    IF i_row_int <= 0.
      w_row_int = 1.
    ELSE.
      w_row_int = i_row_int.
    ENDIF.
    IF i_column_int <= 0.
      w_col_int = 1.
    ELSE.
      w_col_int = i_column_int.
    ENDIF.

    create_worksheet( i_table       = i_table
                      i_style_table = i_style_table ) .

  ENDMETHOD.
  METHOD create_color_style.
    DATA: ls_styles TYPE SHRITEFUH64VYIPN5I4UIDBJAAASE4.
    DATA: lo_style TYPE REF TO Lcl_excel_style.

    READ TABLE wt_styles INTO ls_styles WITH KEY guid = i_style.
    IF sy-subrc = 0.
      lo_style                 = wo_excel->add_new_style( ).
      lo_style->font->bold                 = ls_styles-style->font->bold.
      lo_style->alignment->horizontal      = ls_styles-style->alignment->horizontal.
      lo_style->number_format->format_code = ls_styles-style->number_format->format_code.

      lo_style->font->color-rgb      = is_colors-fontcolor.
      lo_style->fill->filltype       = Lcl_excel_style_fill=>c_fill_solid.
      lo_style->fill->fgcolor-rgb    = is_colors-fillcolor.

      ro_style = lo_style.
    ENDIF.
  ENDMETHOD.
  METHOD create_formular_subtotal.
    DATA: l_row_alpha_start TYPE string,
          l_row_alpha_end   TYPE string,
          l_func_num        TYPE string.

    l_row_alpha_start   = i_row_int_start.
    l_row_alpha_end     = i_row_int_end.

    l_func_num = get_function_number( i_totals_function = i_totals_function ).
    CONCATENATE 'SUBTOTAL(' l_func_num ',' i_column l_row_alpha_start ':' i_column l_row_alpha_end ')' INTO r_formula.
  ENDMETHOD.
  METHOD create_formular_total.
    DATA: l_row_alpha   TYPE string,
          l_row_e_alpha TYPE string.

    l_row_alpha   = w_row_int + 1.
    l_row_e_alpha = i_row_int.

    CONCATENATE i_totals_function '(' i_column l_row_alpha ':' i_column l_row_e_alpha ')' INTO r_formula.
  ENDMETHOD.
  METHOD create_path.
    DATA: l_sep    TYPE c,
          l_path   TYPE string,
          l_return TYPE i.

    CLEAR r_path.

    " Save the file
    cl_gui_frontend_services=>get_sapgui_workdir(
      CHANGING
        sapworkdir            = l_path
          EXCEPTIONS
            get_sapworkdir_failed = 1
            cntl_error            = 2
            error_no_gui          = 3
            not_supported_by_gui  = 4
           ).
    IF sy-subrc <> 0.
      CONCATENATE 'Excel_' w_fcount '.xlsx' INTO r_path.
    ELSE.
      DO.
        ADD 1 TO w_fcount.
*-obtain file separator character---------------------------------------
        CALL METHOD cl_gui_frontend_services=>get_file_separator
          CHANGING
            file_separator       = l_sep
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            OTHERS               = 4.

        IF sy-subrc <> 0.
          l_sep = ''.
        ENDIF.

        CONCATENATE l_path l_sep 'Excel_' w_fcount '.xlsx' INTO r_path.

        IF cl_gui_frontend_services=>file_exist( file  = r_path ) = abap_true.
          cl_gui_frontend_services=>file_delete( EXPORTING filename = r_path
                                                 CHANGING  rc       = l_return
                                                 EXCEPTIONS OTHERS  = 1 ).
          IF sy-subrc = 0 .
            RETURN.
          ENDIF.
        ELSE.
          RETURN.
        ENDIF.
      ENDDO.
    ENDIF.

  ENDMETHOD.
  METHOD create_style_hdr.
    DATA: lo_style TYPE REF TO Lcl_excel_style.

    lo_style                       = wo_excel->add_new_style( ).
    lo_style->font->bold           = abap_true.
    lo_style->font->color-rgb      = Lcl_excel_style_color=>c_white.
    lo_style->fill->filltype       = Lcl_excel_style_fill=>c_fill_solid.
    lo_style->fill->fgcolor-rgb    = 'FF4F81BD'.
    IF i_alignment IS SUPPLIED AND i_alignment IS NOT INITIAL.
      lo_style->alignment->horizontal = i_alignment.
    ENDIF.
    ro_style = lo_style .
  ENDMETHOD.
  METHOD create_style_normal.
    DATA: lo_style TYPE REF TO Lcl_excel_style,
          l_format TYPE zexcel_number_format.

    IF i_inttype IS SUPPLIED AND i_inttype IS NOT INITIAL.
      l_format = set_cell_format(  i_inttype  = i_inttype
                                   i_decimals = i_decimals ) .
    ENDIF.
    IF l_format IS NOT INITIAL OR
       ( i_alignment IS SUPPLIED AND i_alignment IS NOT INITIAL ) .

      lo_style                       = wo_excel->add_new_style( ).

      IF i_alignment IS SUPPLIED AND i_alignment IS NOT INITIAL.
        lo_style->alignment->horizontal = i_alignment.
      ENDIF.

      IF l_format IS NOT INITIAL.
        lo_style->number_format->format_code = l_format.
      ENDIF.

      ro_style = lo_style .

    ENDIF.
  ENDMETHOD.
  METHOD create_style_stripped.
    DATA:   lo_style    TYPE REF TO Lcl_excel_style.
    DATA:  l_format    TYPE zexcel_number_format.

    lo_style                       = wo_excel->add_new_style( ).
    lo_style->fill->filltype       = Lcl_excel_style_fill=>c_fill_solid.
    lo_style->fill->fgcolor-rgb    = 'FFDBE5F1'.
    IF i_alignment IS SUPPLIED AND i_alignment IS NOT INITIAL.
      lo_style->alignment->horizontal = i_alignment.
    ENDIF.
    IF i_inttype IS SUPPLIED AND i_inttype IS NOT INITIAL.
      l_format = set_cell_format(  i_inttype  = i_inttype
                                   i_decimals = i_decimals ) .
      IF l_format IS NOT INITIAL.
        lo_style->number_format->format_code = l_format.
      ENDIF.
    ENDIF.
    ro_style = lo_style.

  ENDMETHOD.
  METHOD create_style_subtotal.
    DATA:   lo_style    TYPE REF TO Lcl_excel_style.
    DATA:  l_format    TYPE zexcel_number_format.

    lo_style                       = wo_excel->add_new_style( ).
    lo_style->font->bold           = abap_true.

    IF i_alignment IS SUPPLIED AND i_alignment IS NOT INITIAL.
      lo_style->alignment->horizontal = i_alignment.
    ENDIF.
    IF i_inttype IS SUPPLIED AND i_inttype IS NOT INITIAL.
      l_format = set_cell_format(  i_inttype  = i_inttype
                                   i_decimals = i_decimals ) .
      IF l_format IS NOT INITIAL.
        lo_style->number_format->format_code = l_format.
      ENDIF.
    ENDIF.

    ro_style = lo_style .

  ENDMETHOD.
  METHOD create_style_total.
    DATA:   lo_style    TYPE REF TO Lcl_excel_style.
    DATA:  l_format    TYPE zexcel_number_format.

    lo_style                                   = wo_excel->add_new_style( ).
    lo_style->font->bold                       = abap_true.

    CREATE OBJECT lo_style->borders->top.
    lo_style->borders->top->border_style       = Lcl_excel_style_border=>c_border_thin.
    lo_style->borders->top->border_color-rgb   = Lcl_excel_style_color=>c_black.

    CREATE OBJECT lo_style->borders->right.
    lo_style->borders->right->border_style       = Lcl_excel_style_border=>c_border_none.
    lo_style->borders->right->border_color-rgb   = Lcl_excel_style_color=>c_black.

    CREATE OBJECT lo_style->borders->down.
    lo_style->borders->down->border_style      = Lcl_excel_style_border=>c_border_double.
    lo_style->borders->down->border_color-rgb  = Lcl_excel_style_color=>c_black.

    CREATE OBJECT lo_style->borders->left.
    lo_style->borders->left->border_style       = Lcl_excel_style_border=>c_border_none.
    lo_style->borders->left->border_color-rgb   = Lcl_excel_style_color=>c_black.

    IF i_alignment IS SUPPLIED AND i_alignment IS NOT INITIAL.
      lo_style->alignment->horizontal = i_alignment.
    ENDIF.
    IF i_inttype IS SUPPLIED AND i_inttype IS NOT INITIAL.
      l_format = set_cell_format(  i_inttype  = i_inttype
                                   i_decimals = i_decimals ) .
      IF l_format IS NOT INITIAL.
        lo_style->number_format->format_code = l_format.
      ENDIF.
    ENDIF.

    ro_style = lo_style .

  ENDMETHOD.
  METHOD create_table.
    TYPES: BEGIN OF ts_output,
             fieldname TYPE fieldname,
             function  TYPE funcname,
           END OF ts_output.

    DATA: lo_data TYPE REF TO data.
    DATA: lo_addit          TYPE REF TO cl_abap_elemdescr,
          lt_components_tab TYPE cl_abap_structdescr=>component_table,
          ls_components     TYPE abap_componentdescr,
          lo_table          TYPE REF TO cl_abap_tabledescr,
          lo_struc          TYPE REF TO cl_abap_structdescr.

    FIELD-SYMBOLS: <fs_scat>  TYPE zexcel_s_converter_fcat,
                   <fs_stab>  TYPE any,
                   <fs_ttab>  TYPE STANDARD TABLE,
                   <fs>       TYPE any,
                   <fs_table> TYPE STANDARD TABLE.

    SORT wt_fieldcatalog BY position.
    ASSIGN wo_table->* TO <fs_table>.

    READ TABLE <fs_table> ASSIGNING <fs_stab> INDEX 1.
    IF sy-subrc EQ 0 .
      LOOP AT wt_fieldcatalog ASSIGNING <fs_scat>.
        ASSIGN COMPONENT <fs_scat>-columnname OF STRUCTURE <fs_stab> TO <fs>.
        IF sy-subrc = 0.
          ls_components-name   = <fs_scat>-columnname.
          TRY.
              lo_addit            ?= cl_abap_typedescr=>describe_by_data( <fs> ).
            CATCH cx_sy_move_cast_error.
              CLEAR lo_addit.
              DELETE TABLE wt_fieldcatalog FROM <fs_scat>.
          ENDTRY.
          IF lo_addit IS BOUND.
            ls_components-type   = lo_addit           .
            INSERT ls_components INTO TABLE lt_components_tab.
          ENDIF.
        ENDIF.
      ENDLOOP.
      IF lt_components_tab IS NOT INITIAL.
        "create new line type
        TRY.
            lo_struc = cl_abap_structdescr=>create( p_components = lt_components_tab
                                                    p_strict     = abap_false ).
          CATCH cx_sy_struct_creation.
            RETURN.  " We can not do anything in this case.
        ENDTRY.

        lo_table = cl_abap_tabledescr=>create( lo_struc ).

        CREATE DATA wo_data   TYPE HANDLE lo_table.
        CREATE DATA lo_data   TYPE HANDLE lo_struc.

        ASSIGN wo_data->* TO <fs_ttab>.
        ASSIGN lo_data->* TO <fs_stab>.
        LOOP AT <fs_table>  ASSIGNING <fs>.
          CLEAR <fs_stab>.
          MOVE-CORRESPONDING <fs> TO <fs_stab>.
          APPEND <fs_stab> TO <fs_ttab>.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD create_text_subtotal.
    DATA: l_string(256) TYPE c,
          l_func        TYPE string.

    CASE i_totals_function.
      WHEN Lcl_excel_table=>totals_function_sum.     " Total
        l_func = 'Total'(003).
      WHEN Lcl_excel_table=>totals_function_min.     " Minimum
        l_func = 'Minimum'(004).
      WHEN Lcl_excel_table=>totals_function_max.     " Maximum
        l_func = 'Maximum'(005).
      WHEN Lcl_excel_table=>totals_function_average. " Mean Value
        l_func = 'Average'(006).
      WHEN Lcl_excel_table=>totals_function_count.   " Count
        l_func = 'Count'(007).
      WHEN OTHERS.
        CLEAR l_func.
    ENDCASE.

    l_string = i_value.

    CONCATENATE l_string l_func INTO r_text SEPARATED BY space.

  ENDMETHOD.
  METHOD create_worksheet.
    DATA: l_freeze_col TYPE i.

    IF wo_data IS BOUND AND wo_worksheet IS BOUND.

      wo_worksheet->Lif_excel_sheet_properties~summarybelow = Lif_excel_sheet_properties=>c_below_on. " By default is on

      IF wt_fieldcatalog IS INITIAL.
        set_fieldcatalog( ) .
      ELSE.
        clean_fieldcatalog( ) .
      ENDIF.

      IF i_table = abap_true.
        l_freeze_col = bind_table( i_style_table = i_style_table ) .
      ELSEIF wt_filter IS NOT INITIAL.
* Let's check for filter.
        wo_autofilter = wo_excel->add_new_autofilter( io_sheet = wo_worksheet ).
        l_freeze_col = bind_cells( ) .
        set_autofilter_area( ) .
      ELSE.
        l_freeze_col = bind_cells( ) .
      ENDIF.

* Check for freeze panes
      IF ws_layout-is_fixed = abap_true.
        IF l_freeze_col = 0.
          l_freeze_col = w_col_int.
        ENDIF.
        wo_worksheet->freeze_panes( EXPORTING ip_num_columns = l_freeze_col
                                              ip_num_rows    = w_row_int ) .
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD execute_converter.
    DATA: lo_if               TYPE REF TO Lif_excel_converter,
          ls_types            TYPE SHRITEFUH64VYIPN5I4UIDBI775SE4,
          lo_addit            TYPE REF TO cl_abap_classdescr,
          lo_addit_superclass TYPE REF TO cl_abap_classdescr.

    IF io_object IS BOUND.
      TRY.
          lo_addit            ?= cl_abap_typedescr=>describe_by_object_ref( io_object ).
        CATCH cx_sy_move_cast_error.
          RAISE EXCEPTION TYPE Lcx_excel.
      ENDTRY.
      ls_types-seoclass = lo_addit->get_relative_name( ).
      READ TABLE wt_objects INTO ls_types WITH TABLE KEY seoclass = ls_types-seoclass.
      IF sy-subrc NE 0.
        DO.
          FREE lo_addit_superclass.
          lo_addit_superclass = lo_addit->get_super_class_type( ).
          IF lo_addit_superclass IS INITIAL.
            CLEAR ls_types-clsname.
            EXIT.
          ENDIF.
          lo_addit = lo_addit_superclass.
          ls_types-seoclass = lo_addit->get_relative_name( ).
          READ TABLE wt_objects INTO ls_types WITH TABLE KEY seoclass = ls_types-seoclass.
          IF sy-subrc EQ 0.
            EXIT.
          ENDIF.
        ENDDO.
      ENDIF.
      IF ls_types-clsname IS NOT INITIAL.
        CREATE OBJECT lo_if TYPE (ls_types-clsname).
        lo_if->create_fieldcatalog(
          EXPORTING
            is_option       = ws_option
            io_object       = io_object
            it_table        = it_table
          IMPORTING
            es_layout       = ws_layout
            et_fieldcatalog = wt_fieldcatalog
            eo_table        = wo_table
            et_colors       = wt_colors
            et_filter       = wt_filter
            ).
*  data lines of highest level.
        IF ws_layout-max_subtotal_level > 0. ADD 1 TO ws_layout-max_subtotal_level. ENDIF.
      ELSE.
        RAISE EXCEPTION TYPE Lcx_excel.
      ENDIF.
    ELSE.
      CLEAR wt_fieldcatalog.
      GET REFERENCE OF it_table INTO wo_table.
    ENDIF.
  ENDMETHOD.
  METHOD get_alv_converters.
    DATA:
      lt_direct_implementations TYPE seor_implementing_keys,
      lt_all_implementations    TYPE seor_implementing_keys,
      ls_impkey                 TYPE seor_implementing_key,
      ls_classkey               TYPE seoclskey,
      lr_implementation         TYPE REF TO Lif_excel_converter,
      ls_object                 TYPE SHRITEFUH64VYIPN5I4UIDBI775SE4,
      lr_classdescr             TYPE REF TO cl_abap_classdescr.

    ls_classkey-clsname = 'LIF_EXCEL_CONVERTER'.

    CALL FUNCTION 'SEO_INTERFACE_IMPLEM_GET_ALL'
      EXPORTING
        intkey  = ls_classkey
      IMPORTING
        impkeys = lt_direct_implementations
      EXCEPTIONS
        OTHERS  = 2.

    CHECK sy-subrc = 0.

    LOOP AT lt_direct_implementations INTO ls_impkey.
      lr_classdescr ?= cl_abap_classdescr=>describe_by_name( ls_impkey-clsname ).
      IF lr_classdescr->is_instantiatable( ) = abap_true.
        APPEND ls_impkey TO lt_all_implementations.
      ENDIF.

      ls_classkey-clsname = ls_impkey-clsname.
      get_subclasses( EXPORTING is_clskey = ls_classkey CHANGING ct_classes = lt_all_implementations ).
    ENDLOOP.

    SORT lt_all_implementations BY clsname.
    DELETE ADJACENT DUPLICATES FROM lt_all_implementations COMPARING clsname.

    LOOP AT lt_all_implementations INTO ls_impkey.
      CLEAR ls_object.
      CREATE OBJECT lr_implementation TYPE (ls_impkey-clsname).
      ls_object-seoclass = lr_implementation->get_supported_class( ).

      IF ls_object-seoclass IS NOT INITIAL.
        ls_object-clsname  = ls_impkey-clsname.
        INSERT ls_object INTO TABLE wt_objects.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_color_style.
    DATA: ls_colors       TYPE zexcel_s_converter_col,
          ls_color_styles TYPE SHRITEFUH64VYIPN5I4UIDBJAABSE4,
          lo_style        TYPE REF TO Lcl_excel_style.

    r_style = i_style. " Default we change nothing

    IF wt_colors IS NOT INITIAL.
* Full line has color
      READ TABLE wt_colors INTO ls_colors WITH KEY rownumber   = i_row
                                                   columnname  = space.
      IF sy-subrc = 0.
        READ TABLE wt_color_styles INTO ls_color_styles WITH KEY guid_old  = i_style
                                                                 fontcolor = ls_colors-fontcolor
                                                                 fillcolor = ls_colors-fillcolor.
        IF sy-subrc = 0.
          r_style = ls_color_styles-style_new->get_guid( ).
        ELSE.
          lo_style = create_color_style( i_style          = i_style
                                         is_colors        = ls_colors ) .
          r_style = lo_style->get_guid( ) .
          ls_color_styles-guid_old  = i_style.
          ls_color_styles-fontcolor = ls_colors-fontcolor.
          ls_color_styles-fillcolor = ls_colors-fillcolor.
          ls_color_styles-style_new = lo_style.
          INSERT ls_color_styles INTO TABLE wt_color_styles.
        ENDIF.
      ELSE.
* Only field has color
        READ TABLE wt_colors INTO ls_colors WITH KEY rownumber   = i_row
                                                     columnname  = i_fieldname.
        IF sy-subrc = 0.
          READ TABLE wt_color_styles INTO ls_color_styles WITH KEY guid_old  = i_style
                                                                   fontcolor = ls_colors-fontcolor
                                                                   fillcolor = ls_colors-fillcolor.
          IF sy-subrc = 0.
            r_style = ls_color_styles-style_new->get_guid( ).
          ELSE.
            lo_style = create_color_style( i_style          = i_style
                                           is_colors        = ls_colors ) .
            ls_color_styles-guid_old  = i_style.
            ls_color_styles-fontcolor = ls_colors-fontcolor.
            ls_color_styles-fillcolor = ls_colors-fillcolor.
            ls_color_styles-style_new = lo_style.
            INSERT ls_color_styles INTO TABLE wt_color_styles.
            r_style = ls_color_styles-style_new->get_guid( ).
          ENDIF.
        ELSE.
          r_style = i_style.
        ENDIF.
      ENDIF.
    ELSE.
      r_style = i_style.
    ENDIF.

  ENDMETHOD.
  METHOD get_file.
    DATA: lo_excel_writer         TYPE REF TO Lif_excel_writer.

    DATA: ls_seoclass TYPE seoclass.


    IF wo_excel IS BOUND.
      CREATE OBJECT lo_excel_writer TYPE Lcl_excel_writer_2007.
      e_file = lo_excel_writer->write_file( wo_excel ).

      SELECT SINGLE * INTO ls_seoclass
        FROM seoclass
        WHERE clsname = 'CL_BCS_CONVERT'.

      IF sy-subrc = 0.
        CALL METHOD (ls_seoclass-clsname)=>xstring_to_solix
          EXPORTING
            iv_xstring = e_file
          RECEIVING
            et_solix   = et_file.
        e_bytecount = xstrlen( e_file ).
      ELSE.
        " Convert to binary
        CALL FUNCTION 'SCMS_XSTRING_TO_BINARY'
          EXPORTING
            buffer        = e_file
          IMPORTING
            output_length = e_bytecount
          TABLES
            binary_tab    = et_file.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD get_function_number.
*Number    Function
*1  AVERAGE
*2  COUNT
*3  COUNTA
*4  MAX
*5  MIN
*6  PRODUCT
*7  STDEV
*8  STDEVP
*9  SUM
*10  VAR
*11  VARP

    CASE i_totals_function.
      WHEN Lcl_excel_table=>totals_function_sum.     " Total
        r_function_number = 9.
      WHEN Lcl_excel_table=>totals_function_min.     " Minimum
        r_function_number = 5.
      WHEN Lcl_excel_table=>totals_function_max.     " Maximum
        r_function_number = 4.
      WHEN Lcl_excel_table=>totals_function_average. " Mean Value
        r_function_number = 1.
      WHEN Lcl_excel_table=>totals_function_count.   " Count
        r_function_number = 2.
      WHEN OTHERS.
        CLEAR r_function_number.
    ENDCASE.
  ENDMETHOD.
  METHOD get_option.

    rs_option = ws_option.

  ENDMETHOD.
  METHOD get_style.
    DATA: ls_styles TYPE SHRITEFUH64VYIPN5I4UIDBJAAASE4,
          lo_style  TYPE REF TO Lcl_excel_style.

    CLEAR r_style.

    READ TABLE wt_styles INTO ls_styles WITH TABLE KEY type      = i_type
                                                       alignment = i_alignment
                                                       inttype   = i_inttype
                                                       decimals  = i_decimals.
    IF sy-subrc = 0.
      r_style = ls_styles-guid.
    ELSE.
      CASE i_type.
        WHEN c_type_hdr. " Header
          lo_style = create_style_hdr( i_alignment = i_alignment ).
        WHEN c_type_str. "Stripped
          lo_style   = create_style_stripped( i_alignment = i_alignment
                                              i_inttype   = i_inttype
                                              i_decimals  = i_decimals   ).
        WHEN c_type_nor. "Normal
          lo_style   = create_style_normal( i_alignment = i_alignment
                                            i_inttype   = i_inttype
                                            i_decimals  = i_decimals   ).
        WHEN c_type_sub. "Subtotals
          lo_style   = create_style_subtotal( i_alignment = i_alignment
                                              i_inttype   = i_inttype
                                              i_decimals  = i_decimals   ).
        WHEN c_type_tot. "Totals
          lo_style   = create_style_total( i_alignment = i_alignment
                                           i_inttype   = i_inttype
                                           i_decimals  = i_decimals   ).
      ENDCASE.
      IF lo_style IS NOT INITIAL.
        r_style = lo_style->get_guid( ).
        ls_styles-type       = i_type.
        ls_styles-alignment  = i_alignment.
        ls_styles-inttype    = i_inttype.
        ls_styles-decimals   = i_decimals.
        ls_styles-guid       = r_style.
        ls_styles-style      = lo_style.
        INSERT ls_styles INTO TABLE wt_styles.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_subclasses.
    DATA:
      lt_subclasses TYPE seor_inheritance_keys,
      ls_subclass   TYPE seor_inheritance_key,
      lr_classdescr TYPE REF TO cl_abap_classdescr.

    CALL FUNCTION 'SEO_CLASS_GET_ALL_SUBS'
      EXPORTING
        clskey             = is_clskey
      IMPORTING
        inhkeys            = lt_subclasses
      EXCEPTIONS
        class_not_existing = 1
        OTHERS             = 2.

    CHECK sy-subrc = 0.

    LOOP AT lt_subclasses INTO ls_subclass.
      lr_classdescr ?= cl_abap_classdescr=>describe_by_name( ls_subclass-clsname ).
      IF lr_classdescr->is_instantiatable( ) = abap_true.
        APPEND ls_subclass TO ct_classes.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD init_option.

    ws_option-filter = abap_true.
    ws_option-hidenc = abap_true.
    ws_option-subtot = abap_true.

  ENDMETHOD.
  METHOD loop_normal.
    DATA: l_row_int_end TYPE zexcel_cell_row,
          l_row_int     TYPE zexcel_cell_row,
          l_col_int     TYPE zexcel_cell_column,
          l_col_alpha   TYPE zexcel_cell_column_alpha,
          l_cell_value  TYPE zexcel_cell_value,
          l_s_color     TYPE abap_bool,
          lo_column     TYPE REF TO Lcl_excel_column,
          l_formula     TYPE zexcel_cell_formula,
          l_style       TYPE zexcel_cell_style,
          l_cells       TYPE i,
          l_count       TYPE i,
          l_table_row   TYPE i.

    FIELD-SYMBOLS: <fs_stab>   TYPE any,
                   <fs_tab>    TYPE STANDARD TABLE,
                   <fs_sfcat>  TYPE zexcel_s_converter_fcat,
                   <fs_fldval> TYPE any.

    ASSIGN wo_data->* TO <fs_tab> .

    DESCRIBE TABLE wt_fieldcatalog LINES l_cells.
    DESCRIBE TABLE <fs_tab> LINES l_count.
    l_cells = l_cells * l_count.

* It is better to loop column by column
    LOOP AT wt_fieldcatalog ASSIGNING <fs_sfcat>.
      l_row_int = i_row_int.
      l_col_int = i_col_int + <fs_sfcat>-position - 1.

*   Freeze panes
      IF <fs_sfcat>-fix_column = abap_true.
        ADD 1 TO r_freeze_col.
      ENDIF.
      l_s_color = abap_true.

      l_col_alpha = Lcl_excel_common=>convert_column2alpha( l_col_int ).

*   Only if the Header is required create it.
      IF ws_option-hidehd IS INITIAL.
        " First of all write column header
        l_cell_value = <fs_sfcat>-scrtext_m.
        wo_worksheet->set_cell( ip_column    = l_col_alpha
                                ip_row       = l_row_int
                                ip_value     = l_cell_value
                                ip_style     = <fs_sfcat>-style_hdr ).
        ADD 1 TO l_row_int.
      ENDIF.
      LOOP AT <fs_tab> ASSIGNING <fs_stab>.
        l_table_row = sy-tabix.
* Now the cell values
        ASSIGN COMPONENT <fs_sfcat>-columnname OF STRUCTURE <fs_stab> TO <fs_fldval>.
* Now let's write the cell values
        IF ws_layout-is_stripped = abap_true AND l_s_color = abap_true.
          l_style = get_color_style( i_row       = l_table_row
                                     i_fieldname = <fs_sfcat>-columnname
                                     i_style     = <fs_sfcat>-style_stripped  ).
          wo_worksheet->set_cell( ip_column    = l_col_alpha
                                  ip_row       = l_row_int
                                  ip_value     = <fs_fldval>
                                  ip_style     = l_style
                                  ip_conv_exit_length = ws_option-conv_exit_length ).
          CLEAR l_s_color.
        ELSE.
          l_style = get_color_style( i_row       = l_table_row
                                     i_fieldname = <fs_sfcat>-columnname
                                     i_style     = <fs_sfcat>-style_normal  ).
          wo_worksheet->set_cell( ip_column    = l_col_alpha
                                  ip_row       = l_row_int
                                  ip_value     = <fs_fldval>
                                  ip_style     = l_style
                                  ip_conv_exit_length = ws_option-conv_exit_length  ).
          l_s_color = abap_true.
        ENDIF.
        READ TABLE wt_filter TRANSPORTING NO FIELDS WITH TABLE KEY rownumber  = l_table_row
                                                                   columnname = <fs_sfcat>-columnname.
        IF sy-subrc = 0.
          wo_worksheet->get_cell( EXPORTING
                                     ip_column    = l_col_alpha
                                     ip_row       = l_row_int
                                  IMPORTING
                                     ep_value     = l_cell_value ).
          wo_autofilter->set_value( i_column = l_col_int
                                    i_value  = l_cell_value ).
        ENDIF.
        ADD 1 TO l_row_int.
      ENDLOOP.
* Now let's check for optimized
      IF <fs_sfcat>-is_optimized = abap_true .
        lo_column = wo_worksheet->get_column( ip_column = l_col_alpha ).
        lo_column->set_auto_size( ip_auto_size = abap_true ) .
      ENDIF.
* Now let's check for visible
      IF <fs_sfcat>-is_hidden = abap_true.
        lo_column = wo_worksheet->get_column( ip_column = l_col_alpha ).
        lo_column->set_visible( ip_visible = abap_false ) .
      ENDIF.
* Now let's check for total versus subtotal.
      IF <fs_sfcat>-totals_function IS NOT INITIAL.
        l_row_int_end = l_row_int - 1.

        l_formula = create_formular_total( i_row_int         = l_row_int_end
                                           i_column          = l_col_alpha
                                           i_totals_function = <fs_sfcat>-totals_function ).
        wo_worksheet->set_cell( ip_column    = l_col_alpha
                                ip_row       = l_row_int
                                ip_formula   = l_formula
                                ip_style     = <fs_sfcat>-style_total ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD loop_subtotal.

    DATA: l_row_int_start   TYPE zexcel_cell_row,
          l_row_int_end     TYPE zexcel_cell_row,
          l_row_int         TYPE zexcel_cell_row,
          l_col_int         TYPE zexcel_cell_column,
          l_col_alpha       TYPE zexcel_cell_column_alpha,
          l_col_alpha_start TYPE zexcel_cell_column_alpha,
          l_cell_value      TYPE zexcel_cell_value,
          l_s_color         TYPE abap_bool,
          lo_column         TYPE REF TO Lcl_excel_column,
          lo_row            TYPE REF TO Lcl_excel_row,
          l_formula         TYPE zexcel_cell_formula,
          l_style           TYPE zexcel_cell_style,
          l_text            TYPE string,
          ls_sort_values    TYPE SHRITEFUH64VYIPN5I4UIDBI776SE4,
          ls_subtotal_rows  TYPE SHRITEFUH64VYIPN5I4UIDBI777SE4,
          l_sort_level      TYPE int4,
          l_hidden          TYPE int4,
          l_line            TYPE i,
          l_cells           TYPE i,
          l_count           TYPE i,
          l_table_row       TYPE i,
          lt_fcat           TYPE zexcel_t_converter_fcat.

    FIELD-SYMBOLS: <fs_stab>    TYPE any,
                   <fs_tab>     TYPE STANDARD TABLE,
                   <fs_sfcat>   TYPE zexcel_s_converter_fcat,
                   <fs_fldval>  TYPE any,
                   <fs_sortval> TYPE any,
                   <fs_sortv>   TYPE SHRITEFUH64VYIPN5I4UIDBI776SE4.

    ASSIGN wo_data->* TO <fs_tab> .

    CLEAR: wt_sort_values,
           wt_subtotal_rows.

    DESCRIBE TABLE wt_fieldcatalog LINES l_cells.
    DESCRIBE TABLE <fs_tab> LINES l_count.
    l_cells = l_cells * l_count.

    READ TABLE <fs_tab> ASSIGNING <fs_stab> INDEX 1.
    IF sy-subrc = 0.
      l_row_int = i_row_int + 1.
      lt_fcat =  wt_fieldcatalog.
      SORT lt_fcat BY sort_level DESCENDING.
      LOOP AT lt_fcat ASSIGNING <fs_sfcat> WHERE is_subtotalled = abap_true.
        ASSIGN COMPONENT <fs_sfcat>-columnname OF STRUCTURE <fs_stab> TO <fs_fldval>.
        ls_sort_values-fieldname    = <fs_sfcat>-columnname.
        ls_sort_values-row_int      = l_row_int.
        ls_sort_values-sort_level   = <fs_sfcat>-sort_level.
        ls_sort_values-is_collapsed = <fs_sfcat>-is_collapsed.
        CREATE DATA ls_sort_values-value LIKE <fs_fldval>.
        ASSIGN ls_sort_values-value->* TO <fs_sortval>.
        <fs_sortval> =  <fs_fldval>.
        INSERT ls_sort_values INTO TABLE wt_sort_values.
      ENDLOOP.
    ENDIF.
    l_row_int = i_row_int.
* Let's check if we need to hide a sort level.
    DESCRIBE TABLE wt_sort_values LINES l_line.
    IF  l_line <= 1.
      CLEAR l_hidden.
    ELSE.
      LOOP AT wt_sort_values INTO ls_sort_values WHERE is_collapsed = abap_false.
        IF l_hidden < ls_sort_values-sort_level.
          l_hidden = ls_sort_values-sort_level.
        ENDIF.
      ENDLOOP.
    ENDIF.
    ADD 1 TO l_hidden. " As this is the first level we show.
* First loop without formular only addtional rows with subtotal text.
    LOOP AT <fs_tab> ASSIGNING <fs_stab>.
      ADD 1 TO l_row_int.  " 1 is for header row.
      l_row_int_start = l_row_int.
      SORT lt_fcat BY sort_level DESCENDING.
      LOOP AT lt_fcat ASSIGNING <fs_sfcat> WHERE is_subtotalled = abap_true.
        l_col_int   = i_col_int + <fs_sfcat>-position - 1.
        l_col_alpha = Lcl_excel_common=>convert_column2alpha( l_col_int ).
* Now the cell values
        ASSIGN COMPONENT <fs_sfcat>-columnname OF STRUCTURE <fs_stab> TO <fs_fldval>.
        IF sy-subrc = 0.
          READ TABLE wt_sort_values ASSIGNING <fs_sortv> WITH TABLE KEY fieldname = <fs_sfcat>-columnname.
          IF sy-subrc = 0.
            ASSIGN <fs_sortv>-value->* TO <fs_sortval>.
            IF <fs_sortval> <> <fs_fldval> OR <fs_sortv>-new = abap_true.
* First let's remmember the subtotal values as it has to appear later.
              ls_subtotal_rows-row_int       = l_row_int.
              ls_subtotal_rows-row_int_start = <fs_sortv>-row_int.
              ls_subtotal_rows-columnname    = <fs_sfcat>-columnname.
              INSERT ls_subtotal_rows INTO TABLE wt_subtotal_rows.
* Now let's write the subtotal line
              l_cell_value = create_text_subtotal( i_value = <fs_sortval>
                                     i_totals_function     = <fs_sfcat>-totals_function ).
              wo_worksheet->set_cell( ip_column    = l_col_alpha
                                      ip_row       = l_row_int
                                      ip_value     = l_cell_value
                                      ip_abap_type = cl_abap_typedescr=>typekind_string
                                      ip_style     = <fs_sfcat>-style_subtotal  ).
              lo_row = wo_worksheet->get_row( ip_row = l_row_int ).
              lo_row->set_outline_level( ip_outline_level = <fs_sfcat>-sort_level ) .
              IF <fs_sfcat>-is_collapsed = abap_true.
                IF <fs_sfcat>-sort_level >  l_hidden.
                  lo_row->set_visible( ip_visible =  abap_false ) .
                ENDIF.
                lo_row->set_collapsed( ip_collapsed =  <fs_sfcat>-is_collapsed ) .
              ENDIF.
* Now let's change the key
              ADD 1 TO l_row_int.
              <fs_sortval> =  <fs_fldval>.
              <fs_sortv>-new = abap_false.
              l_line = <fs_sortv>-sort_level.
              LOOP AT wt_sort_values ASSIGNING <fs_sortv> WHERE sort_level >= l_line.
                <fs_sortv>-row_int = l_row_int.
              ENDLOOP.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
    ADD 1 TO l_row_int.
    l_row_int_start = l_row_int.
    SORT lt_fcat BY sort_level DESCENDING.
    LOOP AT lt_fcat ASSIGNING <fs_sfcat> WHERE is_subtotalled = abap_true.
      l_col_int   = i_col_int + <fs_sfcat>-position - 1.
      l_col_alpha = Lcl_excel_common=>convert_column2alpha( l_col_int ).
      READ TABLE wt_sort_values ASSIGNING <fs_sortv> WITH TABLE KEY fieldname = <fs_sfcat>-columnname.
      IF sy-subrc = 0.
        ASSIGN <fs_sortv>-value->* TO <fs_sortval>.
        ls_subtotal_rows-row_int       = l_row_int.
        ls_subtotal_rows-row_int_start = <fs_sortv>-row_int.
        ls_subtotal_rows-columnname    = <fs_sfcat>-columnname.
        INSERT ls_subtotal_rows INTO TABLE wt_subtotal_rows.
* First let's write the value as it has to appear.
        l_cell_value = create_text_subtotal( i_value = <fs_sortval>
                               i_totals_function     = <fs_sfcat>-totals_function ).
        wo_worksheet->set_cell( ip_column    = l_col_alpha
                                ip_row       = l_row_int
                                ip_value     = l_cell_value
                                ip_abap_type = cl_abap_typedescr=>typekind_string
                                ip_style     = <fs_sfcat>-style_subtotal ).

        l_sort_level = <fs_sfcat>-sort_level.
        lo_row = wo_worksheet->get_row( ip_row = l_row_int ).
        lo_row->set_outline_level( ip_outline_level = l_sort_level ) .
        IF <fs_sfcat>-is_collapsed = abap_true.
          IF <fs_sfcat>-sort_level >  l_hidden.
            lo_row->set_visible( ip_visible =  abap_false ) .
          ENDIF.
          lo_row->set_collapsed( ip_collapsed =  <fs_sfcat>-is_collapsed ) .
        ENDIF.
        ADD 1 TO l_row_int.
      ENDIF.
    ENDLOOP.
* Let's write the Grand total
    l_sort_level = 0.
    lo_row = wo_worksheet->get_row( ip_row = l_row_int ).
    lo_row->set_outline_level( ip_outline_level = l_sort_level ) .
*  lo_row_dim->set_collapsed( ip_collapsed =  <fs_sfcat>-is_collapsed ) . Not on grand total

    l_text    = create_text_subtotal( i_value = 'Grand'(002)
                                      i_totals_function     = <fs_sfcat>-totals_function ).

    l_col_alpha_start = Lcl_excel_common=>convert_column2alpha( i_col_int ).
    wo_worksheet->set_cell( ip_column    = l_col_alpha_start
                            ip_row       = l_row_int
                            ip_value     = l_text
                            ip_abap_type = cl_abap_typedescr=>typekind_string
                            ip_style     = <fs_sfcat>-style_subtotal ).

* It is better to loop column by column second time around
* Second loop with formular and data.
    LOOP AT wt_fieldcatalog ASSIGNING <fs_sfcat>.
      l_row_int = i_row_int.
      l_col_int = i_col_int + <fs_sfcat>-position - 1.
* Freeze panes
      IF <fs_sfcat>-fix_column = abap_true.
        ADD 1 TO r_freeze_col.
      ENDIF.
      l_s_color = abap_true.
      l_col_alpha = Lcl_excel_common=>convert_column2alpha( l_col_int ).
      " First of all write column header
      l_cell_value = <fs_sfcat>-scrtext_m.
      wo_worksheet->set_cell( ip_column    = l_col_alpha
                              ip_row       = l_row_int
                              ip_value     = l_cell_value
                              ip_abap_type = cl_abap_typedescr=>typekind_string
                              ip_style     = <fs_sfcat>-style_hdr ).
      ADD 1 TO l_row_int.
      LOOP AT <fs_tab> ASSIGNING <fs_stab>.
        l_table_row = sy-tabix.
* Now the cell values
        ASSIGN COMPONENT <fs_sfcat>-columnname OF STRUCTURE <fs_stab> TO <fs_fldval>.
* Let's check for subtotal lines
        DO.
          READ TABLE wt_subtotal_rows TRANSPORTING NO FIELDS WITH TABLE KEY row_int = l_row_int.
          IF sy-subrc = 0.
            IF <fs_sfcat>-is_subtotalled = abap_false AND
               <fs_sfcat>-totals_function IS NOT INITIAL.
              DO.
                READ TABLE wt_subtotal_rows INTO ls_subtotal_rows WITH TABLE KEY row_int    = l_row_int.
                IF sy-subrc = 0.
                  l_row_int_start = ls_subtotal_rows-row_int_start.
                  l_row_int_end   = l_row_int - 1.

                  l_formula = create_formular_subtotal( i_row_int_start   = l_row_int_start
                                                        i_row_int_end     = l_row_int_end
                                                        i_column          = l_col_alpha
                                                        i_totals_function = <fs_sfcat>-totals_function ).
                  wo_worksheet->set_cell( ip_column    = l_col_alpha
                                          ip_row       = l_row_int
                                          ip_formula   = l_formula
                                          ip_style     = <fs_sfcat>-style_subtotal ).
                  IF <fs_sfcat>-is_collapsed = abap_true.
                    lo_row = wo_worksheet->get_row( ip_row = l_row_int ).
                    lo_row->set_collapsed( ip_collapsed =  <fs_sfcat>-is_collapsed ).
                    IF <fs_sfcat>-sort_level >  l_hidden.
                      lo_row->set_visible( ip_visible =  abap_false ) .
                    ENDIF.
                  ENDIF.
                  ADD 1 TO l_row_int.
                ELSE.
                  EXIT.
                ENDIF.
              ENDDO.
            ELSE.
              ADD 1 TO l_row_int.
            ENDIF.
          ELSE.
            EXIT.
          ENDIF.
        ENDDO.
* Let's set the row dimension values
        lo_row = wo_worksheet->get_row( ip_row = l_row_int ).
        lo_row->set_outline_level( ip_outline_level = ws_layout-max_subtotal_level ) .
        IF <fs_sfcat>-is_collapsed  = abap_true.
          lo_row->set_visible( ip_visible =  abap_false ) .
          lo_row->set_collapsed( ip_collapsed =  <fs_sfcat>-is_collapsed ) .
        ENDIF.
* Now let's write the cell values
        IF ws_layout-is_stripped = abap_true AND l_s_color = abap_true.
          l_style = get_color_style( i_row       = l_table_row
                                     i_fieldname = <fs_sfcat>-columnname
                                     i_style     = <fs_sfcat>-style_stripped  ).
          wo_worksheet->set_cell( ip_column    = l_col_alpha
                                  ip_row       = l_row_int
                                  ip_value     = <fs_fldval>
                                  ip_style     = l_style
                                  ip_conv_exit_length = ws_option-conv_exit_length ).
          CLEAR l_s_color.
        ELSE.
          l_style = get_color_style( i_row       = l_table_row
                                     i_fieldname = <fs_sfcat>-columnname
                                     i_style     = <fs_sfcat>-style_normal  ).
          wo_worksheet->set_cell( ip_column    = l_col_alpha
                                  ip_row       = l_row_int
                                  ip_value     = <fs_fldval>
                                  ip_style     = l_style
                                  ip_conv_exit_length = ws_option-conv_exit_length   ).
          l_s_color = abap_true.
        ENDIF.
        READ TABLE wt_filter TRANSPORTING NO FIELDS WITH TABLE KEY rownumber  = l_table_row
                                                                   columnname = <fs_sfcat>-columnname.
        IF sy-subrc = 0.
          wo_worksheet->get_cell( EXPORTING
                                     ip_column    = l_col_alpha
                                     ip_row       = l_row_int
                                  IMPORTING
                                     ep_value     = l_cell_value ).
          wo_autofilter->set_value( i_column = l_col_int
                                    i_value  = l_cell_value ).
        ENDIF.
        ADD 1 TO l_row_int.
      ENDLOOP.
* Let's check for subtotal lines
      DO.
        READ TABLE wt_subtotal_rows TRANSPORTING NO FIELDS WITH TABLE KEY row_int = l_row_int.
        IF sy-subrc = 0.
          IF <fs_sfcat>-is_subtotalled = abap_false AND
             <fs_sfcat>-totals_function IS NOT INITIAL.
            DO.
              READ TABLE wt_subtotal_rows INTO ls_subtotal_rows WITH TABLE KEY row_int    = l_row_int.
              IF sy-subrc = 0.
                l_row_int_start = ls_subtotal_rows-row_int_start.
                l_row_int_end   = l_row_int - 1.

                l_formula = create_formular_subtotal( i_row_int_start   = l_row_int_start
                                                      i_row_int_end     = l_row_int_end
                                                      i_column          = l_col_alpha
                                                      i_totals_function = <fs_sfcat>-totals_function ).
                wo_worksheet->set_cell( ip_column    = l_col_alpha
                                        ip_row       = l_row_int
                                        ip_formula   = l_formula
                                        ip_style     = <fs_sfcat>-style_subtotal ).
                IF <fs_sfcat>-is_collapsed = abap_true.
                  lo_row = wo_worksheet->get_row( ip_row = l_row_int ).
                  lo_row->set_collapsed( ip_collapsed =  <fs_sfcat>-is_collapsed ).
                ENDIF.
                ADD 1 TO l_row_int.
              ELSE.
                EXIT.
              ENDIF.
            ENDDO.
          ELSE.
            ADD 1 TO l_row_int.
          ENDIF.
        ELSE.
          EXIT.
        ENDIF.
      ENDDO.
* Now let's check for Grand total
      IF <fs_sfcat>-is_subtotalled = abap_false AND
         <fs_sfcat>-totals_function IS NOT INITIAL.
        l_row_int_start = i_row_int + 1.
        l_row_int_end   = l_row_int - 1.

        l_formula = create_formular_subtotal( i_row_int_start   = l_row_int_start
                                              i_row_int_end     = l_row_int_end
                                              i_column          = l_col_alpha
                                              i_totals_function = <fs_sfcat>-totals_function ).
        wo_worksheet->set_cell( ip_column    = l_col_alpha
                                ip_row       = l_row_int
                                ip_formula   = l_formula
                                ip_style     = <fs_sfcat>-style_subtotal ).
      ENDIF.
* Now let's check for optimized
      IF <fs_sfcat>-is_optimized = abap_true.
        lo_column = wo_worksheet->get_column( ip_column = l_col_alpha ).
        lo_column->set_auto_size( ip_auto_size = abap_true ) .
      ENDIF.
* Now let's check for visible
      IF <fs_sfcat>-is_hidden = abap_true.
        lo_column = wo_worksheet->get_column( ip_column = l_col_alpha ).
        lo_column->set_visible( ip_visible = abap_false ) .
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD open_file.
    DATA: l_bytecount TYPE i,
          lt_file     TYPE solix_tab,
          l_dir       TYPE string.

    FIELD-SYMBOLS: <fs_data> TYPE ANY TABLE.

    ASSIGN wo_data->* TO <fs_data>.

    IF wo_excel IS BOUND.
      get_file( IMPORTING e_bytecount  = l_bytecount
                          et_file      = lt_file ) .

      l_dir =  create_path( ) .

      cl_gui_frontend_services=>gui_download( EXPORTING bin_filesize = l_bytecount
                                                        filename     = l_dir
                                                        filetype     = 'BIN'
                                               CHANGING data_tab     = lt_file ).
      cl_gui_frontend_services=>execute(
        EXPORTING
          document               = l_dir
        EXCEPTIONS
          cntl_error             = 1
          error_no_gui           = 2
          bad_parameter          = 3
          file_not_found         = 4
          path_not_found         = 5
          file_extension_unknown = 6
          error_execute_failed   = 7
          synchronous_failed     = 8
          not_supported_by_gui   = 9
             ).
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                   WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

    ENDIF.


  ENDMETHOD.
  METHOD set_autofilter_area.
    DATA: ls_area   TYPE zexcel_s_autofilter_area,
          l_lines   TYPE i,
          lt_values TYPE zexcel_t_autofilter_values,
          ls_values TYPE zexcel_s_autofilter_values.

* Let's check for filter.
    IF wo_autofilter IS BOUND.
      ls_area-row_start = 1.
      lt_values = wo_autofilter->get_values( ) .
      SORT lt_values BY column ASCENDING.
      DESCRIBE TABLE lt_values LINES l_lines.
      READ TABLE lt_values INTO ls_values INDEX 1.
      IF sy-subrc = 0.
        ls_area-col_start = ls_values-column.
      ENDIF.
      READ TABLE lt_values INTO ls_values INDEX l_lines.
      IF sy-subrc = 0.
        ls_area-col_end = ls_values-column.
      ENDIF.
      wo_autofilter->set_filter_area( is_area = ls_area ) .
    ENDIF.

  ENDMETHOD.
  METHOD set_cell_format.
    DATA:  l_format    TYPE zexcel_number_format.

    CLEAR r_format.
    CASE i_inttype.
      WHEN cl_abap_typedescr=>typekind_date.
        r_format = wo_worksheet->get_default_excel_date_format( ).
      WHEN cl_abap_typedescr=>typekind_time.
        r_format = wo_worksheet->get_default_excel_time_format( ).
      WHEN cl_abap_typedescr=>typekind_float OR cl_abap_typedescr=>typekind_packed OR
           cl_abap_typedescr=>typekind_decfloat OR
           cl_abap_typedescr=>typekind_decfloat16 OR
           cl_abap_typedescr=>typekind_decfloat34.
        IF i_decimals > 0 .
          l_format = '#,##0.'.
          DO i_decimals TIMES.
            CONCATENATE l_format '0' INTO l_format.
          ENDDO.
          r_format = l_format.
        ENDIF.
      WHEN cl_abap_typedescr=>typekind_int OR cl_abap_typedescr=>typekind_int1 OR cl_abap_typedescr=>typekind_int2.
        r_format = '#,##0'.
    ENDCASE.

  ENDMETHOD.
  METHOD set_fieldcatalog.

    DATA: lr_data        TYPE REF TO data,
          lo_structdescr TYPE REF TO cl_abap_structdescr,
          lt_dfies       TYPE ddfields,
          ls_dfies       TYPE dfies.
    DATA: ls_fcat             TYPE zexcel_s_converter_fcat.

    FIELD-SYMBOLS: <fs_tab>         TYPE ANY TABLE.

    ASSIGN wo_data->* TO <fs_tab> .

    CREATE DATA lr_data LIKE LINE OF <fs_tab>.

    lo_structdescr ?= cl_abap_structdescr=>describe_by_data_ref( lr_data ).

    lt_dfies = Lcl_excel_common=>describe_structure( io_struct = lo_structdescr ).

    LOOP AT lt_dfies INTO ls_dfies.
      MOVE-CORRESPONDING ls_dfies TO ls_fcat.
      ls_fcat-columnname = ls_dfies-fieldname.
      INSERT ls_fcat INTO TABLE wt_fieldcatalog.
    ENDLOOP.

    clean_fieldcatalog( ).

  ENDMETHOD.
  METHOD set_option.

    IF ws_indx-begdt IS INITIAL.
      ws_indx-begdt = sy-datum.
    ENDIF.

    ws_indx-aedat = sy-datum.
    ws_indx-usera = sy-uname.
    ws_indx-pgmid = sy-cprog.

    EXPORT p1 = is_option TO DATABASE indx(xl) FROM ws_indx ID ws_indx-srtfd.

    IF sy-subrc = 0.
      ws_option = is_option.
    ENDIF.

  ENDMETHOD.
  METHOD write_file.
    DATA: l_bytecount TYPE i,
          lt_file     TYPE solix_tab,
          l_dir       TYPE string.

    FIELD-SYMBOLS: <fs_data> TYPE ANY TABLE.

    ASSIGN wo_data->* TO <fs_data>.

    IF wo_excel IS BOUND.
      get_file( IMPORTING e_bytecount  = l_bytecount
                          et_file      = lt_file ) .
      IF i_path IS INITIAL.
        l_dir =  create_path( ) .
      ELSE.
        l_dir = i_path.
      ENDIF.
      cl_gui_frontend_services=>gui_download( EXPORTING bin_filesize = l_bytecount
                                                        filename     = l_dir
                                                        filetype     = 'BIN'
                                               CHANGING data_tab     = lt_file ).
    ENDIF.
  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER implementation

*>>>>>>> LCL_EXCEL_CONVERTER_ALV <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter_alv=======ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter_alv=======ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER_ALV implementation.
*"* method's implementations
*include methods.
  METHOD apply_sort.
    DATA: lt_otab TYPE abap_sortorder_tab,
          ls_otab TYPE abap_sortorder.

    FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE,
                   <fs_sort>  TYPE lvc_s_sort.

    CREATE DATA eo_table LIKE it_table.
    ASSIGN eo_table->* TO <fs_table>.

    <fs_table> = it_table.

    SORT wt_sort BY spos.
    LOOP AT wt_sort ASSIGNING <fs_sort>.
      IF <fs_sort>-up = abap_true.
        ls_otab-name = <fs_sort>-fieldname.
        ls_otab-descending = abap_false.
*     ls_otab-astext     = abap_true. " not only text fields
        INSERT ls_otab INTO TABLE lt_otab.
      ENDIF.
      IF <fs_sort>-down = abap_true.
        ls_otab-name = <fs_sort>-fieldname.
        ls_otab-descending = abap_true.
*     ls_otab-astext     = abap_true. " not only text fields
        INSERT ls_otab INTO TABLE lt_otab.
      ENDIF.
    ENDLOOP.
    IF lt_otab IS NOT INITIAL.
      SORT <fs_table> BY (lt_otab).
    ENDIF.

  ENDMETHOD.
  METHOD class_constructor.
* let's fill the color conversion routines.
    DATA: ls_color TYPE SHRITEFUH64VYIPN5I4UIDBJAACSE4.
* 0 all combination the same
    ls_color-col       = 0.
    ls_color-int       = 0.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 0.
    ls_color-int       = 0.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 0.
    ls_color-int       = 1.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 0.
    ls_color-int       = 1.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

* Blue
    ls_color-col       = 1.
    ls_color-int       = 0.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFB0E4FC'. " 176 228 252 blue
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 1.
    ls_color-int       = 0.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFB0E4FC'. " 176 228 252 blue
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 1.
    ls_color-int       = 1.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FF5FCBFE'. " 095 203 254 Int blue
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 1.
    ls_color-int       = 1.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FF5FCBFE'. " 095 203 254
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255
    INSERT ls_color INTO TABLE wt_colors.

* Gray
    ls_color-col       = 2.
    ls_color-int       = 0.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'.
    ls_color-fillcolor = 'FFE5EAF0'. " 229 234 240 gray
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 2.
    ls_color-int       = 0.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFE5EAF0'. " 229 234 240 gray
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 2.
    ls_color-int       = 1.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFD8E8F4'. " 216 234 244 int gray
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 2.
    ls_color-int       = 1.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFD8E8F4'. " 216 234 244 int gray
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

*Yellow
    ls_color-col       = 3.
    ls_color-int       = 0.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFFEFEB8'. " 254 254 184 yellow
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 3.
    ls_color-int       = 0.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFFEFEB8'. " 254 254 184 yellow
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 3.
    ls_color-int       = 1.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFF9ED5D'. " 249 237 093 int yellow
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 3.
    ls_color-int       = 1.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFF9ED5D'. " 249 237 093 int yellow
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

* light blue
    ls_color-col       = 4.
    ls_color-int       = 0.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFCEE7FB'. " 206 231 251 light blue
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 4.
    ls_color-int       = 0.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFCEE7FB'. " 206 231 251 light blue
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 4.
    ls_color-int       = 1.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FF9ACCEF'. " 154 204 239 int light blue
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 4.
    ls_color-int       = 1.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FF9ACCEF'. " 154 204 239 int light blue
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

* Green
    ls_color-col       = 5.
    ls_color-int       = 0.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFCEF8AE'. " 206 248 174 Green
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 5.
    ls_color-int       = 0.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFCEF8AE'. " 206 248 174 Green
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 5.
    ls_color-int       = 1.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FF7AC769'. " 122 199 105 int Green
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 5.
    ls_color-int       = 1.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FF7AC769'. " 122 199 105 int Green
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

* Red
    ls_color-col       = 6.
    ls_color-int       = 0.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFFDBBBC'. " 253 187 188 Red
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 6.
    ls_color-int       = 0.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFFDBBBC'. " 253 187 188 Red
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 6.
    ls_color-int       = 1.
    ls_color-inv       = 0.
    ls_color-fontcolor = 'FF000000'. " 000 000 000 Black
    ls_color-fillcolor = 'FFFB6B6B'. " 251 107 107 int Red
    INSERT ls_color INTO TABLE wt_colors.

    ls_color-col       = 6.
    ls_color-int       = 1.
    ls_color-inv       = 1.
    ls_color-fontcolor = 'FFFB6B6B'. " 251 107 107 int Red
    ls_color-fillcolor = 'FFFFFFFF'. " 255 255 255 White
    INSERT ls_color INTO TABLE wt_colors.

  ENDMETHOD.
  METHOD get_color.
    DATA: ls_con_col TYPE zexcel_s_converter_col,
          ls_color   TYPE SHRITEFUH64VYIPN5I4UIDBJAACSE4,
          l_line     TYPE i,
          l_color(4) TYPE c.
    FIELD-SYMBOLS: <fs_tab>  TYPE STANDARD TABLE,
                   <fs_stab> TYPE any,
                   <fs>      TYPE any,
                   <ft_slis> TYPE STANDARD TABLE,
                   <fs_slis> TYPE any.

* Loop trough the table to set the color properties of each line. The color properties field is
* Char 4 and the characters is set as follows:
* Char 1 = C = This is a color property
* Char 2 = 6 = Color code (1 - 7)
* Char 3 = Intensified on/of = 1 = on
* Char 4 = Inverse display = 0 = of

    ASSIGN io_table->* TO <fs_tab>.

    IF ws_layo-info_fname IS NOT INITIAL OR
       ws_layo-ctab_fname IS NOT INITIAL.
      LOOP AT <fs_tab> ASSIGNING <fs_stab>.
        l_line = sy-tabix.
        IF ws_layo-info_fname IS NOT INITIAL.
          ASSIGN COMPONENT ws_layo-info_fname OF STRUCTURE <fs_stab> TO <fs>.
          IF sy-subrc = 0 AND <fs> IS NOT INITIAL.
            l_color = <fs>.
            IF l_color(1) = 'C'.
              READ TABLE wt_colors INTO ls_color WITH TABLE KEY col = l_color+1(1)
                                                                int = l_color+2(1)
                                                                inv = l_color+3(1).
              IF sy-subrc = 0.
                ls_con_col-rownumber  = l_line.
                ls_con_col-columnname = space.
                ls_con_col-fontcolor  = ls_color-fontcolor.
                ls_con_col-fillcolor  = ls_color-fillcolor.
                INSERT ls_con_col INTO TABLE et_colors.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
        IF ws_layo-ctab_fname IS NOT INITIAL.

          ASSIGN COMPONENT ws_layo-ctab_fname OF STRUCTURE <fs_stab> TO <ft_slis>.
          IF sy-subrc = 0.
            LOOP AT <ft_slis> ASSIGNING <fs_slis>.
              ASSIGN COMPONENT 'COLOR' OF STRUCTURE <fs_slis> TO <fs>.
              IF sy-subrc = 0.
                IF <fs> IS NOT INITIAL.
                  FIELD-SYMBOLS: <col>      TYPE any,
                                 <int>      TYPE any,
                                 <inv>      TYPE any,
                                 <fname>    TYPE any,
                                 <nokeycol> TYPE any.
                  ASSIGN COMPONENT 'COL' OF STRUCTURE <fs> TO <col>.
                  ASSIGN COMPONENT 'INT' OF STRUCTURE <fs> TO <int>.
                  ASSIGN COMPONENT 'INV' OF STRUCTURE <fs> TO <inv>.
                  READ TABLE wt_colors INTO ls_color WITH TABLE KEY col = <col>
                                                                    int = <int>
                                                                    inv = <inv>.
                  IF sy-subrc = 0.
                    ls_con_col-rownumber  = l_line.
                    ASSIGN COMPONENT 'FNAME' OF STRUCTURE <fs_slis> TO <fname>.
                    IF sy-subrc NE 0.
                      ASSIGN COMPONENT 'FIELDNAME' OF STRUCTURE <fs_slis> TO <fname>.
                      IF sy-subrc EQ 0.
                        ls_con_col-columnname = <fname>.
                      ENDIF.
                    ELSE.
                      ls_con_col-columnname = <fname>.
                    ENDIF.

                    ls_con_col-fontcolor  = ls_color-fontcolor.
                    ls_con_col-fillcolor  = ls_color-fillcolor.
                    ASSIGN COMPONENT 'NOKEYCOL' OF STRUCTURE <fs_slis> TO <nokeycol>.
                    IF sy-subrc EQ 0.
                      ls_con_col-nokeycol   = <nokeycol>.
                    ENDIF.
                    INSERT ls_con_col INTO TABLE et_colors.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD get_filter.
    DATA: ls_filt   TYPE lvc_s_filt,
          l_line    TYPE i,
          ls_filter TYPE zexcel_s_converter_fil.
    DATA: lo_addit          TYPE REF TO cl_abap_elemdescr,
          lt_components_tab TYPE cl_abap_structdescr=>component_table,
          ls_components     TYPE abap_componentdescr,
          lo_table          TYPE REF TO cl_abap_tabledescr,
          lo_struc          TYPE REF TO cl_abap_structdescr,
          lo_trange         TYPE REF TO data,
          lo_srange         TYPE REF TO data,
          lo_ltabdata       TYPE REF TO data.

    FIELD-SYMBOLS: <fs_tab>    TYPE STANDARD TABLE,
                   <fs_ltab>   TYPE STANDARD TABLE,
                   <fs_stab>   TYPE any,
                   <fs>        TYPE any,
                   <fs1>       TYPE any,
                   <fs_srange> TYPE any,
                   <fs_trange> TYPE STANDARD TABLE.

    IF ws_option-filter = abap_false.
      CLEAR et_filter.
      RETURN.
    ENDIF.

    ASSIGN xo_table->* TO <fs_tab>.

    CREATE DATA lo_ltabdata LIKE <fs_tab>.
    ASSIGN lo_ltabdata->* TO <fs_ltab>.

    LOOP AT wt_filt INTO ls_filt.
      LOOP AT <fs_tab> ASSIGNING <fs_stab>.
        l_line = sy-tabix.
        ASSIGN COMPONENT ls_filt-fieldname OF STRUCTURE <fs_stab> TO <fs>.
        IF sy-subrc = 0.
          IF l_line = 1.
            CLEAR lt_components_tab.
            ls_components-name   = 'SIGN'.
            lo_addit            ?= cl_abap_typedescr=>describe_by_data( ls_filt-sign ).
            ls_components-type   = lo_addit           .
            INSERT ls_components INTO TABLE lt_components_tab.
            ls_components-name   = 'OPTION'.
            lo_addit            ?= cl_abap_typedescr=>describe_by_data( ls_filt-option ).
            ls_components-type   = lo_addit           .
            INSERT ls_components INTO TABLE lt_components_tab.
            ls_components-name   = 'LOW'.
            lo_addit            ?= cl_abap_typedescr=>describe_by_data( <fs> ).
            ls_components-type   = lo_addit           .
            INSERT ls_components INTO TABLE lt_components_tab.
            ls_components-name   = 'HIGH'.
            lo_addit            ?= cl_abap_typedescr=>describe_by_data( <fs> ).
            ls_components-type   = lo_addit           .
            INSERT ls_components INTO TABLE lt_components_tab.
            "create new line type
            TRY.
                lo_struc = cl_abap_structdescr=>create( p_components = lt_components_tab
                                                        p_strict     = abap_false ).
              CATCH cx_sy_struct_creation.
                CONTINUE.
            ENDTRY.
            lo_table = cl_abap_tabledescr=>create( lo_struc ).

            CREATE DATA lo_trange  TYPE HANDLE lo_table.
            CREATE DATA lo_srange  TYPE HANDLE lo_struc.

            ASSIGN lo_trange->* TO <fs_trange>.
            ASSIGN lo_srange->* TO <fs_srange>.
          ENDIF.
          CLEAR <fs_trange>.
          ASSIGN COMPONENT 'SIGN'   OF STRUCTURE  <fs_srange> TO <fs1>.
          <fs1> = ls_filt-sign.
          ASSIGN COMPONENT 'OPTION' OF STRUCTURE  <fs_srange> TO <fs1>.
          <fs1> = ls_filt-option.
          ASSIGN COMPONENT 'LOW'   OF STRUCTURE  <fs_srange> TO <fs1>.
          <fs1> = ls_filt-low.
          ASSIGN COMPONENT 'HIGH'   OF STRUCTURE  <fs_srange> TO <fs1>.
          <fs1> = ls_filt-high.
          INSERT <fs_srange> INTO TABLE <fs_trange>.
          IF <fs> IN <fs_trange>.
            IF ws_option-filter = abap_true.
              ls_filter-rownumber   = l_line.
              ls_filter-columnname  = ls_filt-fieldname.
              INSERT ls_filter INTO TABLE et_filter.
            ELSE.
              INSERT <fs_stab> INTO TABLE <fs_ltab>.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDLOOP.
      IF ws_option-filter = abap_undefined.
        <fs_tab> = <fs_ltab>.
        CLEAR <fs_ltab>.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD update_catalog.
    DATA: ls_fieldcatalog TYPE zexcel_s_converter_fcat,
          ls_fcat         TYPE lvc_s_fcat,
          ls_sort         TYPE lvc_s_sort,
          l_decimals      TYPE lvc_decmls.

    FIELD-SYMBOLS: <fs_scat> TYPE zexcel_s_converter_fcat.

    IF ws_layo-zebra IS NOT INITIAL.
      cs_layout-is_stripped = abap_true.
    ENDIF.
    IF ws_layo-no_keyfix IS INITIAL OR
       ws_layo-no_keyfix = '0'.
      cs_layout-is_fixed = abap_true.
    ENDIF.

    LOOP AT wt_fcat INTO ls_fcat.
      CLEAR: ls_fieldcatalog,
             l_decimals.
      CASE ws_option-hidenc.
        WHEN abap_false.     " We make hiden columns visible
          CLEAR ls_fcat-no_out.
        WHEN abap_true.
* We convert column and hide it.
        WHEN abap_undefined. "We don't convert hiden columns
          IF ls_fcat-no_out = abap_true.
            ls_fcat-tech = abap_true.
          ENDIF.
      ENDCASE.
      IF ls_fcat-tech = abap_false.
        ls_fieldcatalog-tabname         = ls_fcat-tabname.
        ls_fieldcatalog-fieldname       = ls_fcat-fieldname .
        ls_fieldcatalog-columnname      = ls_fcat-fieldname .
        ls_fieldcatalog-position        = ls_fcat-col_pos.
        ls_fieldcatalog-col_id          = ls_fcat-col_id.
        ls_fieldcatalog-convexit        = ls_fcat-convexit.
        ls_fieldcatalog-inttype         = ls_fcat-inttype.
        ls_fieldcatalog-scrtext_s       = ls_fcat-scrtext_s .
        ls_fieldcatalog-scrtext_m       = ls_fcat-scrtext_m .
        ls_fieldcatalog-scrtext_l       = ls_fcat-scrtext_l.
        l_decimals = ls_fcat-decimals_o.
        IF l_decimals IS NOT INITIAL.
          ls_fieldcatalog-decimals = l_decimals.
        ELSE.
          ls_fieldcatalog-decimals = ls_fcat-decimals .
        ENDIF.
        CASE ws_option-subtot.
          WHEN abap_false.     " We ignore subtotals
            CLEAR ls_fcat-do_sum.
          WHEN abap_true.      " We convert subtotals and detail

          WHEN abap_undefined. " We should only take subtotals and displayed detail
* for now abap_true
        ENDCASE.
        CASE ls_fcat-do_sum.
          WHEN abap_true.
            ls_fieldcatalog-totals_function =  Lcl_excel_table=>totals_function_sum.
          WHEN 'A'.
            ls_fieldcatalog-totals_function =  Lcl_excel_table=>totals_function_min.
          WHEN 'B' .
            ls_fieldcatalog-totals_function =  Lcl_excel_table=>totals_function_max.
          WHEN 'C' .
            ls_fieldcatalog-totals_function =  Lcl_excel_table=>totals_function_average.
          WHEN OTHERS.
            CLEAR ls_fieldcatalog-totals_function .
        ENDCASE.
        ls_fieldcatalog-fix_column       = ls_fcat-fix_column.
        IF ws_layo-cwidth_opt IS INITIAL.
          IF ls_fcat-col_opt IS NOT INITIAL.
            ls_fieldcatalog-is_optimized = abap_true.
          ENDIF.
        ELSE.
          ls_fieldcatalog-is_optimized = abap_true.
        ENDIF.
        IF ls_fcat-no_out IS NOT INITIAL.
          ls_fieldcatalog-is_hidden = abap_true.
          ls_fieldcatalog-position  = ls_fieldcatalog-col_id. " We hide based on orginal data structure
        ENDIF.
* Alignment in each cell
        CASE ls_fcat-just.
          WHEN 'R'.
            ls_fieldcatalog-alignment = Lcl_excel_style_alignment=>c_horizontal_right.
          WHEN 'L'.
            ls_fieldcatalog-alignment = Lcl_excel_style_alignment=>c_horizontal_left.
          WHEN 'C'.
            ls_fieldcatalog-alignment = Lcl_excel_style_alignment=>c_horizontal_center.
          WHEN OTHERS.
            CLEAR ls_fieldcatalog-alignment.
        ENDCASE.
* Check for subtotals.
        READ TABLE wt_sort INTO ls_sort WITH KEY fieldname = ls_fcat-fieldname.
        IF sy-subrc = 0 AND  ws_option-subtot <> abap_false.
          ls_fieldcatalog-sort_level      = 0 .
          ls_fieldcatalog-is_subtotalled  = ls_sort-subtot.
          ls_fieldcatalog-is_collapsed    = ls_sort-expa.
          IF ls_fieldcatalog-is_subtotalled = abap_true.
            ls_fieldcatalog-sort_level      = ls_sort-spos.
            ls_fieldcatalog-totals_function = Lcl_excel_table=>totals_function_sum. " we need function for text
          ENDIF.
        ENDIF.
        APPEND ls_fieldcatalog TO ct_fieldcatalog.
      ENDIF.
    ENDLOOP.

    SORT ct_fieldcatalog BY sort_level ASCENDING.
    cs_layout-max_subtotal_level  = 0.
    LOOP AT ct_fieldcatalog ASSIGNING <fs_scat> WHERE sort_level > 0.
      cs_layout-max_subtotal_level = cs_layout-max_subtotal_level + 1.
      <fs_scat>-sort_level = cs_layout-max_subtotal_level.
    ENDLOOP.

  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER_ALV implementation

*>>>>>>> LCL_EXCEL_CONVERTER_ALV_GRID <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter_alv_grid==ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter_alv_grid==ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER_ALV_GRID implementation.
*"* method's implementations
*include methods.
  METHOD Lif_excel_converter~can_convert_object.
    DATA: lo_alv TYPE REF TO cl_gui_alv_grid.

    TRY.
        lo_alv ?= io_object.
      CATCH cx_sy_move_cast_error .
        RAISE EXCEPTION TYPE Lcx_excel.
    ENDTRY.

  ENDMETHOD.
  METHOD Lif_excel_converter~create_fieldcatalog.
    DATA: lo_alv TYPE REF TO cl_gui_alv_grid.

    Lif_excel_converter~can_convert_object( io_object = io_object ).

    ws_option = is_option.

    lo_alv ?= io_object.

    CLEAR: es_layout,
           et_fieldcatalog.

    IF lo_alv IS BOUND.
      lo_alv->get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = wt_fcat ).
      lo_alv->get_frontend_layout( IMPORTING es_layout = ws_layo ).
      lo_alv->get_sort_criteria( IMPORTING et_sort = wt_sort ) .
      lo_alv->get_filter_criteria( IMPORTING et_filter = wt_filt ) .

      apply_sort( EXPORTING it_table = it_table
                  IMPORTING eo_table = eo_table ) .

      get_color( EXPORTING io_table    = eo_table
                 IMPORTING et_colors   = et_colors ) .

      get_filter( IMPORTING et_filter  = et_filter
                  CHANGING  xo_table   = eo_table  ) .

      update_catalog( CHANGING  cs_layout       = es_layout
                                ct_fieldcatalog = et_fieldcatalog ).
    ENDIF.
  ENDMETHOD.
  METHOD Lif_excel_converter~get_supported_class.
    rv_supported_class = 'CL_GUI_ALV_GRID'.
  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER_ALV_GRID implementation

*>>>>>>> LCL_EXCEL_CONVERTER_RESULT <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter_result====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter_result====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER_RESULT implementation.
*"* method's implementations
*include methods.
  METHOD get_table.
    DATA: lo_object   TYPE REF TO object,
          ls_seoclass TYPE seoclass,
          l_method    TYPE string.

    SELECT SINGLE * INTO ls_seoclass
      FROM seoclass
      WHERE clsname = 'IF_SALV_BS_DATA_SOURCE'.

    IF sy-subrc = 0.
      l_method = 'GET_TABLE_REF'.
      lo_object ?= io_object.
      CALL METHOD lo_object->(l_method)
        RECEIVING
          value = ro_data.
    ELSE.
      l_method = 'GET_REF_TO_TABLE'.
      lo_object ?= io_object.
      CALL METHOD lo_object->(l_method)
        RECEIVING
          value = ro_data.
    ENDIF.

  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER_RESULT implementation

*>>>>>>> LCL_EXCEL_CONVERTER_RESULT_EX <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter_result_ex=ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter_result_ex=ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER_RESULT_EX implementation.
*"* method's implementations
*include methods.
  METHOD Lif_excel_converter~can_convert_object.

    DATA: lo_result TYPE REF TO cl_salv_ex_result_data_table.

    TRY.
        lo_result ?= io_object.
      CATCH cx_sy_move_cast_error .
        RAISE EXCEPTION TYPE Lcx_excel.
    ENDTRY.

  ENDMETHOD.
  METHOD Lif_excel_converter~create_fieldcatalog.
    DATA: lo_result TYPE REF TO cl_salv_ex_result_data_table,
          lo_ex_cm  TYPE REF TO cl_salv_ex_cm,
          lo_data   TYPE REF TO data.

    FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.

    Lif_excel_converter~can_convert_object( io_object = io_object ).

    ws_option = is_option.

    lo_result ?= io_object.

    CLEAR: es_layout,
           et_fieldcatalog.

    IF lo_result IS BOUND.
      lo_data = get_table( io_object = lo_result->r_model->r_data ).
      IF lo_data IS BOUND.
        ASSIGN lo_data->* TO <fs_table> .

        lo_ex_cm ?= lo_result->r_model->r_model.
        ws_layo = lo_ex_cm->s_layo.
* T_DRDN  Instance Attribute  Public  Type  LVC_T_DROP
        wt_fcat = lo_ex_cm->t_fcat.
        wt_filt = lo_ex_cm->t_filt.
* T_HYPE  Instance Attribute  Public  Type  LVC_T_HYPE
* T_SELECTED_CELLS  Instance Attribute  Public  Type  LVC_T_CELL
* T_SELECTED_COLUMNS  Instance Attribute  Public  Type  LVC_T_COL
        wt_sort = lo_ex_cm->t_sort.

        apply_sort( EXPORTING it_table = <fs_table>
                    IMPORTING eo_table = eo_table ) .

        get_color( EXPORTING io_table    = eo_table
                   IMPORTING et_colors   = et_colors ) .

        get_filter( IMPORTING et_filter  = et_filter
                    CHANGING  xo_table   = eo_table ) .

        update_catalog( CHANGING  cs_layout       = es_layout
                                  ct_fieldcatalog = et_fieldcatalog ).
      ELSE.
* We have a problem and should stop here.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD Lif_excel_converter~get_supported_class.
    rv_supported_class = 'CL_SALV_EX_RESULT_DATA_TABLE'.
  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER_RESULT_EX implementation

*>>>>>>> LCL_EXCEL_CONVERTER_RESULT_WD <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter_result_wd=ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter_result_wd=ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER_RESULT_WD implementation.
*"* method's implementations
*include methods.
  METHOD create_wt_fcat.
    DATA: lr_data        TYPE REF TO data,
          lo_structdescr TYPE REF TO cl_abap_structdescr,
          lt_dfies       TYPE ddfields,
          ls_dfies       TYPE dfies.

    DATA: ls_fcat         TYPE lvc_s_fcat.

    FIELD-SYMBOLS: <fs_tab>         TYPE ANY TABLE.

    ASSIGN io_table->* TO <fs_tab> .
    CREATE DATA lr_data LIKE LINE OF <fs_tab>.

    lo_structdescr ?= cl_abap_structdescr=>describe_by_data_ref( lr_data ).

    lt_dfies = Lcl_excel_common=>describe_structure( io_struct = lo_structdescr ).

    LOOP AT lt_dfies INTO ls_dfies.
      MOVE-CORRESPONDING ls_dfies TO ls_fcat.
      ls_fcat-col_pos = ls_dfies-position.
      ls_fcat-key     = ls_dfies-keyflag.
      get_fields_info( CHANGING xs_fcat = ls_fcat ) .

      ls_fcat-col_opt = abap_true.

      get_columns_info( CHANGING xs_fcat = ls_fcat ) .

      INSERT ls_fcat INTO TABLE wt_fcat.
    ENDLOOP.

  ENDMETHOD.
  METHOD create_wt_filt.
* No neeed for superclass.
* Only for WD
    DATA: lt_filters TYPE salv_wd_t_filter_rule_ref,
          ls_filt    TYPE lvc_s_filt.

    FIELD-SYMBOLS: <fs_fields> TYPE salv_wd_s_field_ref,
                   <fs_filter> TYPE salv_wd_s_filter_rule_ref.

    LOOP AT  wt_fields ASSIGNING <fs_fields>.
      CLEAR lt_filters.
      lt_filters    = <fs_fields>-r_field->if_salv_wd_filter~get_filter_rules( ) .
      LOOP AT lt_filters ASSIGNING <fs_filter>.
        ls_filt-fieldname = <fs_fields>-fieldname.
        IF <fs_filter>-r_filter_rule->get_included( ) = abap_true.
          ls_filt-sign      = 'I'.
        ELSE.
          ls_filt-sign      = 'E'.
        ENDIF.
        ls_filt-option    = <fs_filter>-r_filter_rule->get_operator( ).
        ls_filt-high      = <fs_filter>-r_filter_rule->get_high_value( ) .
        ls_filt-low       = <fs_filter>-r_filter_rule->get_low_value( ) .
        INSERT ls_filt INTO TABLE wt_filt.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.
  METHOD create_wt_sort.
    DATA: lo_sort      TYPE REF TO cl_salv_wd_sort_rule,
          l_sort_order TYPE salv_wd_constant,
          ls_sort      TYPE lvc_s_sort.

    FIELD-SYMBOLS: <fs_fields>  TYPE salv_wd_s_field_ref.

    LOOP AT  wt_fields ASSIGNING <fs_fields>.
      lo_sort      = <fs_fields>-r_field->if_salv_wd_sort~get_sort_rule( ) .
      IF lo_sort IS BOUND.
        l_sort_order = lo_sort->get_sort_order( ).
        IF l_sort_order <> if_salv_wd_c_sort=>sort_order.
          CLEAR ls_sort.
          ls_sort-spos      = lo_sort->get_sort_position( ).
          ls_sort-fieldname = <fs_fields>-fieldname.
          ls_sort-subtot    = lo_sort->get_group_aggregation( ).
          IF l_sort_order = if_salv_wd_c_sort=>sort_order_ascending.
            ls_sort-up = abap_true.
          ELSE.
            ls_sort-down = abap_true.
          ENDIF.
          INSERT ls_sort INTO TABLE wt_sort.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_columns_info.
    DATA:  l_numc2             TYPE salv_wd_constant.


    FIELD-SYMBOLS: <fs_column>  TYPE salv_wd_s_column_ref.

    READ TABLE wt_columns ASSIGNING <fs_column> WITH KEY id = xs_fcat-fieldname .
    IF sy-subrc = 0.
      xs_fcat-col_pos    = <fs_column>-r_column->get_position( ) .
      l_numc2 = <fs_column>-r_column->get_fixed_position( ).
      IF l_numc2 = '02'.
        xs_fcat-fix_column = abap_true .
      ENDIF.
      l_numc2 = <fs_column>-r_column->get_visible( ).
      IF l_numc2 = '01'.
        xs_fcat-no_out = abap_true .
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD get_fields_info.
    DATA: lo_aggr    TYPE REF TO cl_salv_wd_aggr_rule,
          l_aggrtype TYPE salv_wd_constant.

    FIELD-SYMBOLS: <fs_fields>  TYPE salv_wd_s_field_ref.

    READ TABLE wt_fields ASSIGNING <fs_fields> WITH KEY fieldname = xs_fcat-fieldname.
    IF sy-subrc = 0.
      lo_aggr = <fs_fields>-r_field->if_salv_wd_aggr~get_aggr_rule( ) .
      IF lo_aggr IS BOUND.
        l_aggrtype = lo_aggr->get_aggregation_type( ) .
        CASE l_aggrtype.
          WHEN if_salv_wd_c_aggregation=>aggrtype_total.
            xs_fcat-do_sum = abap_true.
          WHEN if_salv_wd_c_aggregation=>aggrtype_minimum.
            xs_fcat-do_sum =  'A'.
          WHEN if_salv_wd_c_aggregation=>aggrtype_maximum .
            xs_fcat-do_sum =  'B'.
          WHEN if_salv_wd_c_aggregation=>aggrtype_average .
            xs_fcat-do_sum =  'C'.
          WHEN OTHERS.
            CLEAR xs_fcat-do_sum .
        ENDCASE.
      ENDIF.
    ENDIF.

  ENDMETHOD.
  METHOD Lif_excel_converter~can_convert_object.

    DATA: lo_result TYPE REF TO cl_salv_wd_result_data_table.

    TRY.
        lo_result ?= io_object.
      CATCH cx_sy_move_cast_error .
        RAISE EXCEPTION TYPE Lcx_excel.
    ENDTRY.

  ENDMETHOD.
  METHOD Lif_excel_converter~create_fieldcatalog.
    DATA: lo_result TYPE REF TO cl_salv_wd_result_data_table,
          lo_data   TYPE REF TO data.

    FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.

    Lif_excel_converter~can_convert_object( io_object = io_object ).

    ws_option = is_option.

    lo_result ?= io_object.

    CLEAR: es_layout,
           et_fieldcatalog.

    IF lo_result IS BOUND.
      lo_data = get_table( io_object = lo_result->r_model->r_data ).
      IF lo_data IS BOUND.
        ASSIGN lo_data->* TO <fs_table> .

        wo_config ?= lo_result->r_model->r_model.

        IF wo_config IS BOUND.
          wt_fields  = wo_config->if_salv_wd_field_settings~get_fields( ) .
          wt_columns = wo_config->if_salv_wd_column_settings~get_columns( ) .
        ENDIF.

        create_wt_fcat( io_table = lo_data ).
        create_wt_sort( ).
        create_wt_filt( ).

        apply_sort( EXPORTING it_table = <fs_table>
                    IMPORTING eo_table = eo_table ) .

        get_filter( IMPORTING et_filter  = et_filter
                    CHANGING  xo_table   = eo_table ) .

        update_catalog( CHANGING  cs_layout       = es_layout
                                  ct_fieldcatalog = et_fieldcatalog ).
      ELSE.
* We have a problem and should stop here
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD Lif_excel_converter~get_supported_class.
    rv_supported_class = 'CL_SALV_WD_RESULT_DATA_TABLE'.
  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER_RESULT_WD implementation

*>>>>>>> LCL_EXCEL_DATA_VALIDATION <<<<<<<*

*"* macro definitions
*include Lcl_excel_data_validation=====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_data_validation=====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_DATA_VALIDATION implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    " Initialise instance variables
    formula1          = ''.
    formula2          = ''.
    type              = me->c_type_none.
    errorstyle        = me->c_style_stop.
    operator          = ''.
    allowblank        = abap_false.
    showdropdown      = abap_false.
    showinputmessage  = abap_true.
    showerrormessage  = abap_true.
    errortitle        = ''.
    error             = ''.
    prompttitle       = ''.
    prompt            = ''.
* inizialize dimension range
    cell_row     = 1.
    cell_column  = 'A'.
  ENDMETHOD.
endclass. "LCL_EXCEL_DATA_VALIDATION implementation

*>>>>>>> LCL_EXCEL_DATA_VALIDATIONS <<<<<<<*

*"* macro definitions
*include Lcl_excel_data_validations====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_data_validations====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_DATA_VALIDATIONS implementation.
*"* method's implementations
*include methods.
  METHOD add.
    data_validations->add( ip_data_validation ).
  ENDMETHOD.
  METHOD clear.
    data_validations->clear( ).
  ENDMETHOD.
  METHOD constructor.

    CREATE OBJECT data_validations.

  ENDMETHOD.
  METHOD get_iterator.
    eo_iterator ?= data_validations->get_iterator( ).
  ENDMETHOD.
  METHOD is_empty.
    is_empty = data_validations->is_empty( ).
  ENDMETHOD.
  METHOD remove.
    data_validations->remove( ip_data_validation ).
  ENDMETHOD.
  METHOD size.
    ep_size = data_validations->size( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_DATA_VALIDATIONS implementation

*>>>>>>> LCL_EXCEL_DRAWING <<<<<<<*

*"* macro definitions
*include Lcl_excel_drawing=============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_drawing=============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_DRAWING implementation.
*"* method's implementations
*include methods.
  METHOD constructor.

    me->guid = Lcl_excel_obsolete_func_wrap=>guid_create( ).      " ins issue #379 - replacement for outdated function call

    IF ip_title IS NOT INITIAL.
      title = ip_title.
    ELSE.
      title = me->guid.
    ENDIF.

    me->type = ip_type.

* inizialize dimension range
    anchor = anchor_one_cell.
    from_loc-col = 1.
    from_loc-row = 1.
  ENDMETHOD.
  METHOD create_media_name.

* if media name is initial, create unique name
    CHECK media_name IS INITIAL.

    index = ip_index.
    CONCATENATE me->type index INTO media_name.
    CONDENSE media_name NO-GAPS.
  ENDMETHOD.
  METHOD emu2pixel.
* suppose 96 DPI
    IF ip_dpi IS SUPPLIED.
      r_pixel = ip_emu * ip_dpi / 914400.
    ELSE.
* suppose 96 DPI
      r_pixel = ip_emu * 96 / 914400.
    ENDIF.
  ENDMETHOD.
  METHOD get_from_col.
    r_from_col = me->from_loc-col.
  ENDMETHOD.
  METHOD get_from_row.
    r_from_row = me->from_loc-row.
  ENDMETHOD.
  METHOD get_guid.

    ep_guid = me->guid.

  ENDMETHOD.
  METHOD get_height_emu_str.
    r_height = pixel2emu( size-height ).
    CONDENSE r_height NO-GAPS.
  ENDMETHOD.
  METHOD get_index.
    rp_index = me->index.
  ENDMETHOD.
  METHOD get_media.

    DATA: lv_language LIKE sy-langu.
    DATA: lt_bin_mime TYPE sdokcntbins.
    DATA: lt_mime          TYPE tsfmime,
          lv_filesize      TYPE i,
          lv_filesizec(10).

    CASE media_source.
      WHEN c_media_source_xstring.
        r_media = media.
      WHEN c_media_source_www.
        CALL FUNCTION 'WWWDATA_IMPORT'
          EXPORTING
            key    = media_key_www
          TABLES
            mime   = lt_mime
          EXCEPTIONS
            OTHERS = 1.

        CALL FUNCTION 'WWWPARAMS_READ'
          EXPORTING
            relid = media_key_www-relid
            objid = media_key_www-objid
            name  = 'filesize'
          IMPORTING
            value = lv_filesizec.

        lv_filesize = lv_filesizec.
        CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
          EXPORTING
            input_length = lv_filesize
          IMPORTING
            buffer       = r_media
          TABLES
            binary_tab   = lt_mime
          EXCEPTIONS
            failed       = 1
            OTHERS       = 2.
      WHEN c_media_source_mime.
        lv_language = sy-langu.
        cl_wb_mime_repository=>load_mime( EXPORTING
                                            io        = me->io
                                          IMPORTING
                                            filesize  = lv_filesize
                                            bin_data  = lt_bin_mime
                                          CHANGING
                                            language  = lv_language ).

        CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
          EXPORTING
            input_length = lv_filesize
          IMPORTING
            buffer       = r_media
          TABLES
            binary_tab   = lt_bin_mime
          EXCEPTIONS
            failed       = 1
            OTHERS       = 2.
    ENDCASE.
  ENDMETHOD.
  METHOD get_media_name.
    CONCATENATE media_name  `.` media_type INTO r_name.
  ENDMETHOD.
  METHOD get_media_type.
    r_type = media_type.
  ENDMETHOD.
  METHOD get_name.
    r_name = title.
  ENDMETHOD.
  METHOD get_position.
    rp_position-anchor = anchor.
    rp_position-from = from_loc.
    rp_position-to = to_loc.
    rp_position-size = size.
  ENDMETHOD.
  METHOD get_to_col.
    r_to_col = me->to_loc-col.
  ENDMETHOD.
  METHOD get_to_row.
    r_to_row = me->to_loc-row.
  ENDMETHOD.
  METHOD get_type.
    rp_type = me->type.
  ENDMETHOD.
  METHOD get_width_emu_str.
    r_width = pixel2emu( size-width ).
    CONDENSE r_width NO-GAPS.
  ENDMETHOD.
  METHOD load_chart_attributes.
    DATA: node                TYPE REF TO if_ixml_element.
    DATA: node2               TYPE REF TO if_ixml_element.
    DATA: node3               TYPE REF TO if_ixml_element.
    DATA: node4               TYPE REF TO if_ixml_element.

    DATA lo_barchart TYPE REF TO Lcl_excel_graph_bars.
    DATA lo_piechart TYPE REF TO Lcl_excel_graph_pie.
    DATA lo_linechart TYPE REF TO Lcl_excel_graph_line.

    TYPES: BEGIN OF t_prop,
             val          TYPE string,
             rtl          TYPE string,
             lang         TYPE string,
             formatcode   TYPE string,
             sourcelinked TYPE string,
           END OF t_prop.

    TYPES: BEGIN OF t_pagemargins,
             b      TYPE string,
             l      TYPE string,
             r      TYPE string,
             t      TYPE string,
             header TYPE string,
             footer TYPE string,
           END OF t_pagemargins.

    DATA ls_prop TYPE t_prop.
    DATA ls_pagemargins TYPE t_pagemargins.

    DATA lo_collection TYPE REF TO if_ixml_node_collection.
    DATA lo_node       TYPE REF TO if_ixml_node.
    DATA lo_iterator   TYPE REF TO if_ixml_node_iterator.
    DATA lv_idx        TYPE i.
    DATA lv_order      TYPE i.
    DATA lv_invertifnegative      TYPE string.
    DATA lv_symbol      TYPE string.
    DATA lv_smooth      TYPE c.
    DATA lv_sername    TYPE string.
    DATA lv_label      TYPE string.
    DATA lv_value      TYPE string.
    DATA lv_axid       TYPE string.
    DATA lv_orientation TYPE string.
    DATA lv_delete TYPE string.
    DATA lv_axpos TYPE string.
    DATA lv_formatcode TYPE string.
    DATA lv_sourcelinked TYPE string.
    DATA lv_majortickmark TYPE string.
    DATA lv_minortickmark TYPE string.
    DATA lv_ticklblpos TYPE string.
    DATA lv_crossax TYPE string.
    DATA lv_crosses TYPE string.
    DATA lv_auto TYPE string.
    DATA lv_lblalgn TYPE string.
    DATA lv_lbloffset TYPE string.
    DATA lv_nomultilvllbl TYPE string.
    DATA lv_crossbetween TYPE string.

    node ?= ip_chart->if_ixml_node~get_first_child( ).
    CHECK node IS NOT INITIAL.

    CASE me->graph_type.
      WHEN c_graph_bars.
        CREATE OBJECT lo_barchart.
        me->graph = lo_barchart.
      WHEN c_graph_pie.
        CREATE OBJECT lo_piechart.
        me->graph = lo_piechart.
      WHEN c_graph_line.
        CREATE OBJECT lo_linechart.
        me->graph = lo_linechart.
      WHEN OTHERS.
    ENDCASE.

    "Fill properties
    node2 ?= node->find_from_name_ns( name = 'date1904' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_1904val = ls_prop-val.
    node2 ?= node->find_from_name_ns( name = 'lang' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_langval = ls_prop-val.
    node2 ?= node->find_from_name_ns( name = 'roundedCorners' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_roundedcornersval = ls_prop-val.

    "style
    node2 ?= node->find_from_name_ns( name = 'style' uri = namespace-c14 ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_c14styleval = ls_prop-val.
    node2 ?= node->find_from_name_ns( name = 'style' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_styleval = ls_prop-val.
    "---------------------------Read graph properties
    "ADDED
    CLEAR node2.
    node2 ?= node->find_from_name_ns( name = 'title' uri = namespace-c ).
    IF node2 IS BOUND AND node2 IS NOT INITIAL.
      node3 ?= node2->find_from_name_ns( name = 't' uri = namespace-a ).
      me->graph->title = node3->get_value( ).
    ENDIF.
    "END

    node2 ?= node->find_from_name_ns( name = 'autoTitleDeleted' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_autotitledeletedval = ls_prop-val.

    "plotArea
    CASE me->graph_type.
      WHEN c_graph_bars.
        node2 ?= node->find_from_name_ns( name = 'barDir' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_bardirval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'grouping' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_groupingval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'varyColors' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_varycolorsval = ls_prop-val.

        "Load series
        CALL METHOD node->get_elements_by_tag_name_ns
          EXPORTING
*           depth     = 0
            name = 'ser'
            uri  = namespace-c
          RECEIVING
            rval = lo_collection.
        CALL METHOD lo_collection->create_iterator
          RECEIVING
            rval = lo_iterator.
        lo_node = lo_iterator->get_next( ).
        IF lo_node IS BOUND.
          node2 ?= lo_node->query_interface( c_ixml_iid_element ).
        ENDIF.
        WHILE lo_node IS BOUND.
          node3 ?= node2->find_from_name_ns( name = 'idx' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_idx = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'order' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_order = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'invertIfNegative' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_invertifnegative = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'v' uri = namespace-c ).
          IF node3 IS BOUND.
            lv_sername = node3->get_value( ).
          ENDIF.
          node3 ?= node2->find_from_name_ns( name = 'strRef' uri = namespace-c ).
          IF node3 IS BOUND.
            node4 ?= node3->find_from_name_ns( name = 'f' uri = namespace-c ).
            lv_label = node4->get_value( ).
          ENDIF.
          node3 ?= node2->find_from_name_ns( name = 'numRef' uri = namespace-c ).
          IF node3 IS BOUND.
            node4 ?= node3->find_from_name_ns( name = 'f' uri = namespace-c ).
            lv_value = node4->get_value( ).
          ENDIF.
          CALL METHOD lo_barchart->create_serie
            EXPORTING
              ip_idx              = lv_idx
              ip_order            = lv_order
              ip_invertifnegative = lv_invertifnegative
              ip_lbl              = lv_label
              ip_ref              = lv_value
              ip_sername          = lv_sername.
          lo_node = lo_iterator->get_next( ).
          IF lo_node IS BOUND.
            node2 ?= lo_node->query_interface( c_ixml_iid_element ).
          ENDIF.
        ENDWHILE.
        "note: numCache avoided
        node2 ?= node->find_from_name_ns( name = 'showLegendKey' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_showlegendkeyval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showVal' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_showvalval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showCatName' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_showcatnameval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showSerName' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_showsernameval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showPercent' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_showpercentval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showBubbleSize' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_showbubblesizeval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'gapWidth' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_barchart->ns_gapwidthval = ls_prop-val.

        "Load axes
        node2 ?= node->find_from_name_ns( name = 'barChart' uri = namespace-c ).
        CALL METHOD node2->get_elements_by_tag_name_ns
          EXPORTING
*           depth     = 0
            name = 'axId'
            uri  = namespace-c
          RECEIVING
            rval = lo_collection.
        CALL METHOD lo_collection->create_iterator
          RECEIVING
            rval = lo_iterator.
        lo_node = lo_iterator->get_next( ).
        IF lo_node IS BOUND.
          node2 ?= lo_node->query_interface( c_ixml_iid_element ).
        ENDIF.
        WHILE lo_node IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lv_axid = ls_prop-val.
          IF sy-index EQ 1. "catAx
            node2 ?= node->find_from_name_ns( name = 'catAx' uri = namespace-c ).
            node3 ?= node2->find_from_name_ns( name = 'orientation' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_orientation = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'delete' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_delete = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'axPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_axpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'numFmt' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_formatcode = ls_prop-formatcode.
            lv_sourcelinked = ls_prop-sourcelinked.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_majortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_minortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'tickLblPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_ticklblpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crossAx' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crossax = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crosses' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crosses = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'auto' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_auto = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'lblAlgn' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_lblalgn = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'lblOffset' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_lbloffset = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'noMultiLvlLbl' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_nomultilvllbl = ls_prop-val.
            CALL METHOD lo_barchart->create_ax
              EXPORTING
                ip_axid          = lv_axid
                ip_type          = Lcl_excel_graph_bars=>c_catax
                ip_orientation   = lv_orientation
                ip_delete        = lv_delete
                ip_axpos         = lv_axpos
                ip_formatcode    = lv_formatcode
                ip_sourcelinked  = lv_sourcelinked
                ip_majortickmark = lv_majortickmark
                ip_minortickmark = lv_minortickmark
                ip_ticklblpos    = lv_ticklblpos
                ip_crossax       = lv_crossax
                ip_crosses       = lv_crosses
                ip_auto          = lv_auto
                ip_lblalgn       = lv_lblalgn
                ip_lbloffset     = lv_lbloffset
                ip_nomultilvllbl = lv_nomultilvllbl.
          ELSEIF sy-index EQ 2. "valAx
            node2 ?= node->find_from_name_ns( name = 'valAx' uri = namespace-c ).
            node3 ?= node2->find_from_name_ns( name = 'orientation' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_orientation = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'delete' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_delete = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'axPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_axpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'numFmt' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_formatcode = ls_prop-formatcode.
            lv_sourcelinked = ls_prop-sourcelinked.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_majortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_minortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'tickLblPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_ticklblpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crossAx' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crossax = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crosses' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crosses = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crossBetween' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crossbetween = ls_prop-val.
            CALL METHOD lo_barchart->create_ax
              EXPORTING
                ip_axid          = lv_axid
                ip_type          = Lcl_excel_graph_bars=>c_valax
                ip_orientation   = lv_orientation
                ip_delete        = lv_delete
                ip_axpos         = lv_axpos
                ip_formatcode    = lv_formatcode
                ip_sourcelinked  = lv_sourcelinked
                ip_majortickmark = lv_majortickmark
                ip_minortickmark = lv_minortickmark
                ip_ticklblpos    = lv_ticklblpos
                ip_crossax       = lv_crossax
                ip_crosses       = lv_crosses
                ip_crossbetween  = lv_crossbetween.
          ENDIF.
          lo_node = lo_iterator->get_next( ).
          IF lo_node IS BOUND.
            node2 ?= lo_node->query_interface( c_ixml_iid_element ).
          ENDIF.
        ENDWHILE.

      WHEN c_graph_pie.
        node2 ?= node->find_from_name_ns( name = 'varyColors' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_varycolorsval = ls_prop-val.

        "Load series
        CALL METHOD node->get_elements_by_tag_name_ns
          EXPORTING
*           depth     = 0
            name = 'ser'
            uri  = namespace-c
          RECEIVING
            rval = lo_collection.
        CALL METHOD lo_collection->create_iterator
          RECEIVING
            rval = lo_iterator.
        lo_node = lo_iterator->get_next( ).
        IF lo_node IS BOUND.
          node2 ?= lo_node->query_interface( c_ixml_iid_element ).
        ENDIF.
        WHILE lo_node IS BOUND.
          node3 ?= node2->find_from_name_ns( name = 'idx' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_idx = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'order' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_order = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'v' uri = namespace-c ).
          IF node3 IS BOUND.
            lv_sername = node3->get_value( ).
          ENDIF.
          node3 ?= node2->find_from_name_ns( name = 'strRef' uri = namespace-c ).
          IF node3 IS BOUND.
            node4 ?= node3->find_from_name_ns( name = 'f' uri = namespace-c ).
            lv_label = node4->get_value( ).
          ENDIF.
          node3 ?= node2->find_from_name_ns( name = 'numRef' uri = namespace-c ).
          IF node3 IS BOUND.
            node4 ?= node3->find_from_name_ns( name = 'f' uri = namespace-c ).
            lv_value = node4->get_value( ).
          ENDIF.
          CALL METHOD lo_piechart->create_serie
            EXPORTING
              ip_idx     = lv_idx
              ip_order   = lv_order
              ip_lbl     = lv_label
              ip_ref     = lv_value
              ip_sername = lv_sername.
          lo_node = lo_iterator->get_next( ).
          IF lo_node IS BOUND.
            node2 ?= lo_node->query_interface( c_ixml_iid_element ).
          ENDIF.
        ENDWHILE.

        "note: numCache avoided
        node2 ?= node->find_from_name_ns( name = 'showLegendKey' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_showlegendkeyval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showVal' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_showvalval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showCatName' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_showcatnameval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showSerName' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_showsernameval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showPercent' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_showpercentval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showBubbleSize' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_showbubblesizeval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showLeaderLines' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_showleaderlinesval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'firstSliceAng' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_firstsliceangval = ls_prop-val.
      WHEN c_graph_line.
        node2 ?= node->find_from_name_ns( name = 'grouping' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_groupingval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'varyColors' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_varycolorsval = ls_prop-val.

        "Load series
        CALL METHOD node->get_elements_by_tag_name_ns
          EXPORTING
*           depth     = 0
            name = 'ser'
            uri  = namespace-c
          RECEIVING
            rval = lo_collection.
        CALL METHOD lo_collection->create_iterator
          RECEIVING
            rval = lo_iterator.
        lo_node = lo_iterator->get_next( ).
        IF lo_node IS BOUND.
          node2 ?= lo_node->query_interface( c_ixml_iid_element ).
        ENDIF.
        WHILE lo_node IS BOUND.
          node3 ?= node2->find_from_name_ns( name = 'idx' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_idx = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'order' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_order = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'symbol' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_symbol = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'smooth' uri = namespace-c ).
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
          lv_smooth = ls_prop-val.
          node3 ?= node2->find_from_name_ns( name = 'v' uri = namespace-c ).
          IF node3 IS BOUND.
            lv_sername = node3->get_value( ).
          ENDIF.
          node3 ?= node2->find_from_name_ns( name = 'strRef' uri = namespace-c ).
          IF node3 IS BOUND.
            node4 ?= node3->find_from_name_ns( name = 'f' uri = namespace-c ).
            lv_label = node4->get_value( ).
          ENDIF.
          node3 ?= node2->find_from_name_ns( name = 'numRef' uri = namespace-c ).
          IF node3 IS BOUND.
            node4 ?= node3->find_from_name_ns( name = 'f' uri = namespace-c ).
            lv_value = node4->get_value( ).
          ENDIF.
          CALL METHOD lo_linechart->create_serie
            EXPORTING
              ip_idx     = lv_idx
              ip_order   = lv_order
              ip_symbol  = lv_symbol
              ip_smooth  = lv_smooth
              ip_lbl     = lv_label
              ip_ref     = lv_value
              ip_sername = lv_sername.
          lo_node = lo_iterator->get_next( ).
          IF lo_node IS BOUND.
            node2 ?= lo_node->query_interface( c_ixml_iid_element ).
          ENDIF.
        ENDWHILE.
        "note: numCache avoided
        node2 ?= node->find_from_name_ns( name = 'showLegendKey' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_showlegendkeyval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showVal' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_showvalval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showCatName' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_showcatnameval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showSerName' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_showsernameval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showPercent' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_showpercentval = ls_prop-val.
        node2 ?= node->find_from_name_ns( name = 'showBubbleSize' uri = namespace-c ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_showbubblesizeval = ls_prop-val.

        node ?= node->find_from_name_ns( name = 'lineChart' uri = namespace-c ).
        node2 ?= node->find_from_name_ns( name = 'marker' uri = namespace-c depth = '1' ).
        IF node2 IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lo_linechart->ns_markerval = ls_prop-val.
        ENDIF.
        node2 ?= node->find_from_name_ns( name = 'smooth' uri = namespace-c depth = '1' ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_linechart->ns_smoothval = ls_prop-val.
        node ?= ip_chart->if_ixml_node~get_first_child( ).
        CHECK node IS NOT INITIAL.

        "Load axes
        node2 ?= node->find_from_name_ns( name = 'lineChart' uri = namespace-c ).
        CALL METHOD node2->get_elements_by_tag_name_ns
          EXPORTING
*           depth     = 0
            name = 'axId'
            uri  = namespace-c
          RECEIVING
            rval = lo_collection.
        CALL METHOD lo_collection->create_iterator
          RECEIVING
            rval = lo_iterator.
        lo_node = lo_iterator->get_next( ).
        IF lo_node IS BOUND.
          node2 ?= lo_node->query_interface( c_ixml_iid_element ).
        ENDIF.
        WHILE lo_node IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lv_axid = ls_prop-val.
          IF sy-index EQ 1. "catAx
            node2 ?= node->find_from_name_ns( name = 'catAx' uri = namespace-c ).
            node3 ?= node2->find_from_name_ns( name = 'orientation' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_orientation = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'delete' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_delete = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'axPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_axpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_majortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_minortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'tickLblPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_ticklblpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crossAx' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crossax = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crosses' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crosses = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'auto' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_auto = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'lblAlgn' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_lblalgn = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'lblOffset' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_lbloffset = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'noMultiLvlLbl' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_nomultilvllbl = ls_prop-val.
            CALL METHOD lo_linechart->create_ax
              EXPORTING
                ip_axid          = lv_axid
                ip_type          = Lcl_excel_graph_line=>c_catax
                ip_orientation   = lv_orientation
                ip_delete        = lv_delete
                ip_axpos         = lv_axpos
                ip_formatcode    = lv_formatcode
                ip_sourcelinked  = lv_sourcelinked
                ip_majortickmark = lv_majortickmark
                ip_minortickmark = lv_minortickmark
                ip_ticklblpos    = lv_ticklblpos
                ip_crossax       = lv_crossax
                ip_crosses       = lv_crosses
                ip_auto          = lv_auto
                ip_lblalgn       = lv_lblalgn
                ip_lbloffset     = lv_lbloffset
                ip_nomultilvllbl = lv_nomultilvllbl.
          ELSEIF sy-index EQ 2. "valAx
            node2 ?= node->find_from_name_ns( name = 'valAx' uri = namespace-c ).
            node3 ?= node2->find_from_name_ns( name = 'orientation' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_orientation = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'delete' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_delete = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'axPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_axpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'numFmt' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_formatcode = ls_prop-formatcode.
            lv_sourcelinked = ls_prop-sourcelinked.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_majortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'majorTickMark' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_minortickmark = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'tickLblPos' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_ticklblpos = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crossAx' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crossax = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crosses' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crosses = ls_prop-val.
            node3 ?= node2->find_from_name_ns( name = 'crossBetween' uri = namespace-c ).
            Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = ls_prop ).
            lv_crossbetween = ls_prop-val.
            CALL METHOD lo_linechart->create_ax
              EXPORTING
                ip_axid          = lv_axid
                ip_type          = Lcl_excel_graph_line=>c_valax
                ip_orientation   = lv_orientation
                ip_delete        = lv_delete
                ip_axpos         = lv_axpos
                ip_formatcode    = lv_formatcode
                ip_sourcelinked  = lv_sourcelinked
                ip_majortickmark = lv_majortickmark
                ip_minortickmark = lv_minortickmark
                ip_ticklblpos    = lv_ticklblpos
                ip_crossax       = lv_crossax
                ip_crosses       = lv_crosses
                ip_crossbetween  = lv_crossbetween.
          ENDIF.
          lo_node = lo_iterator->get_next( ).
          IF lo_node IS BOUND.
            node2 ?= lo_node->query_interface( c_ixml_iid_element ).
          ENDIF.
        ENDWHILE.
      WHEN OTHERS.
    ENDCASE.

    "legend
    CASE me->graph_type.
      WHEN c_graph_bars.
        node2 ?= node->find_from_name_ns( name = 'legendPos' uri = namespace-c ).
        IF node2 IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lo_barchart->ns_legendposval = ls_prop-val.
        ENDIF.
        node2 ?= node->find_from_name_ns( name = 'overlay' uri = namespace-c ).
        IF node2 IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lo_barchart->ns_overlayval = ls_prop-val.
        ENDIF.
      WHEN c_graph_line.
        node2 ?= node->find_from_name_ns( name = 'legendPos' uri = namespace-c ).
        IF node2 IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lo_linechart->ns_legendposval = ls_prop-val.
        ENDIF.
        node2 ?= node->find_from_name_ns( name = 'overlay' uri = namespace-c ).
        IF node2 IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lo_linechart->ns_overlayval = ls_prop-val.
        ENDIF.
      WHEN c_graph_pie.
        node2 ?= node->find_from_name_ns( name = 'legendPos' uri = namespace-c ).
        IF node2 IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lo_piechart->ns_legendposval = ls_prop-val.
        ENDIF.
        node2 ?= node->find_from_name_ns( name = 'overlay' uri = namespace-c ).
        IF node2 IS BOUND.
          Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
          lo_piechart->ns_overlayval = ls_prop-val.
        ENDIF.
        node2 ?= node->find_from_name_ns( name = 'pPr' uri = namespace-a ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_pprrtl = ls_prop-rtl.
        node2 ?= node->find_from_name_ns( name = 'endParaRPr' uri = namespace-a ).
        Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
        lo_piechart->ns_endpararprlang = ls_prop-lang.

      WHEN OTHERS.
    ENDCASE.

    node2 ?= node->find_from_name_ns( name = 'plotVisOnly' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_plotvisonlyval = ls_prop-val.
    node2 ?= node->find_from_name_ns( name = 'dispBlanksAs' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_dispblanksasval = ls_prop-val.
    node2 ?= node->find_from_name_ns( name = 'showDLblsOverMax' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_prop ).
    me->graph->ns_showdlblsovermaxval = ls_prop-val.
    "---------------------

    node2 ?= node->find_from_name_ns( name = 'pageMargins' uri = namespace-c ).
    Lcl_excel_reader_2007=>fill_struct_from_attributes( EXPORTING ip_element = node2 CHANGING cp_structure = ls_pagemargins ).
    me->graph->pagemargins = ls_pagemargins.


  ENDMETHOD.
  METHOD pixel2emu.
* suppose 96 DPI
    IF ip_dpi IS SUPPLIED.
      r_emu = ip_pixel  * 914400 / ip_dpi.
    ELSE.
* suppose 96 DPI
      r_emu = ip_pixel  * 914400 / 96.
    ENDIF.
  ENDMETHOD.
  METHOD set_media.
    IF ip_media IS SUPPLIED.
      media = ip_media.
    ENDIF.
    media_type = ip_media_type.
    media_source = c_media_source_xstring.
    IF ip_width IS SUPPLIED.
      size-width  = ip_width.
    ENDIF.
    IF ip_height IS SUPPLIED.
      size-height = ip_height.
    ENDIF.
  ENDMETHOD.
  METHOD set_media_mime.

    DATA: lv_language LIKE sy-langu.

    io = ip_io.
    media_source = c_media_source_mime.
    size-width  = ip_width.
    size-height = ip_height.

    lv_language = sy-langu.
    cl_wb_mime_repository=>load_mime( EXPORTING
                                        io        = ip_io
                                      IMPORTING
                                        filename  = media_name
                                        "mimetype = media_type
                                      CHANGING
                                        language  = lv_language  ).

    SPLIT media_name AT '.' INTO media_name media_type.

  ENDMETHOD.
  METHOD set_media_www.
    DATA: lv_value(20).

    media_key_www = ip_key.
    media_source = c_media_source_www.

    CALL FUNCTION 'WWWPARAMS_READ'
      EXPORTING
        relid = media_key_www-relid
        objid = media_key_www-objid
        name  = 'fileextension'
      IMPORTING
        value = lv_value.
    media_type = lv_value.
    SHIFT media_type LEFT DELETING LEADING '.'.

    size-width  = ip_width.
    size-height = ip_height.
  ENDMETHOD.
  METHOD set_position.
    from_loc-col = Lcl_excel_common=>convert_column2int( ip_from_col ) - 1.
    IF ip_coloff IS SUPPLIED.
      from_loc-col_offset = ip_coloff.
    ENDIF.
    from_loc-row = ip_from_row - 1.
    IF ip_rowoff IS SUPPLIED.
      from_loc-row_offset = ip_rowoff.
    ENDIF.
    anchor = anchor_one_cell.
  ENDMETHOD.
  METHOD set_position2.

    DATA: lv_anchor                     TYPE zexcel_drawing_anchor.
    lv_anchor = ip_anchor.

    IF lv_anchor IS INITIAL.
      IF ip_to IS NOT INITIAL.
        lv_anchor = anchor_two_cell.
      ELSE.
        lv_anchor = anchor_one_cell.
      ENDIF.
    ENDIF.

    CASE lv_anchor.
      WHEN anchor_absolute OR anchor_one_cell.
        CLEAR: me->to_loc.
      WHEN anchor_two_cell.
        CLEAR: me->size.
    ENDCASE.

    me->from_loc = ip_from.
    me->to_loc = ip_to.
    me->anchor = lv_anchor.

  ENDMETHOD.
endclass. "LCL_EXCEL_DRAWING implementation

*>>>>>>> LCL_EXCEL_DRAWINGS <<<<<<<*

*"* macro definitions
*include Lcl_excel_drawings============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_drawings============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_DRAWINGS implementation.
*"* method's implementations
*include methods.
  METHOD add.
    DATA: lv_index TYPE i.

    drawings->add( ip_drawing ).
    lv_index = drawings->size( ).
    ip_drawing->create_media_name(
      ip_index = lv_index ).
  ENDMETHOD.
  METHOD clear.

    drawings->clear( ).
  ENDMETHOD.
  METHOD constructor.

    CREATE OBJECT drawings.
    type = ip_type.

  ENDMETHOD.
  METHOD get.

    DATA lv_index TYPE i.
    lv_index = ip_index.
    eo_drawing ?= drawings->get( lv_index ).
  ENDMETHOD.
  METHOD get_iterator.

    eo_iterator ?= drawings->get_iterator( ).
  ENDMETHOD.
  METHOD get_type.
    rp_type = me->type.
  ENDMETHOD.
  METHOD include.
    drawings->add( ip_drawing ).
  ENDMETHOD.
  METHOD is_empty.

    is_empty = drawings->is_empty( ).
  ENDMETHOD.
  METHOD remove.

    drawings->remove( ip_drawing ).
  ENDMETHOD.
  METHOD size.

    ep_size = drawings->size( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_DRAWINGS implementation

*>>>>>>> LCL_EXCEL_FILL_TEMPLATE <<<<<<<*

*"* macro definitions
*include Lcl_excel_fill_template=======ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_fill_template=======ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_FILL_TEMPLATE implementation.
*"* method's implementations
*include methods.
  METHOD create.

    CREATE OBJECT eo_template_filler .

    eo_template_filler->mo_excel = io_excel.
    eo_template_filler->get_range( ).
    eo_template_filler->discard_overlapped( ).
    eo_template_filler->sign_range( ).
    eo_template_filler->find_var( ).

  ENDMETHOD.
  METHOD discard_overlapped.
    DATA:
       lt_range TYPE tt_ranges.
    FIELD-SYMBOLS:
      <ls_range>   TYPE ts_range,
      <ls_range_2> TYPE ts_range.

    SORT mt_range BY sheet  start  stop.

    LOOP AT mt_range ASSIGNING <ls_range>.

      LOOP AT mt_range ASSIGNING <ls_range_2> WHERE sheet =  <ls_range>-sheet
                                            AND name  <> <ls_range>-name
                                            AND stop  >= <ls_range>-start
                                            AND start <  <ls_range>-start
                                            AND stop  <  <ls_range>-stop.
        EXIT.
      ENDLOOP.

      IF sy-subrc NE 0.
        APPEND <ls_range> TO lt_range.
      ENDIF.

    ENDLOOP.

    mt_range = lt_range.

    SORT mt_range BY sheet  start  stop DESCENDING.

  ENDMETHOD.
  METHOD fill_range.

    DATA: lt_tmp_cells_template        TYPE tt_cell_data_no_key,
          lt_cells_result              TYPE tt_cell_data_no_key,
          lt_tmp_cells                 TYPE tt_cell_data_no_key,
          ls_cell                      TYPE zexcel_s_cell_data,
          lt_tmp_merged_cells_template TYPE Lcl_excel_worksheet=>mty_ts_merge,
          lt_merged_cells_result       TYPE Lcl_excel_worksheet=>mty_ts_merge,
          lt_tmp_merged_cells          TYPE Lcl_excel_worksheet=>mty_ts_merge,
          ls_merged_cell               LIKE LINE OF lt_tmp_merged_cells,
          lv_start_row                 TYPE i,
          lv_stop_row                  TYPE i,
          lv_cell_row                  TYPE i,
          lv_column_alpha              TYPE string,
          lt_matches                   TYPE match_result_tab,
          lv_search                    TYPE string,
          lv_var_name                  TYPE string,
          lv_cell_value                TYPE string.

    FIELD-SYMBOLS:
      <table>     TYPE ANY TABLE,
      <line>      TYPE any,
      <ls_range>  TYPE ts_range,
      <ls_cell>   TYPE zexcel_s_cell_data,
      <ls_match>  TYPE match_result,
      <var_value> TYPE any.


    cv_diff = cv_diff +  iv_range_length .

    lv_start_row = 1.


* recursive fill nested range

    LOOP AT mt_range ASSIGNING <ls_range> WHERE sheet = iv_sheet
                                            AND parent = iv_parent.


      lv_stop_row = <ls_range>-start - 1.

*      update cells before any range

      LOOP AT ct_cells INTO ls_cell  WHERE cell_row >= lv_start_row AND cell_row <= lv_stop_row .
        ls_cell-cell_row =  ls_cell-cell_row + cv_diff.
        lv_column_alpha = Lcl_excel_common=>convert_column2alpha( ls_cell-cell_column ).

        ls_cell-cell_coords = ls_cell-cell_row.
        CONCATENATE lv_column_alpha ls_cell-cell_coords INTO ls_cell-cell_coords.
        CONDENSE ls_cell-cell_coords NO-GAPS.

        APPEND ls_cell TO lt_cells_result.
      ENDLOOP.



*      update merged cells before range

      LOOP AT ct_merged_cells INTO ls_merged_cell WHERE row_from >=  lv_start_row AND row_to <= lv_stop_row.
        ls_merged_cell-row_from = ls_merged_cell-row_from + cv_diff.
        ls_merged_cell-row_to = ls_merged_cell-row_to + cv_diff.

        APPEND ls_merged_cell TO lt_merged_cells_result.

      ENDLOOP.



      lv_start_row = <ls_range>-stop + 1.



      CLEAR:
       lt_tmp_cells_template,
       lt_tmp_merged_cells_template.


*copy cell template
      LOOP AT ct_cells INTO ls_cell WHERE cell_row >= <ls_range>-start AND cell_row <= <ls_range>-stop.
        APPEND ls_cell TO lt_tmp_cells_template.
      ENDLOOP.

      LOOP AT ct_merged_cells INTO ls_merged_cell WHERE row_from >= <ls_range>-start AND row_to <= <ls_range>-stop.
        APPEND ls_merged_cell TO lt_tmp_merged_cells_template.
      ENDLOOP.


      ASSIGN COMPONENT <ls_range>-name OF STRUCTURE iv_data TO <table>.
      CHECK sy-subrc = 0.

      cv_diff = cv_diff - <ls_range>-length.

*merge each line of data table with template
      LOOP AT <table> ASSIGNING <line>.
*        make local copy
        lt_tmp_cells = lt_tmp_cells_template.
        lt_tmp_merged_cells = lt_tmp_merged_cells_template.

*fill data

        fill_range(
          EXPORTING
            io_sheet        = io_sheet
            iv_sheet        = iv_sheet
            iv_parent       = <ls_range>-id
            iv_data         = <line>
            iv_range_length = <ls_range>-length
          CHANGING
            ct_cells        = lt_tmp_cells
            ct_merged_cells = lt_tmp_merged_cells
            cv_diff         = cv_diff ).

*collect data

        APPEND LINES OF lt_tmp_cells TO lt_cells_result.
        APPEND LINES OF lt_tmp_merged_cells TO lt_merged_cells_result.

      ENDLOOP.

    ENDLOOP.


    IF <ls_range> IS ASSIGNED.

      LOOP AT ct_cells INTO ls_cell WHERE cell_row > <ls_range>-stop .
        ls_cell-cell_row =  ls_cell-cell_row + cv_diff.
        lv_column_alpha = Lcl_excel_common=>convert_column2alpha( ls_cell-cell_column ).

        ls_cell-cell_coords = ls_cell-cell_row.
        CONCATENATE lv_column_alpha ls_cell-cell_coords INTO ls_cell-cell_coords.
        CONDENSE ls_cell-cell_coords NO-GAPS.

        APPEND ls_cell TO lt_cells_result.
      ENDLOOP.

      ct_cells = lt_cells_result.

      LOOP AT ct_merged_cells INTO ls_merged_cell WHERE row_from > <ls_range>-stop.
        ls_merged_cell-row_from = ls_merged_cell-row_from + cv_diff.
        ls_merged_cell-row_to = ls_merged_cell-row_to + cv_diff.

        APPEND ls_merged_cell TO lt_merged_cells_result.
      ENDLOOP.

      ct_merged_cells = lt_merged_cells_result.

    ELSE.


      LOOP AT ct_cells ASSIGNING <ls_cell>.
        <ls_cell>-cell_row =  <ls_cell>-cell_row + cv_diff.
        lv_column_alpha = Lcl_excel_common=>convert_column2alpha( <ls_cell>-cell_column ).

        <ls_cell>-cell_coords = <ls_cell>-cell_row.
        CONCATENATE lv_column_alpha <ls_cell>-cell_coords INTO <ls_cell>-cell_coords.
        CONDENSE <ls_cell>-cell_coords NO-GAPS.
      ENDLOOP.

      LOOP AT ct_merged_cells INTO ls_merged_cell .
        ls_merged_cell-row_from = ls_merged_cell-row_from + cv_diff.
        ls_merged_cell-row_to = ls_merged_cell-row_to + cv_diff.

        APPEND ls_merged_cell TO lt_merged_cells_result.
      ENDLOOP.

      ct_merged_cells = lt_merged_cells_result.

    ENDIF.


*check if variables in this range
    READ TABLE mt_var TRANSPORTING NO FIELDS WITH KEY sheet = iv_sheet parent = iv_parent.

    IF sy-subrc = 0.

*      replace variables of current range with data
      LOOP AT ct_cells ASSIGNING <ls_cell>.

        CLEAR lt_matches.

        lv_cell_value = <ls_cell>-cell_value.

        FIND ALL OCCURRENCES OF REGEX '\[[^\]]*\]' IN <ls_cell>-cell_value  RESULTS lt_matches.

        SORT lt_matches BY offset DESCENDING .

        LOOP AT lt_matches ASSIGNING <ls_match>.
          lv_search = <ls_cell>-cell_value+<ls_match>-offset(<ls_match>-length).
          lv_var_name = lv_search.

          TRANSLATE lv_var_name TO UPPER CASE.
          TRANSLATE lv_var_name USING '[ ] '.
          CONDENSE lv_var_name .

          ASSIGN COMPONENT lv_var_name OF STRUCTURE iv_data TO <var_value>.
          CHECK sy-subrc = 0.

          " Use SET_CELL to format correctly
          io_sheet->set_cell( ip_column = <ls_cell>-cell_column ip_row = <ls_cell>-cell_row - cv_diff ip_value = <var_value> ).
          lv_cell_row = <ls_cell>-cell_row - cv_diff.
          READ TABLE io_sheet->sheet_content INTO ls_cell
            WITH KEY cell_column = <ls_cell>-cell_column
                     cell_row    = lv_cell_row.
          REPLACE ALL OCCURRENCES OF lv_search IN <ls_cell>-cell_value WITH ls_cell-cell_value.
        ENDLOOP.

        IF lines( lt_matches ) = 1.
          lv_cell_row = <ls_cell>-cell_row - cv_diff.
          READ TABLE io_sheet->sheet_content INTO ls_cell
            WITH KEY cell_column = <ls_cell>-cell_column
                     cell_row    = lv_cell_row.
          <ls_cell>-data_type = ls_cell-data_type.
        ENDIF.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD fill_sheet.

    DATA: lo_worksheet      TYPE REF TO Lcl_excel_worksheet,
          lt_sheet_cells    TYPE tt_cell_data_no_key,
          lt_merged_cells   TYPE Lcl_excel_worksheet=>mty_ts_merge,
          lt_merged_cells_2 TYPE Lcl_excel_worksheet=>mty_ts_merge,
          lv_initial_diff   TYPE i.
    FIELD-SYMBOLS:
      <any_data>       TYPE any,
      <ls_sheet_cell>  TYPE zexcel_s_cell_data,
      <ls_merged_cell> TYPE Lcl_excel_worksheet=>mty_merge.


    lo_worksheet = mo_excel->get_worksheet_by_name( iv_data-sheet ).

    lt_sheet_cells = lo_worksheet->sheet_content.
    lt_merged_cells = lo_worksheet->mt_merged_cells.

    ASSIGN iv_data-data->* TO <any_data>.

    fill_range(
      EXPORTING
        io_sheet        = lo_worksheet
        iv_range_length = 0
        iv_sheet        = iv_data-sheet
        iv_parent       = 0
        iv_data         = <any_data>
      CHANGING
        ct_cells        = lt_sheet_cells
        ct_merged_cells = lt_merged_cells
        cv_diff         = lv_initial_diff  ).


    CLEAR lo_worksheet->sheet_content.

    LOOP AT lt_sheet_cells ASSIGNING <ls_sheet_cell>.
      INSERT <ls_sheet_cell> INTO TABLE lo_worksheet->sheet_content.
    ENDLOOP.

    lt_merged_cells_2 = lo_worksheet->mt_merged_cells.
    LOOP AT lt_merged_cells_2 ASSIGNING <ls_merged_cell>.
      lo_worksheet->delete_merge( ip_cell_column = <ls_merged_cell>-col_from ip_cell_row = <ls_merged_cell>-row_from ).
    ENDLOOP.

    LOOP AT lt_merged_cells ASSIGNING <ls_merged_cell>.
      lo_worksheet->set_merge(
          ip_column_start = <ls_merged_cell>-col_from
          ip_column_end   = <ls_merged_cell>-col_to
          ip_row          = <ls_merged_cell>-row_from
          ip_row_to       = <ls_merged_cell>-row_to ).
    ENDLOOP.

  ENDMETHOD.
  METHOD find_var.

    DATA: lv_row            TYPE i,
          lv_column         TYPE i,
          lv_column_alpha   TYPE string,
          lv_value          TYPE string,
          ls_name_style     TYPE ts_name_style,
          lo_style          TYPE REF TO Lcl_excel_style,
          lo_worksheet      TYPE REF TO Lcl_excel_worksheet,
          ls_variable       TYPE ts_variable,
          lv_highest_column TYPE zexcel_cell_column,
          lv_highest_row    TYPE int4,
          lt_matches        TYPE match_result_tab,
          lv_search         TYPE string,
          lv_replace        TYPE string.

    FIELD-SYMBOLS:
      <ls_match>      TYPE match_result,
      <ls_range>      TYPE ts_range,
      <lv_sheet>      TYPE zexcel_sheet_title,
      <ls_name_style> TYPE ts_name_style.


    LOOP AT mt_sheet ASSIGNING <lv_sheet>.

      lo_worksheet ?= mo_excel->get_worksheet_by_name(  <lv_sheet> ).
      lv_row = 1.

      lv_highest_column = lo_worksheet->get_highest_column( ).
      lv_highest_row    = lo_worksheet->get_highest_row( ).

      WHILE lv_row <= lv_highest_row.
        lv_column = 1.
        WHILE lv_column <= lv_highest_column.
          lv_column_alpha = Lcl_excel_common=>convert_column2alpha( lv_column ).
          CLEAR lo_style.
          lo_worksheet->get_cell(
            EXPORTING
              ip_column = lv_column_alpha
              ip_row    = lv_row
            IMPORTING
              ep_value = lv_value
              ep_style = lo_style ).

          FIND ALL OCCURRENCES OF REGEX '\[[^\]]*\]' IN lv_value RESULTS lt_matches.

          LOOP AT lt_matches ASSIGNING <ls_match>.
            lv_search = lv_value+<ls_match>-offset(<ls_match>-length).
            lv_replace = lv_search.

            TRANSLATE lv_replace TO UPPER CASE.

            CLEAR ls_variable.

            ls_variable-sheet = <lv_sheet>.
            ls_variable-name = lv_replace.
            TRANSLATE ls_variable-name USING '[ ] '.
            CONDENSE ls_variable-name .

            LOOP AT mt_range ASSIGNING <ls_range> WHERE sheet = <lv_sheet>
                                                    AND start <= lv_row
                                                    AND stop >= lv_row.
              ls_variable-parent = <ls_range>-id.
              EXIT.
            ENDLOOP.

            READ TABLE mt_var TRANSPORTING NO FIELDS WITH KEY sheet = ls_variable-sheet name = ls_variable-name parent = ls_variable-parent.
            IF sy-subrc NE 0.
              APPEND ls_variable TO mt_var.
            ENDIF.

            READ TABLE mt_name_styles WITH KEY sheet = ls_variable-sheet name = ls_variable-name parent = ls_variable-parent ASSIGNING <ls_name_style>.
            IF sy-subrc NE 0.
              CLEAR ls_name_style.
              ls_name_style-sheet = <lv_sheet>.
              ls_name_style-name = ls_variable-name.
              ls_name_style-parent = ls_variable-parent.
              APPEND ls_name_style TO mt_name_styles ASSIGNING <ls_name_style>.
            ENDIF.
            IF lo_style IS NOT BOUND.
              <ls_name_style>-text_counter = <ls_name_style>-text_counter + 1.
            ELSE.
              IF lo_style->number_format->format_code CA '0'
                   AND lo_style->number_format->format_code NS '0]'.
                <ls_name_style>-numeric_counter = <ls_name_style>-numeric_counter + 1.
              ELSEIF lo_style->number_format->format_code CA 'm'
                 AND lo_style->number_format->format_code CA 'd'
                 AND lo_style->number_format->format_code NA 'h'.
                <ls_name_style>-date_counter = <ls_name_style>-date_counter + 1.
              ELSEIF ( lo_style->number_format->format_code CA 'h' OR lo_style->number_format->format_code CA 's' )
                 AND lo_style->number_format->format_code NA 'd'.
                <ls_name_style>-time_counter = <ls_name_style>-time_counter + 1.
              ELSE.
                <ls_name_style>-text_counter = <ls_name_style>-text_counter + 1.
              ENDIF.
            ENDIF.

          ENDLOOP.
          lv_column = lv_column + 1.
        ENDWHILE.
        lv_row = lv_row + 1.
      ENDWHILE.
    ENDLOOP.

    SORT mt_range BY id .
  ENDMETHOD.
  METHOD get_range.

    DATA:
      lo_worksheets_iterator TYPE REF TO Lcl_excel_collection_iterator,
      lo_worksheet           TYPE REF TO Lcl_excel_worksheet,
      lo_range_iterator      TYPE REF TO Lcl_excel_collection_iterator,
      lo_range               TYPE REF TO Lcl_excel_range.


    lo_worksheets_iterator = mo_excel->get_worksheets_iterator( ).


    WHILE lo_worksheets_iterator->has_next( ) = abap_true.
      lo_worksheet ?= lo_worksheets_iterator->get_next( ).
      APPEND lo_worksheet->get_title( ) TO mt_sheet.
    ENDWHILE.

    lo_range_iterator = mo_excel->get_ranges_iterator( ).

    WHILE lo_range_iterator->has_next(  ) = abap_true.
      lo_range ?= lo_range_iterator->get_next( ).
      validate_range( lo_range ).
    ENDWHILE.

  ENDMETHOD.
  METHOD sign_range.

    DATA: lv_tabix TYPE i.
    FIELD-SYMBOLS:
      <ls_range>   TYPE ts_range,
      <ls_range_2> TYPE ts_range.

    LOOP AT mt_range ASSIGNING <ls_range>.
      <ls_range>-id = sy-tabix.
    ENDLOOP.

    LOOP AT mt_range ASSIGNING  <ls_range>.
      lv_tabix = sy-tabix + 1.

      LOOP AT mt_range ASSIGNING  <ls_range_2>
                                  FROM lv_tabix
                                  WHERE sheet = <ls_range>-sheet.

        IF <ls_range_2>-start >= <ls_range>-start AND <ls_range_2>-stop <= <ls_range>-stop.
          <ls_range_2>-parent = <ls_range>-id.
        ENDIF.

      ENDLOOP.

    ENDLOOP.

    SORT mt_range BY id DESCENDING.
  ENDMETHOD.
  METHOD validate_range.

    DATA: lv_range_name       TYPE string,
          lv_range_address    TYPE string,
          lv_range_start      TYPE string,
          lv_range_stop       TYPE string,
          lv_range_sheet      TYPE string,
          lv_tmp_value        TYPE string,
          lt_cell_coord_parts TYPE TABLE OF string,
          lv_cell_coord_start TYPE string,
          lv_cell_coord_stop  TYPE string,
          lv_column_start     TYPE zexcel_cell_column_alpha,
          lv_column_end       TYPE zexcel_cell_column_alpha,
          lv_row_start        TYPE zexcel_cell_row,
          lv_row_end          TYPE zexcel_cell_row.

    FIELD-SYMBOLS: <ls_range> TYPE ts_range.


    lv_range_name = io_range->name.
    TRANSLATE lv_range_name TO UPPER CASE.
    lv_range_address = io_range->get_value( ).

    SPLIT lv_range_address AT '!' INTO lv_range_sheet lv_tmp_value.

    SPLIT lv_tmp_value AT ':' INTO lv_range_start lv_range_stop.

    SPLIT lv_range_start AT '$' INTO TABLE lt_cell_coord_parts.

    IF lines( lt_cell_coord_parts ) > 2.
      TRY.
          Lcl_excel_common=>convert_range2column_a_row(
            EXPORTING
              i_range        = lv_range_address
            IMPORTING
              e_column_start = lv_column_start
              e_column_end   = lv_column_end
              e_row_start    = lv_row_start
              e_row_end      = lv_row_end
          ).
        CATCH Lcx_excel.    "
          RETURN.
      ENDTRY.
      IF lv_column_start = 'A' AND lv_column_end = 'XFD'.
        lv_cell_coord_start = |{ lv_row_start }|.
        lv_cell_coord_stop = |{ lv_row_end }|.
        CLEAR lt_cell_coord_parts.
        CLEAR lv_range_stop.
      ELSE.
        RETURN.
      ENDIF.
    ENDIF.

    IF lines( lt_cell_coord_parts ) >= 2.
      READ TABLE lt_cell_coord_parts INTO lv_cell_coord_start INDEX 2.
    ENDIF.

    IF lv_cell_coord_start CO '0123456789'.
      APPEND INITIAL LINE TO mt_range ASSIGNING <ls_range>.
      <ls_range>-sheet = lv_range_sheet.
      <ls_range>-name = lv_range_name.
      <ls_range>-start = lv_cell_coord_start.

      SPLIT lv_range_stop AT '$' INTO TABLE lt_cell_coord_parts.
      READ TABLE lt_cell_coord_parts INTO lv_cell_coord_stop INDEX 2.
      <ls_range>-stop = lv_cell_coord_stop.

      <ls_range>-length = <ls_range>-stop - <ls_range>-start + 1.

    ENDIF.

  ENDMETHOD.
endclass. "LCL_EXCEL_FILL_TEMPLATE implementation

*>>>>>>> LCL_EXCEL_FONT <<<<<<<*

*"* macro definitions
*include Lcl_excel_font================ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_font================ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


*"* test class
*include Lcl_excel_font================ccau.



class LCL_EXCEL_FONT implementation.
*"* method's implementations
*include methods.
  METHOD calculate_text_width.

    CONSTANTS lc_excel_cell_padding TYPE f VALUE '0.75'.

    DATA: ld_current_character       TYPE c LENGTH 1,
          lt_itcfc                   TYPE STANDARD TABLE OF itcfc,
          ld_offset                  TYPE i,
          ld_length                  TYPE i,
          ld_uccp                    TYPE i,
          ls_font_metric             TYPE mty_s_font_metric,
          ld_width_from_font_metrics TYPE i,
          ld_font_family             TYPE itcfh-tdfamily,
          lt_font_families           LIKE STANDARD TABLE OF ld_font_family,
          ls_font_cache              TYPE mty_s_font_cache.

    FIELD-SYMBOLS: <ls_font_cache>  TYPE mty_s_font_cache,
                   <ls_font_metric> TYPE mty_s_font_metric,
                   <ls_itcfc>       TYPE itcfc.

    " Check if the same font (font name and font attributes) was already
    " used before
    READ TABLE mth_font_cache
      WITH TABLE KEY
        font_name   = iv_font_name
        font_height = iv_font_height
        flag_bold   = iv_flag_bold
        flag_italic = iv_flag_italic
      ASSIGNING <ls_font_cache>.

    IF sy-subrc <> 0.
      " Font is used for the first time
      " Add the font to our local font cache
      ls_font_cache-font_name   = iv_font_name.
      ls_font_cache-font_height = iv_font_height.
      ls_font_cache-flag_bold   = iv_flag_bold.
      ls_font_cache-flag_italic = iv_flag_italic.
      INSERT ls_font_cache INTO TABLE mth_font_cache
        ASSIGNING <ls_font_cache>.

      " Determine the SAPscript font family name from the Excel
      " font name
      SELECT tdfamily
        FROM tfo01
        INTO TABLE lt_font_families
        UP TO 1 ROWS
        WHERE tdtext = iv_font_name
        ORDER BY PRIMARY KEY.

      " Check if a matching font family was found
      " Fonts can be uploaded from TTF files using transaction SE73
      IF lines( lt_font_families ) > 0.
        READ TABLE lt_font_families INDEX 1 INTO ld_font_family.

        " Load font metrics (returns a table with the size of each letter
        " in the font)
        CALL FUNCTION 'LOAD_FONT'
          EXPORTING
            family      = ld_font_family
            height      = iv_font_height
            printer     = 'SWIN'
            bold        = iv_flag_bold
            italic      = iv_flag_italic
          TABLES
            metric      = lt_itcfc
          EXCEPTIONS
            font_family = 1
            codepage    = 2
            device_type = 3
            OTHERS      = 4.
        IF sy-subrc <> 0.
          CLEAR lt_itcfc.
        ENDIF.

        " For faster access, convert each character number to the actual
        " character, and store the characters and their sizes in a hash
        " table
        LOOP AT lt_itcfc ASSIGNING <ls_itcfc>.
          ld_uccp = <ls_itcfc>-cpcharno.
          ls_font_metric-char =
            cl_abap_conv_in_ce=>uccpi( ld_uccp ).
          ls_font_metric-char_width = <ls_itcfc>-tdcwidths.
          INSERT ls_font_metric
            INTO TABLE <ls_font_cache>-th_font_metrics.
        ENDLOOP.

      ENDIF.
    ENDIF.

    " Calculate the cell width
    " If available, use font metrics
    IF lines( <ls_font_cache>-th_font_metrics ) = 0.
      " Font metrics are not available
      " -> Calculate the cell width using only the font size
      ld_length = strlen( iv_cell_value ).
      rv_width = ld_length * iv_font_height / lc_default_font_height + lc_excel_cell_padding.

    ELSE.
      " Font metrics are available

      " Calculate the size of the text by adding the sizes of each
      " letter
      ld_length = strlen( iv_cell_value ).
      DO ld_length TIMES.
        " Subtract 1, because the first character is at offset 0
        ld_offset = sy-index - 1.

        " Read the current character from the cell value
        ld_current_character = iv_cell_value+ld_offset(1).

        " Look up the size of the current letter
        READ TABLE <ls_font_cache>-th_font_metrics
          WITH TABLE KEY char = ld_current_character
          ASSIGNING <ls_font_metric>.
        IF sy-subrc = 0.
          " The size of the letter is known
          " -> Add the actual size of the letter
          ADD <ls_font_metric>-char_width TO ld_width_from_font_metrics.
        ELSE.
          " The size of the letter is unknown
          " -> Add the font height as the default letter size
          ADD iv_font_height TO ld_width_from_font_metrics.
        ENDIF.
      ENDDO.

      " Add cell padding (Excel makes columns a bit wider than the space
      " that is needed for the text itself) and convert unit
      " (division by 100)
      rv_width = ld_width_from_font_metrics / 100 + lc_excel_cell_padding.
    ENDIF.

  ENDMETHOD.
endclass. "LCL_EXCEL_FONT implementation

*>>>>>>> LCL_EXCEL_GRAPH <<<<<<<*

*"* macro definitions
*include Lcl_excel_graph===============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_graph===============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_GRAPH implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    "Load default values
    me->pagemargins-b = '0.75'.
    me->pagemargins-l = '0.7'.
    me->pagemargins-r = '0.7'.
    me->pagemargins-t = '0.75'.
    me->pagemargins-header = '0.3'.
    me->pagemargins-footer = '0.3'.
  ENDMETHOD.
  METHOD create_serie.
    DATA ls_serie TYPE s_series.

    DATA: lv_start_row_c TYPE c LENGTH 7,
          lv_stop_row_c  TYPE c LENGTH 7.


    IF ip_lbl IS NOT SUPPLIED.
      lv_stop_row_c = ip_lbl_to_row.
      SHIFT lv_stop_row_c RIGHT DELETING TRAILING space.
      SHIFT lv_stop_row_c LEFT DELETING LEADING space.
      lv_start_row_c = ip_lbl_from_row.
      SHIFT lv_start_row_c RIGHT DELETING TRAILING space.
      SHIFT lv_start_row_c LEFT DELETING LEADING space.
      ls_serie-lbl = ip_sheet.
      ls_serie-lbl = Lcl_excel_common=>escape_string( ip_value = ls_serie-lbl ).
      CONCATENATE ls_serie-lbl '!$' ip_lbl_from_col '$' lv_start_row_c ':$' ip_lbl_to_col '$' lv_stop_row_c INTO ls_serie-lbl.
      CLEAR: lv_start_row_c, lv_stop_row_c.
    ELSE.
      ls_serie-lbl = ip_lbl.
    ENDIF.
    IF ip_ref IS NOT SUPPLIED.
      lv_stop_row_c = ip_ref_to_row.
      SHIFT lv_stop_row_c RIGHT DELETING TRAILING space.
      SHIFT lv_stop_row_c LEFT DELETING LEADING space.
      lv_start_row_c = ip_ref_from_row.
      SHIFT lv_start_row_c RIGHT DELETING TRAILING space.
      SHIFT lv_start_row_c LEFT DELETING LEADING space.
      ls_serie-ref = ip_sheet.
      ls_serie-ref = Lcl_excel_common=>escape_string( ip_value = ls_serie-ref ).
      CONCATENATE ls_serie-ref '!$' ip_ref_from_col '$' lv_start_row_c ':$' ip_ref_to_col '$' lv_stop_row_c INTO ls_serie-ref.
      CLEAR: lv_start_row_c, lv_stop_row_c.
    ELSE.
      ls_serie-ref = ip_ref.
    ENDIF.
    ls_serie-idx = ip_idx.
    ls_serie-order = ip_order.
    ls_serie-invertifnegative = ip_invertifnegative.
    ls_serie-symbol = ip_symbol.
    ls_serie-smooth = ip_smooth.
    ls_serie-sername = ip_sername.
    APPEND ls_serie TO me->series.
    SORT me->series BY order ASCENDING.
  ENDMETHOD.
  METHOD set_print_lbl.
    me->print_label = ip_value.
  ENDMETHOD.
  METHOD set_style.
    me->ns_c14styleval = ip_style-c14style.
    CONDENSE me->ns_c14styleval NO-GAPS.
    me->ns_styleval = ip_style-cstyle.
    CONDENSE me->ns_styleval NO-GAPS.
  ENDMETHOD.
  METHOD set_title.
    me->title = ip_value.
  ENDMETHOD.
endclass. "LCL_EXCEL_GRAPH implementation

*>>>>>>> LCL_EXCEL_GRAPH_BARS <<<<<<<*

*"* macro definitions
*include Lcl_excel_graph_bars==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_graph_bars==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_GRAPH_BARS implementation.
*"* method's implementations
*include methods.
  METHOD create_ax.
    DATA ls_ax TYPE s_ax.
    ls_ax-type = ip_type.

    IF ip_type = c_catax.
      IF ip_axid IS SUPPLIED.
        ls_ax-axid = ip_axid.
      ELSE.
        ls_ax-axid = '1'.
      ENDIF.
      IF ip_orientation IS SUPPLIED.
        ls_ax-orientation = ip_orientation.
      ELSE.
        ls_ax-orientation = 'minMax'.
      ENDIF.
      IF ip_delete IS SUPPLIED.
        ls_ax-delete = ip_delete.
      ELSE.
        ls_ax-delete = '0'.
      ENDIF.
      IF ip_axpos IS SUPPLIED.
        ls_ax-axpos = ip_axpos.
      ELSE.
        ls_ax-axpos = 'b'.
      ENDIF.
      IF ip_formatcode IS SUPPLIED.
        ls_ax-formatcode = ip_formatcode.
      ELSE.
        ls_ax-formatcode = 'General'.
      ENDIF.
      IF ip_sourcelinked IS SUPPLIED.
        ls_ax-sourcelinked = ip_sourcelinked.
      ELSE.
        ls_ax-sourcelinked = '1'.
      ENDIF.
      IF ip_majortickmark IS SUPPLIED.
        ls_ax-majortickmark = ip_majortickmark.
      ELSE.
        ls_ax-majortickmark = 'out'.
      ENDIF.
      IF ip_minortickmark IS SUPPLIED.
        ls_ax-minortickmark = ip_minortickmark.
      ELSE.
        ls_ax-minortickmark = 'none'.
      ENDIF.
      IF ip_ticklblpos IS SUPPLIED.
        ls_ax-ticklblpos = ip_ticklblpos.
      ELSE.
        ls_ax-ticklblpos = 'nextTo'.
      ENDIF.
      IF ip_crossax IS SUPPLIED.
        ls_ax-crossax = ip_crossax.
      ELSE.
        ls_ax-crossax = '2'.
      ENDIF.
      IF ip_crosses IS SUPPLIED.
        ls_ax-crosses = ip_crosses.
      ELSE.
        ls_ax-crosses = 'autoZero'.
      ENDIF.
      IF ip_auto IS SUPPLIED.
        ls_ax-auto = ip_auto.
      ELSE.
        ls_ax-auto = '1'.
      ENDIF.
      IF ip_lblalgn IS SUPPLIED.
        ls_ax-lblalgn = ip_lblalgn.
      ELSE.
        ls_ax-lblalgn = 'ctr'.
      ENDIF.
      IF ip_lbloffset IS SUPPLIED.
        ls_ax-lbloffset = ip_lbloffset.
      ELSE.
        ls_ax-lbloffset = '100'.
      ENDIF.
      IF ip_nomultilvllbl IS SUPPLIED.
        ls_ax-nomultilvllbl = ip_nomultilvllbl.
      ELSE.
        ls_ax-nomultilvllbl = '0'.
      ENDIF.
    ELSEIF ip_type = c_valax.
      IF ip_axid IS SUPPLIED.
        ls_ax-axid = ip_axid.
      ELSE.
        ls_ax-axid = '2'.
      ENDIF.
      IF ip_orientation IS SUPPLIED.
        ls_ax-orientation = ip_orientation.
      ELSE.
        ls_ax-orientation = 'minMax'.
      ENDIF.
      IF ip_delete IS SUPPLIED.
        ls_ax-delete = ip_delete.
      ELSE.
        ls_ax-delete = '0'.
      ENDIF.
      IF ip_axpos IS SUPPLIED.
        ls_ax-axpos = ip_axpos.
      ELSE.
        ls_ax-axpos = 'l'.
      ENDIF.
      IF ip_formatcode IS SUPPLIED.
        ls_ax-formatcode = ip_formatcode.
      ELSE.
        ls_ax-formatcode = 'General'.
      ENDIF.
      IF ip_sourcelinked IS SUPPLIED.
        ls_ax-sourcelinked = ip_sourcelinked.
      ELSE.
        ls_ax-sourcelinked = '1'.
      ENDIF.
      IF ip_majortickmark IS SUPPLIED.
        ls_ax-majortickmark = ip_majortickmark.
      ELSE.
        ls_ax-majortickmark = 'out'.
      ENDIF.
      IF ip_minortickmark IS SUPPLIED.
        ls_ax-minortickmark = ip_minortickmark.
      ELSE.
        ls_ax-minortickmark = 'none'.
      ENDIF.
      IF ip_ticklblpos IS SUPPLIED.
        ls_ax-ticklblpos = ip_ticklblpos.
      ELSE.
        ls_ax-ticklblpos = 'nextTo'.
      ENDIF.
      IF ip_crossax IS SUPPLIED.
        ls_ax-crossax = ip_crossax.
      ELSE.
        ls_ax-crossax = '1'.
      ENDIF.
      IF ip_crosses IS SUPPLIED.
        ls_ax-crosses = ip_crosses.
      ELSE.
        ls_ax-crosses = 'autoZero'.
      ENDIF.
      IF ip_crossbetween IS SUPPLIED.
        ls_ax-crossbetween = ip_crossbetween.
      ELSE.
        ls_ax-crossbetween = 'between'.
      ENDIF.
    ENDIF.

    APPEND ls_ax TO me->axes.
    SORT me->axes BY axid ASCENDING.
  ENDMETHOD.
  METHOD set_show_cat_name.
    ns_showcatnameval = ip_value.
  ENDMETHOD.
  METHOD set_show_legend_key.
    ns_showlegendkeyval = ip_value.
  ENDMETHOD.
  METHOD set_show_percent.
    ns_showpercentval = ip_value.
  ENDMETHOD.
  METHOD set_show_ser_name.
    ns_showsernameval = ip_value.
  ENDMETHOD.
  METHOD set_show_values.
    ns_showvalval = ip_value.
  ENDMETHOD.
  METHOD set_varycolor.
    ns_varycolorsval = ip_value.
  ENDMETHOD.
endclass. "LCL_EXCEL_GRAPH_BARS implementation

*>>>>>>> LCL_EXCEL_GRAPH_LINE <<<<<<<*

*"* macro definitions
*include Lcl_excel_graph_line==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_graph_line==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_GRAPH_LINE implementation.
*"* method's implementations
*include methods.
  METHOD create_ax.
    DATA ls_ax TYPE s_ax.
    ls_ax-type = ip_type.

    IF ip_type = c_catax.
      IF ip_axid IS SUPPLIED.
        ls_ax-axid = ip_axid.
      ELSE.
        ls_ax-axid = '1'.
      ENDIF.
      IF ip_orientation IS SUPPLIED.
        ls_ax-orientation = ip_orientation.
      ELSE.
        ls_ax-orientation = 'minMax'.
      ENDIF.
      IF ip_delete IS SUPPLIED.
        ls_ax-delete = ip_delete.
      ELSE.
        ls_ax-delete = '0'.
      ENDIF.
      IF ip_axpos IS SUPPLIED.
        ls_ax-axpos = ip_axpos.
      ELSE.
        ls_ax-axpos = 'b'.
      ENDIF.
      IF ip_formatcode IS SUPPLIED.
        ls_ax-formatcode = ip_formatcode.
      ELSE.
        ls_ax-formatcode = 'General'.
      ENDIF.
      IF ip_sourcelinked IS SUPPLIED.
        ls_ax-sourcelinked = ip_sourcelinked.
      ELSE.
        ls_ax-sourcelinked = '1'.
      ENDIF.
      IF ip_majortickmark IS SUPPLIED.
        ls_ax-majortickmark = ip_majortickmark.
      ELSE.
        ls_ax-majortickmark = 'out'.
      ENDIF.
      IF ip_minortickmark IS SUPPLIED.
        ls_ax-minortickmark = ip_minortickmark.
      ELSE.
        ls_ax-minortickmark = 'none'.
      ENDIF.
      IF ip_ticklblpos IS SUPPLIED.
        ls_ax-ticklblpos = ip_ticklblpos.
      ELSE.
        ls_ax-ticklblpos = 'nextTo'.
      ENDIF.
      IF ip_crossax IS SUPPLIED.
        ls_ax-crossax = ip_crossax.
      ELSE.
        ls_ax-crossax = '2'.
      ENDIF.
      IF ip_crosses IS SUPPLIED.
        ls_ax-crosses = ip_crosses.
      ELSE.
        ls_ax-crosses = 'autoZero'.
      ENDIF.
      IF ip_auto IS SUPPLIED.
        ls_ax-auto = ip_auto.
      ELSE.
        ls_ax-auto = '1'.
      ENDIF.
      IF ip_lblalgn IS SUPPLIED.
        ls_ax-lblalgn = ip_lblalgn.
      ELSE.
        ls_ax-lblalgn = 'ctr'.
      ENDIF.
      IF ip_lbloffset IS SUPPLIED.
        ls_ax-lbloffset = ip_lbloffset.
      ELSE.
        ls_ax-lbloffset = '100'.
      ENDIF.
      IF ip_nomultilvllbl IS SUPPLIED.
        ls_ax-nomultilvllbl = ip_nomultilvllbl.
      ELSE.
        ls_ax-nomultilvllbl = '0'.
      ENDIF.
    ELSEIF ip_type = c_valax.
      IF ip_axid IS SUPPLIED.
        ls_ax-axid = ip_axid.
      ELSE.
        ls_ax-axid = '2'.
      ENDIF.
      IF ip_orientation IS SUPPLIED.
        ls_ax-orientation = ip_orientation.
      ELSE.
        ls_ax-orientation = 'minMax'.
      ENDIF.
      IF ip_delete IS SUPPLIED.
        ls_ax-delete = ip_delete.
      ELSE.
        ls_ax-delete = '0'.
      ENDIF.
      IF ip_axpos IS SUPPLIED.
        ls_ax-axpos = ip_axpos.
      ELSE.
        ls_ax-axpos = 'l'.
      ENDIF.
      IF ip_formatcode IS SUPPLIED.
        ls_ax-formatcode = ip_formatcode.
      ELSE.
        ls_ax-formatcode = 'General'.
      ENDIF.
      IF ip_sourcelinked IS SUPPLIED.
        ls_ax-sourcelinked = ip_sourcelinked.
      ELSE.
        ls_ax-sourcelinked = '1'.
      ENDIF.
      IF ip_majortickmark IS SUPPLIED.
        ls_ax-majortickmark = ip_majortickmark.
      ELSE.
        ls_ax-majortickmark = 'out'.
      ENDIF.
      IF ip_minortickmark IS SUPPLIED.
        ls_ax-minortickmark = ip_minortickmark.
      ELSE.
        ls_ax-minortickmark = 'none'.
      ENDIF.
      IF ip_ticklblpos IS SUPPLIED.
        ls_ax-ticklblpos = ip_ticklblpos.
      ELSE.
        ls_ax-ticklblpos = 'nextTo'.
      ENDIF.
      IF ip_crossax IS SUPPLIED.
        ls_ax-crossax = ip_crossax.
      ELSE.
        ls_ax-crossax = '1'.
      ENDIF.
      IF ip_crosses IS SUPPLIED.
        ls_ax-crosses = ip_crosses.
      ELSE.
        ls_ax-crosses = 'autoZero'.
      ENDIF.
      IF ip_crossbetween IS SUPPLIED.
        ls_ax-crossbetween = ip_crossbetween.
      ELSE.
        ls_ax-crossbetween = 'between'.
      ENDIF.
    ENDIF.

    APPEND ls_ax TO me->axes.
    SORT me->axes BY axid ASCENDING.
  ENDMETHOD.
  METHOD set_show_cat_name.
    ns_showcatnameval = ip_value.
  ENDMETHOD.
  METHOD set_show_legend_key.
    ns_showlegendkeyval = ip_value.
  ENDMETHOD.
  METHOD set_show_percent.
    ns_showpercentval = ip_value.
  ENDMETHOD.
  METHOD set_show_ser_name.
    ns_showsernameval = ip_value.
  ENDMETHOD.
  METHOD set_show_values.
    ns_showvalval = ip_value.
  ENDMETHOD.
  METHOD set_varycolor.
    ns_varycolorsval = ip_value.
  ENDMETHOD.
endclass. "LCL_EXCEL_GRAPH_LINE implementation

*>>>>>>> LCL_EXCEL_GRAPH_PIE <<<<<<<*

*"* macro definitions
*include Lcl_excel_graph_pie===========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_graph_pie===========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_GRAPH_PIE implementation.
*"* method's implementations
*include methods.
  METHOD set_show_cat_name.
    ns_showcatnameval = ip_value.
  ENDMETHOD.
  METHOD set_show_leader_lines.
    ns_showleaderlinesval = ip_value.
  ENDMETHOD.
  METHOD set_show_legend_key.
    ns_showlegendkeyval = ip_value.
  ENDMETHOD.
  METHOD set_show_percent.
    ns_showpercentval = ip_value.
  ENDMETHOD.
  METHOD set_show_ser_name.
    ns_showsernameval = ip_value.
  ENDMETHOD.
  METHOD set_show_values.
    ns_showvalval = ip_value.
  ENDMETHOD.
  METHOD set_varycolor.
    ns_varycolorsval = ip_value.
  ENDMETHOD.
endclass. "LCL_EXCEL_GRAPH_PIE implementation

*>>>>>>> LCL_EXCEL_HYPERLINK <<<<<<<*

*"* macro definitions
*include Lcl_excel_hyperlink===========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_hyperlink===========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_HYPERLINK implementation.
*"* method's implementations
*include methods.
  METHOD create.
    DATA: lo_hyperlink TYPE REF TO Lcl_excel_hyperlink.

    CREATE OBJECT lo_hyperlink.

    lo_hyperlink->location = iv_url.
    lo_hyperlink->internal = iv_internal.

    ov_link = lo_hyperlink.
  ENDMETHOD.
  METHOD create_external_link.

    ov_link = Lcl_excel_hyperlink=>create( iv_url = iv_url
                                           iv_internal = abap_false ).
  ENDMETHOD.
  METHOD create_internal_link.
    ov_link = Lcl_excel_hyperlink=>create( iv_url = iv_location
                                           iv_internal = abap_true ).
  ENDMETHOD.
  METHOD get_ref.
    ev_ref = row.
    CONDENSE ev_ref.
    CONCATENATE column ev_ref INTO ev_ref.
  ENDMETHOD.
  METHOD get_url.
    ev_url = me->location.
  ENDMETHOD.
  METHOD is_internal.
    ev_ret = me->internal.
  ENDMETHOD.
  METHOD set_cell_reference.
    me->column = Lcl_excel_common=>convert_column2alpha( ip_column ). " issue #155 - less restrictive typing for ip_column
    me->row = ip_row.
  ENDMETHOD.
endclass. "LCL_EXCEL_HYPERLINK implementation

*>>>>>>> LCL_EXCEL_LEGACY_PALETTE <<<<<<<*

*"* macro definitions
*include Lcl_excel_legacy_palette======ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_legacy_palette======ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_LEGACY_PALETTE implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    " default Excel palette based on
    " http://msdn.microsoft.com/en-us/library/documentformat.openxml.spreadsheet.indexedcolors.aspx

    APPEND '00000000' TO colors.
    APPEND '00FFFFFF' TO colors.
    APPEND '00FF0000' TO colors.
    APPEND '0000FF00' TO colors.
    APPEND '000000FF' TO colors.
    APPEND '00FFFF00' TO colors.
    APPEND '00FF00FF' TO colors.
    APPEND '0000FFFF' TO colors.
    APPEND '00000000' TO colors.
    APPEND '00FFFFFF' TO colors.

    APPEND '00FF0000' TO colors.
    APPEND '0000FF00' TO colors.
    APPEND '000000FF' TO colors.
    APPEND '00FFFF00' TO colors.
    APPEND '00FF00FF' TO colors.
    APPEND '0000FFFF' TO colors.
    APPEND '00800000' TO colors.
    APPEND '00008000' TO colors.
    APPEND '00000080' TO colors.
    APPEND '00808000' TO colors.

    APPEND '00800080' TO colors.
    APPEND '00008080' TO colors.
    APPEND '00C0C0C0' TO colors.
    APPEND '00808080' TO colors.
    APPEND '009999FF' TO colors.
    APPEND '00993366' TO colors.
    APPEND '00FFFFCC' TO colors.
    APPEND '00CCFFFF' TO colors.
    APPEND '00660066' TO colors.
    APPEND '00FF8080' TO colors.

    APPEND '000066CC' TO colors.
    APPEND '00CCCCFF' TO colors.
    APPEND '00000080' TO colors.
    APPEND '00FF00FF' TO colors.
    APPEND '00FFFF00' TO colors.
    APPEND '0000FFFF' TO colors.
    APPEND '00800080' TO colors.
    APPEND '00800000' TO colors.
    APPEND '00008080' TO colors.
    APPEND '000000FF' TO colors.

    APPEND '0000CCFF' TO colors.
    APPEND '00CCFFFF' TO colors.
    APPEND '00CCFFCC' TO colors.
    APPEND '00FFFF99' TO colors.
    APPEND '0099CCFF' TO colors.
    APPEND '00FF99CC' TO colors.
    APPEND '00CC99FF' TO colors.
    APPEND '00FFCC99' TO colors.
    APPEND '003366FF' TO colors.
    APPEND '0033CCCC' TO colors.

    APPEND '0099CC00' TO colors.
    APPEND '00FFCC00' TO colors.
    APPEND '00FF9900' TO colors.
    APPEND '00FF6600' TO colors.
    APPEND '00666699' TO colors.
    APPEND '00969696' TO colors.
    APPEND '00003366' TO colors.
    APPEND '00339966' TO colors.
    APPEND '00003300' TO colors.
    APPEND '00333300' TO colors.

    APPEND '00993300' TO colors.
    APPEND '00993366' TO colors.
    APPEND '00333399' TO colors.
    APPEND '00333333' TO colors.

  ENDMETHOD.
  METHOD get_color.
    DATA: lv_index TYPE i.

    lv_index = ip_index + 1.
    READ TABLE colors INTO ep_color INDEX lv_index.
    IF sy-subrc <> 0.
      Lcx_excel=>raise_text( 'Invalid color index' ).
    ENDIF.
  ENDMETHOD.
  METHOD get_colors.
    ep_colors = colors.
  ENDMETHOD.
  METHOD is_modified.
    ep_modified = modified.
  ENDMETHOD.
  METHOD set_color.
    DATA: lv_index TYPE i.

    FIELD-SYMBOLS: <lv_color> LIKE LINE OF colors.

    lv_index = ip_index + 1.
    READ TABLE colors ASSIGNING <lv_color> INDEX lv_index.
    IF sy-subrc <> 0.
      Lcx_excel=>raise_text( 'Invalid color index' ).
    ENDIF.

    IF <lv_color> <> ip_color.
      modified = abap_true.
      <lv_color> = ip_color.
    ENDIF.

  ENDMETHOD.
endclass. "LCL_EXCEL_LEGACY_PALETTE implementation

*>>>>>>> LCL_EXCEL_RANGE <<<<<<<*

*"* macro definitions
*include Lcl_excel_range===============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_range===============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_RANGE implementation.
*"* method's implementations
*include methods.
  METHOD get_guid.

    ep_guid = me->guid.

  ENDMETHOD.
  METHOD get_value.

    ep_value = me->value.

  ENDMETHOD.
  METHOD set_range_value.
    me->value = ip_value.
  ENDMETHOD.
  METHOD set_value.
    DATA: lv_start_row_c TYPE c LENGTH 7,
          lv_stop_row_c  TYPE c LENGTH 7,
          lv_value       TYPE string.
    lv_stop_row_c = ip_stop_row.
    SHIFT lv_stop_row_c RIGHT DELETING TRAILING space.
    SHIFT lv_stop_row_c LEFT DELETING LEADING space.
    lv_start_row_c = ip_start_row.
    SHIFT lv_start_row_c RIGHT DELETING TRAILING space.
    SHIFT lv_start_row_c LEFT DELETING LEADING space.
    lv_value = ip_sheet_name.
    me->value = Lcl_excel_common=>escape_string( ip_value = lv_value ).

    IF ip_stop_column IS INITIAL AND ip_stop_row IS INITIAL.
      CONCATENATE me->value '!$' ip_start_column '$' lv_start_row_c INTO me->value.
    ELSE.
      CONCATENATE me->value '!$' ip_start_column '$' lv_start_row_c ':$' ip_stop_column '$' lv_stop_row_c INTO me->value.
    ENDIF.
  ENDMETHOD.
endclass. "LCL_EXCEL_RANGE implementation

*>>>>>>> LCL_EXCEL_RANGES <<<<<<<*

*"* macro definitions
*include Lcl_excel_ranges==============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_ranges==============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_RANGES implementation.
*"* method's implementations
*include methods.
  METHOD add.
    ranges->add( ip_range ).
  ENDMETHOD.
  METHOD clear.
    ranges->clear( ).
  ENDMETHOD.
  METHOD constructor.


    CREATE OBJECT ranges.

  ENDMETHOD.
  METHOD get.
    eo_range ?= ranges->get( ip_index ).
  ENDMETHOD.
  METHOD get_iterator.
    eo_iterator ?= ranges->get_iterator( ).
  ENDMETHOD.
  METHOD is_empty.
    is_empty = ranges->is_empty( ).
  ENDMETHOD.
  METHOD remove.
    ranges->remove( ip_range ).
  ENDMETHOD.
  METHOD size.
    ep_size = ranges->size( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_RANGES implementation

*>>>>>>> LCL_EXCEL_READER_HUGE_FILE <<<<<<<*

*"* macro definitions
*include Lcl_excel_reader_huge_file====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_reader_huge_file====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations

* Signal "not found"
CLASS SHRITEFUH64VYIPN5I4UIDBJAAHSE4 IMPLEMENTATION.
  METHOD constructor.
    super->constructor( textid = textid previous = previous ).
    me->error = error.
  ENDMETHOD.                    "constructor
  METHOD if_message~get_text.
    result = error.
  ENDMETHOD.                    "if_message~get_text
ENDCLASS.                    "SHRITEFUH64VYIPN5I4UIDBJAAHSE4 IMPLEMENTATION

*"* test class
*include Lcl_excel_reader_huge_file====ccau.
*"* use this source file for your ABAP unit test classes
*CLASS SHRITEFUH64VYIPN5I4UIDBJAAJSE4 DEFINITION DEFERRED.
*CLASS Lcl_excel_reader_huge_file DEFINITION LOCAL FRIENDS SHRITEFUH64VYIPN5I4UIDBJAAJSE4.

*

*

class LCL_EXCEL_READER_HUGE_FILE implementation.
*"* method's implementations
*include methods.
  METHOD fill_cell_from_attributes.

    WHILE io_reader->node_type NE c_end_of_stream.
      io_reader->next_attribute( ).
      IF io_reader->node_type NE c_attribute.
        EXIT.
      ENDIF.
      CASE io_reader->name.
        WHEN `t`.
          es_cell-datatype = io_reader->value.
        WHEN `s`.
          IF io_reader->value IS NOT INITIAL.
            es_cell-style = get_style( io_reader->value ).
          ENDIF.
        WHEN `r`.
          es_cell-coord = get_cell_coord( io_reader->value ).
      ENDCASE.
    ENDWHILE.

  ENDMETHOD.
  METHOD get_cell_coord.

    Lcl_excel_common=>convert_columnrow2column_a_row(
      EXPORTING
        i_columnrow = iv_coord
      IMPORTING
        e_column    = es_coord-column
        e_row       = es_coord-row
      ).

  ENDMETHOD.
  METHOD get_shared_string.
    DATA: lv_tabix TYPE i,
          lv_error TYPE string.
    FIELD-SYMBOLS: <ls_shared_string> TYPE t_shared_string.
    lv_tabix = iv_index + 1.
    READ TABLE shared_strings ASSIGNING <ls_shared_string> INDEX lv_tabix.
    IF sy-subrc NE 0.
      CONCATENATE 'Entry ' iv_index ' not found in Shared String Table' INTO lv_error.
      RAISE EXCEPTION TYPE SHRITEFUH64VYIPN5I4UIDBJAAHSE4
        EXPORTING
          error = lv_error.
    ENDIF.
    ev_value = <ls_shared_string>-value.
  ENDMETHOD.
  METHOD get_style.

    DATA: lv_tabix TYPE i,
          lo_style TYPE REF TO Lcl_excel_style,
          lv_error TYPE string.

    IF gs_buffer_style-index NE iv_index.
      lv_tabix = iv_index + 1.
      READ TABLE styles INTO lo_style INDEX lv_tabix.
      IF sy-subrc NE 0.
        CONCATENATE 'Entry ' iv_index ' not found in Style Table' INTO lv_error.
        RAISE EXCEPTION TYPE SHRITEFUH64VYIPN5I4UIDBJAAHSE4
          EXPORTING
            error = lv_error.
      ELSE.
        gs_buffer_style-index = iv_index.
        gs_buffer_style-guid  = lo_style->get_guid( ).
      ENDIF.
    ENDIF.

    ev_style_guid = gs_buffer_style-guid.

  ENDMETHOD.
  METHOD get_sxml_reader.

    DATA: lv_xml TYPE xstring.

    lv_xml = get_from_zip_archive( iv_path ).
    eo_reader = cl_sxml_string_reader=>create( lv_xml ).

  ENDMETHOD.
  METHOD load_shared_strings.

    DATA: lo_reader TYPE REF TO if_sxml_reader.
    DATA: lt_shared_strings TYPE TABLE OF string,
          ls_shared_string  TYPE t_shared_string.
    FIELD-SYMBOLS: <lv_shared_string> TYPE string.

    lo_reader = get_sxml_reader( ip_path ).

    lt_shared_strings = read_shared_strings( lo_reader ).
    LOOP AT lt_shared_strings ASSIGNING <lv_shared_string>.
      ls_shared_string-value = unescape_string_value( <lv_shared_string> ).
      APPEND ls_shared_string TO shared_strings.
    ENDLOOP.

  ENDMETHOD.
  METHOD load_worksheet.

    DATA: lo_reader TYPE REF TO if_sxml_reader.
    DATA: lx_not_found TYPE REF TO SHRITEFUH64VYIPN5I4UIDBJAAHSE4.

    lo_reader = get_sxml_reader( ip_path ).

    TRY.

        read_worksheet_data( io_reader    = lo_reader
                             io_worksheet = io_worksheet ).

      CATCH SHRITEFUH64VYIPN5I4UIDBJAAHSE4 INTO lx_not_found.
        Lcx_excel=>raise_text( lx_not_found->error ).
    ENDTRY.
  ENDMETHOD.
  METHOD put_cell_to_worksheet.
    CHECK is_cell-value IS NOT INITIAL
       OR is_cell-formula IS NOT INITIAL
       OR is_cell-style IS NOT INITIAL.
    CALL METHOD io_worksheet->set_cell
      EXPORTING
        ip_column    = is_cell-column
        ip_row       = is_cell-row
        ip_value     = is_cell-value
        ip_formula   = is_cell-formula
        ip_data_type = is_cell-datatype
        ip_style     = is_cell-style.
  ENDMETHOD.
  METHOD read_shared_strings.

    DATA lv_value TYPE string.

    WHILE io_reader->node_type NE c_end_of_stream.
      io_reader->next_node( ).
      CASE io_reader->name.
        WHEN 'si'.
          CASE io_reader->node_type .
            WHEN c_element_open .
              CLEAR lv_value .
            WHEN c_element_close .
              APPEND lv_value TO et_shared_strings.
          ENDCASE .
        WHEN 't'.
          CASE io_reader->node_type .
            WHEN c_node_value .
              lv_value = lv_value && io_reader->value .
          ENDCASE .
      ENDCASE .
    ENDWHILE.

  ENDMETHOD.
  METHOD read_worksheet_data.

    DATA: ls_cell   TYPE t_cell.

* Skip to <sheetData> element
    skip_to(  iv_element_name = `sheetData`  io_reader = io_reader ).

* Main loop: Evaluate the <c> elements and its children
    WHILE io_reader->node_type NE c_end_of_stream.
      io_reader->next_node( ).
      CASE io_reader->node_type.
        WHEN c_element_open.
          IF io_reader->name EQ `c`.
            ls_cell = fill_cell_from_attributes( io_reader ).
          ENDIF.
        WHEN c_node_value.
          CASE io_reader->name.
            WHEN `f`.
              ls_cell-formula = io_reader->value.
            WHEN `v`.
              IF ls_cell-datatype EQ `s`.
                ls_cell-value = get_shared_string( io_reader->value ).
              ELSE.
                ls_cell-value = io_reader->value.
              ENDIF.
            WHEN `t` OR `is`.
              ls_cell-value = io_reader->value.
          ENDCASE.
        WHEN c_element_close.
          CASE io_reader->name.
            WHEN `c`.
              put_cell_to_worksheet( is_cell = ls_cell io_worksheet = io_worksheet ).
            WHEN `sheetData`.
              EXIT.
          ENDCASE.
      ENDCASE.
    ENDWHILE.

  ENDMETHOD.
  METHOD skip_to.

    DATA: lv_error TYPE string.

* Skip forward to given element
    WHILE io_reader->name NE iv_element_name OR
          io_reader->node_type NE c_element_open.
      io_reader->next_node( ).
      IF io_reader->node_type = c_end_of_stream.
        CONCATENATE 'XML error: Didn''t find element <' iv_element_name '>' INTO lv_error.
        RAISE EXCEPTION TYPE SHRITEFUH64VYIPN5I4UIDBJAAHSE4
          EXPORTING
            error = lv_error.
      ENDIF.
    ENDWHILE.


  ENDMETHOD.
endclass. "LCL_EXCEL_READER_HUGE_FILE implementation

*>>>>>>> LCL_EXCEL_READER_XLSM <<<<<<<*

*"* macro definitions
*include Lcl_excel_reader_xlsm=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_reader_xlsm=========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_READER_XLSM implementation.
*"* method's implementations
*include methods.
  METHOD load_vbaproject.

    DATA lv_content TYPE xstring.

    lv_content = me->get_from_zip_archive( ip_path ).

    ip_excel->Lif_excel_book_vba_project~set_vbaproject( lv_content ).

  ENDMETHOD.
  METHOD load_workbook.
    super->load_workbook( EXPORTING iv_workbook_full_filename = iv_workbook_full_filename
                                    io_excel                  = io_excel ).

    CONSTANTS: lc_vba_project  TYPE string VALUE 'http://schemas.microsoft.com/office/2006/relationships/vbaProject'.

    DATA: rels_workbook_path TYPE string,
          rels_workbook      TYPE REF TO if_ixml_document,
          path               TYPE string,
          node               TYPE REF TO if_ixml_element,
          workbook           TYPE REF TO if_ixml_document,
          stripped_name      TYPE chkfile,
          dirname            TYPE string,
          relationship       TYPE t_relationship,
          fileversion        TYPE t_fileversion,
          workbookpr         TYPE t_workbookpr.

    CALL FUNCTION 'TRINT_SPLIT_FILE_AND_PATH'
      EXPORTING
        full_name     = iv_workbook_full_filename
      IMPORTING
        stripped_name = stripped_name
        file_path     = dirname.

    " Read Workbook Relationships
    CONCATENATE dirname '_rels/' stripped_name '.rels'
      INTO rels_workbook_path.

    rels_workbook = me->get_ixml_from_zip_archive( rels_workbook_path ).

    node ?= rels_workbook->find_from_name_ns( name = 'Relationship' uri = namespace-relationships ).
    WHILE node IS BOUND.
      me->fill_struct_from_attributes( EXPORTING ip_element = node CHANGING cp_structure = relationship ).

      CASE relationship-type.
        WHEN lc_vba_project.
          " Read VBA  binary
          CONCATENATE dirname relationship-target INTO path.
          me->load_vbaproject( ip_path  = path
                               ip_excel = io_excel ).
        WHEN OTHERS.
      ENDCASE.

      node ?= node->get_next( ).
    ENDWHILE.

    " Read Workbook codeName
    workbook = me->get_ixml_from_zip_archive( iv_workbook_full_filename ).
    node ?=  workbook->find_from_name_ns( name = 'fileVersion' uri = namespace-main ).
    IF node IS BOUND.

      fill_struct_from_attributes( EXPORTING ip_element   = node
                                   CHANGING  cp_structure = fileversion  ).

      io_excel->Lif_excel_book_vba_project~set_codename( fileversion-codename ).
    ENDIF.

    " Read Workbook codeName
    workbook = me->get_ixml_from_zip_archive( iv_workbook_full_filename ).
    node ?=  workbook->find_from_name_ns( name = 'workbookPr' uri = namespace-main ).
    IF node IS BOUND.

      fill_struct_from_attributes( EXPORTING ip_element   = node
                                   CHANGING  cp_structure = workbookpr  ).

      io_excel->Lif_excel_book_vba_project~set_codename_pr( workbookpr-codename ).
    ENDIF.

  ENDMETHOD.
  METHOD load_worksheet.

    super->load_worksheet( EXPORTING ip_path      = ip_path
                                     io_worksheet = io_worksheet ).

    DATA: node      TYPE REF TO if_ixml_element,
          worksheet TYPE REF TO if_ixml_document,
          sheetpr   TYPE t_sheetpr.

    " Read Workbook codeName
    worksheet = me->get_ixml_from_zip_archive( ip_path ).
    node ?=  worksheet->find_from_name_ns( name = 'sheetPr' uri = namespace-main ).
    IF node IS BOUND.

      fill_struct_from_attributes( EXPORTING ip_element   = node
                                   CHANGING  cp_structure = sheetpr  ).
      IF sheetpr-codename IS NOT INITIAL.
        io_worksheet->Lif_excel_sheet_vba_project~set_codename_pr( sheetpr-codename ).
      ENDIF.
    ENDIF.
  ENDMETHOD.
endclass. "LCL_EXCEL_READER_XLSM implementation

*>>>>>>> LCL_EXCEL_ROW <<<<<<<*

*"* macro definitions
*include Lcl_excel_row=================ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_row=================ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_ROW implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    " Initialise values
    me->row_index    = ip_index.
    me->row_height   = -1.
    me->visible     = abap_true.
    me->outline_level  = 0.
    me->collapsed   = abap_false.

    " set row dimension as unformatted by default
    me->xf_index = 0.
    me->custom_height = abap_false.
  ENDMETHOD.
  METHOD get_collapsed.

    DATA: lt_row_outlines  TYPE Lcl_excel_worksheet=>mty_ts_outlines_row,
          lv_previous_row  TYPE i,
          lv_following_row TYPE i.

    r_collapsed = me->collapsed.

    CHECK r_collapsed = abap_false.  " Maybe new method for outlines is being used
    CHECK io_worksheet IS BOUND.

* If an outline is collapsed ( even inside an outer outline ) the line following the last line
* of the group gets the flag "collapsed"
    IF io_worksheet->Lif_excel_sheet_properties~summarybelow = Lif_excel_sheet_properties=>c_below_off.
      lv_following_row = me->row_index + 1.
      lt_row_outlines = io_worksheet->get_row_outlines( ).
      READ TABLE lt_row_outlines TRANSPORTING NO FIELDS WITH KEY row_from  = lv_following_row " first line of an outline
                                                                 collapsed = abap_true.       " that is collapsed
    ELSE.
      lv_previous_row = me->row_index - 1.
      lt_row_outlines = io_worksheet->get_row_outlines( ).
      READ TABLE lt_row_outlines TRANSPORTING NO FIELDS WITH KEY row_to    = lv_previous_row  " last line of an outline
                                                                 collapsed = abap_true.       " that is collapsed
    ENDIF.
    CHECK sy-subrc = 0.  " ok - we found it
    r_collapsed = abap_true.


  ENDMETHOD.
  METHOD get_custom_height.
    r_custom_height = me->custom_height.
  ENDMETHOD.
  METHOD get_outline_level.

    DATA: lt_row_outlines TYPE Lcl_excel_worksheet=>mty_ts_outlines_row.
    FIELD-SYMBOLS: <ls_row_outline> LIKE LINE OF lt_row_outlines.

* if someone has set the outline level explicitly - just use that
    IF me->outline_level IS NOT INITIAL.
      r_outline_level = me->outline_level.
      RETURN.
    ENDIF.
* Maybe we can use the outline information in the worksheet
    CHECK io_worksheet IS BOUND.

    lt_row_outlines = io_worksheet->get_row_outlines( ).
    LOOP AT lt_row_outlines ASSIGNING <ls_row_outline> WHERE row_from <= me->row_index
                                                         AND row_to   >= me->row_index.

      ADD 1 TO r_outline_level.

    ENDLOOP.

  ENDMETHOD.
  METHOD get_row_height.
    r_row_height = me->row_height.
  ENDMETHOD.
  METHOD get_row_index.
    r_row_index = me->row_index.
  ENDMETHOD.
  METHOD get_visible.

    DATA: lt_row_outlines TYPE Lcl_excel_worksheet=>mty_ts_outlines_row.
    FIELD-SYMBOLS: <ls_row_outline> LIKE LINE OF lt_row_outlines.

    r_visible = me->visible.
    CHECK r_visible = abap_true.  " Currently visible --> but maybe the new outline methodology will hide it implicitly
    CHECK io_worksheet IS BOUND.  " But we have to see the worksheet to make sure

    lt_row_outlines = io_worksheet->get_row_outlines( ).
    LOOP AT lt_row_outlines ASSIGNING <ls_row_outline> WHERE row_from  <= me->row_index
                                                         AND row_to    >= me->row_index
                                                         AND collapsed =  abap_true.      " row is in a collapsed outline --> not visible
      CLEAR r_visible.
      RETURN. " one hit is enough to ensure invisibility

    ENDLOOP.

  ENDMETHOD.
  METHOD get_xf_index.
    r_xf_index = me->xf_index.
  ENDMETHOD.
  METHOD set_collapsed.
    me->collapsed = ip_collapsed.
  ENDMETHOD.
  METHOD set_outline_level.
    IF   ip_outline_level < 0
      OR ip_outline_level > 7.

      Lcx_excel=>raise_text( 'Outline level must range between 0 and 7.' ).

    ENDIF.
    me->outline_level = ip_outline_level.
  ENDMETHOD.
  METHOD set_row_height.
    DATA: height TYPE f.
    TRY.
        height = ip_row_height.
        IF height <= 0.
          Lcx_excel=>raise_text( 'Please supply a positive number as row-height' ).
        ENDIF.
        me->row_height = ip_row_height.
      CATCH cx_sy_conversion_no_number.
        Lcx_excel=>raise_text( 'Unable to interpret ip_row_height as number' ).
    ENDTRY.
    me->custom_height = ip_custom_height.
  ENDMETHOD.
  METHOD set_row_index.
    me->row_index = ip_index.
  ENDMETHOD.
  METHOD set_visible.
    me->visible = ip_visible.
  ENDMETHOD.
  METHOD set_xf_index.
    me->xf_index = ip_xf_index.
  ENDMETHOD.
endclass. "LCL_EXCEL_ROW implementation

*>>>>>>> LCL_EXCEL_ROWS <<<<<<<*

*"* macro definitions
*include Lcl_excel_rows================ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_rows================ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_ROWS implementation.
*"* method's implementations
*include methods.
  METHOD add.
    DATA: ls_hashed_row TYPE mty_s_hashed_row.

    ls_hashed_row-row_index = io_row->get_row_index( ).
    ls_hashed_row-row = io_row.

    INSERT ls_hashed_row INTO TABLE rows_hashed.

    rows->add( io_row ).
  ENDMETHOD.                    "ADD
  METHOD clear.
    CLEAR rows_hashed.
    rows->clear( ).
  ENDMETHOD.                    "CLEAR
  METHOD constructor.

    CREATE OBJECT rows.

  ENDMETHOD.                    "CONSTRUCTOR
  METHOD get.
    FIELD-SYMBOLS: <ls_hashed_row> TYPE mty_s_hashed_row.

    READ TABLE rows_hashed WITH KEY row_index = ip_index ASSIGNING <ls_hashed_row>.
    IF sy-subrc = 0.
      eo_row = <ls_hashed_row>-row.
    ENDIF.
  ENDMETHOD.                    "GET
  METHOD get_iterator.
    eo_iterator ?= rows->get_iterator( ).
  ENDMETHOD.                    "GET_ITERATOR
  METHOD get_max_index.
    FIELD-SYMBOLS: <ls_hashed_row> TYPE mty_s_hashed_row.

    LOOP AT rows_hashed ASSIGNING <ls_hashed_row>.
      IF <ls_hashed_row>-row_index > ep_index.
        ep_index = <ls_hashed_row>-row_index.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_min_index.
    FIELD-SYMBOLS: <ls_hashed_row> TYPE mty_s_hashed_row.

    LOOP AT rows_hashed ASSIGNING <ls_hashed_row>.
      IF ep_index = 0 OR <ls_hashed_row>-row_index < ep_index.
        ep_index = <ls_hashed_row>-row_index.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD is_empty.
    is_empty = rows->is_empty( ).
  ENDMETHOD.                    "IS_EMPTY
  METHOD remove.
    DELETE TABLE rows_hashed WITH TABLE KEY row_index = io_row->get_row_index( ) .
    rows->remove( io_row ).
  ENDMETHOD.                    "REMOVE
  METHOD size.
    ep_size = rows->size( ).
  ENDMETHOD.                    "SIZE
endclass. "LCL_EXCEL_ROWS implementation

*>>>>>>> LCL_EXCEL_SECURITY <<<<<<<*

*"* macro definitions
*include Lcl_excel_security============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_security============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_SECURITY implementation.
*"* method's implementations
*include methods.
  METHOD is_security_enabled.
    IF lockrevision EQ abap_true OR lockstructure EQ abap_true OR lockwindows EQ abap_true.
      ep_security_enabled = abap_true.
    ENDIF.
  ENDMETHOD.
endclass. "LCL_EXCEL_SECURITY implementation

*>>>>>>> LCL_EXCEL_SHEET_SETUP <<<<<<<*

*"* macro definitions
*include Lcl_excel_sheet_setup=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_sheet_setup=========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_SHEET_SETUP implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    orientation = me->c_orientation_default.

* default margins
    margin_bottom = '0.75'.
    margin_footer = '0.3'.
    margin_header = '0.3'.
    margin_left   = '0.7'.
    margin_right  = '0.7'.
    margin_top    = '0.75'.

* clear page settings
    CLEAR: black_and_white,
           cell_comments,
           copies,
           draft,
           errors,
           first_page_number,
           fit_to_page,
           fit_to_height,
           fit_to_width,
           horizontal_dpi,
           orientation,
           page_order,
           paper_height,
           paper_size,
           paper_width,
           scale,
           use_first_page_num,
           use_printer_defaults,
           vertical_dpi.
  ENDMETHOD.
  METHOD get_header_footer.

* Only Basic font/text formatting possible:
* Bold (yes / no), Font Type, Font Size
*
* usefull placeholders, which can be used in header/footer value strings
* '&P' - page number
* '&N' - total number of pages
* '&D' - Date
* '&T' - Time
* '&F' - File Name
* '&Z' - Path
* '&A' - Sheet name
* new line via class constant CL_ABAP_CHAR_UTILITIES=>newline
*
* Example Value String 'page &P of &N'
*
* DO NOT USE &L , &C or &R which automatically created as position markers

    ep_odd_header = me->odd_header.
    ep_odd_footer = me->odd_footer.
    ep_even_header = me->even_header.
    ep_even_footer = me->even_footer.

  ENDMETHOD.
  METHOD get_header_footer_string.
* ----------------------------------------------------------------------
    DATA:   lc_marker_left(2)   TYPE c VALUE '&L'
          , lc_marker_right(2)  TYPE c VALUE '&R'
          , lc_marker_center(2) TYPE c VALUE '&C'
          , lv_value            TYPE string
          .
* ----------------------------------------------------------------------
    IF ep_odd_header IS SUPPLIED.

      IF me->odd_header-left_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->odd_header ip_side = 'LEFT' ).
        CONCATENATE lc_marker_left lv_value INTO ep_odd_header.
      ENDIF.

      IF me->odd_header-center_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->odd_header ip_side = 'CENTER' ).
        CONCATENATE ep_odd_header lc_marker_center lv_value INTO ep_odd_header.
      ENDIF.

      IF me->odd_header-right_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->odd_header ip_side = 'RIGHT' ).
        CONCATENATE ep_odd_header lc_marker_right lv_value INTO ep_odd_header.
      ENDIF.

      IF me->odd_header-left_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_left lv_value INTO ep_odd_header.
      ENDIF.
      IF me->odd_header-center_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_center lv_value INTO ep_odd_header.
      ENDIF.
      IF me->odd_header-right_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_right lv_value INTO ep_odd_header.
      ENDIF.

    ENDIF.
* ----------------------------------------------------------------------
    IF ep_odd_footer IS SUPPLIED.

      IF me->odd_footer-left_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->odd_footer ip_side = 'LEFT' ).
        CONCATENATE lc_marker_left lv_value INTO ep_odd_footer.
      ENDIF.

      IF me->odd_footer-center_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->odd_footer ip_side = 'CENTER' ).
        CONCATENATE ep_odd_footer lc_marker_center lv_value INTO ep_odd_footer.
      ENDIF.

      IF me->odd_footer-right_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->odd_footer ip_side = 'RIGHT' ).
        CONCATENATE ep_odd_footer lc_marker_right lv_value INTO ep_odd_footer.
      ENDIF.

      IF me->odd_footer-left_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_left lv_value INTO ep_odd_footer.
      ENDIF.
      IF me->odd_footer-center_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_center lv_value INTO ep_odd_footer.
      ENDIF.
      IF me->odd_footer-right_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_right lv_value INTO ep_odd_footer.
      ENDIF.

    ENDIF.
* ----------------------------------------------------------------------
    IF ep_even_header IS SUPPLIED.

      IF me->even_header-left_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->even_header ip_side = 'LEFT' ).
        CONCATENATE lc_marker_left lv_value INTO ep_even_header.
      ENDIF.

      IF me->even_header-center_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->even_header ip_side = 'CENTER' ).
        CONCATENATE ep_even_header lc_marker_center lv_value INTO ep_even_header.
      ENDIF.

      IF me->even_header-right_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->even_header ip_side = 'RIGHT' ).
        CONCATENATE ep_even_header lc_marker_right lv_value INTO ep_even_header.
      ENDIF.

      IF me->even_header-left_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_left lv_value INTO ep_even_header.
      ENDIF.
      IF me->even_header-center_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_center lv_value INTO ep_even_header.
      ENDIF.
      IF me->even_header-right_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_right lv_value INTO ep_even_header.
      ENDIF.

    ENDIF.
* ----------------------------------------------------------------------
    IF ep_even_footer IS SUPPLIED.

      IF me->even_footer-left_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->even_footer ip_side = 'LEFT' ).
        CONCATENATE lc_marker_left lv_value INTO ep_even_footer.
      ENDIF.

      IF me->even_footer-center_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->even_footer ip_side = 'CENTER' ).
        CONCATENATE ep_even_footer lc_marker_center lv_value INTO ep_even_footer.
      ENDIF.

      IF me->even_footer-right_value IS NOT INITIAL.
        lv_value = me->process_header_footer( ip_header = me->even_footer ip_side = 'RIGHT' ).
        CONCATENATE ep_even_footer lc_marker_right lv_value INTO ep_even_footer.
      ENDIF.

      IF me->even_footer-left_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_left lv_value INTO ep_even_footer.
      ENDIF.
      IF me->even_footer-center_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_center lv_value INTO ep_even_footer.
      ENDIF.
      IF me->even_footer-right_image IS NOT INITIAL.
        lv_value = '&G'.
        CONCATENATE ep_odd_header lc_marker_right lv_value INTO ep_even_footer.
      ENDIF.

    ENDIF.
* ----------------------------------------------------------------------
  ENDMETHOD.
  METHOD process_header_footer.

* ----------------------------------------------------------------------
* Only Basic font/text formatting possible:
* Bold (yes / no), Font Type, Font Size

    DATA:   lv_fname(12) TYPE c
          , lv_string    TYPE string
          .

    FIELD-SYMBOLS:   <lv_value> TYPE string
                   , <ls_font>  TYPE zexcel_s_style_font
                   .

* ----------------------------------------------------------------------
    CONCATENATE ip_side '_VALUE' INTO lv_fname.
    ASSIGN COMPONENT lv_fname OF STRUCTURE ip_header TO <lv_value>.

    CONCATENATE ip_side '_FONT' INTO lv_fname.
    ASSIGN COMPONENT lv_fname OF STRUCTURE ip_header TO <ls_font>.

    IF <ls_font> IS ASSIGNED AND <lv_value> IS ASSIGNED.

      IF <lv_value> = '&G'. "image header
        rv_processed_string = <lv_value>.
      ELSE.

        IF <ls_font>-name IS NOT INITIAL.
          CONCATENATE '&"' <ls_font>-name ',' INTO rv_processed_string.
        ELSE.
          rv_processed_string = '&"-,'.
        ENDIF.

        IF <ls_font>-bold = abap_true.
          CONCATENATE rv_processed_string 'Bold"' INTO rv_processed_string.
        ELSE.
          CONCATENATE rv_processed_string 'Standard"' INTO rv_processed_string.
        ENDIF.

        IF <ls_font>-size IS NOT INITIAL.
          lv_string = <ls_font>-size.
          CONCATENATE rv_processed_string '&' lv_string INTO rv_processed_string.
          CONDENSE rv_processed_string NO-GAPS.
        ENDIF.

        CONCATENATE rv_processed_string <lv_value> INTO rv_processed_string.
      ENDIF.
    ENDIF.
* ----------------------------------------------------------------------

  ENDMETHOD.
  METHOD set_header_footer.

* Only Basic font/text formatting possible:
* Bold (yes / no), Font Type, Font Size
*
* usefull placeholders, which can be used in header/footer value strings
* '&P' - page number
* '&N' - total number of pages
* '&D' - Date
* '&T' - Time
* '&F' - File Name
* '&Z' - Path
* '&A' - Sheet name
* new line via class constant CL_ABAP_CHAR_UTILITIES=>newline
*
* Example Value String 'page &P of &N'
*
* DO NOT USE &L , &C or &R which automatically created as position markers

    me->odd_header = ip_odd_header.
    me->odd_footer = ip_odd_footer.
    me->even_header = ip_even_header.
    me->even_footer = ip_even_footer.

    IF me->even_header IS NOT INITIAL OR me->even_footer IS NOT INITIAL.
      me->diff_oddeven_headerfooter = abap_true.
    ENDIF.


  ENDMETHOD.
  METHOD set_page_margins.
    DATA: lv_coef TYPE f,
          lv_unit TYPE string.

    lv_unit = ip_unit.
    TRANSLATE lv_unit TO UPPER CASE.

    CASE lv_unit.
      WHEN 'IN'. lv_coef = 1.
      WHEN 'CM'. lv_coef = '0.393700787'.
      WHEN 'MM'. lv_coef = '0.0393700787'.
    ENDCASE.

    IF ip_bottom IS SUPPLIED. margin_bottom = lv_coef * ip_bottom. ENDIF.
    IF ip_footer IS SUPPLIED. margin_footer = lv_coef * ip_footer. ENDIF.
    IF ip_header IS SUPPLIED. margin_header = lv_coef * ip_header. ENDIF.
    IF ip_left IS SUPPLIED.   margin_left   = lv_coef * ip_left. ENDIF.
    IF ip_right IS SUPPLIED.  margin_right  = lv_coef * ip_right. ENDIF.
    IF ip_top IS SUPPLIED.    margin_top    = lv_coef * ip_top. ENDIF.

  ENDMETHOD.
endclass. "LCL_EXCEL_SHEET_SETUP implementation

*>>>>>>> LCL_EXCEL_STYLE <<<<<<<*

*"* macro definitions
*include Lcl_excel_style===============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style===============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE implementation.
*"* method's implementations
*include methods.
  METHOD constructor.


    CREATE OBJECT font.
    CREATE OBJECT fill.
    CREATE OBJECT borders.
    CREATE OBJECT alignment.
    CREATE OBJECT number_format.
    CREATE OBJECT protection.

    IF ip_guid IS NOT INITIAL.
      me->guid = ip_guid.
    ELSE.
      me->guid = Lcl_excel_obsolete_func_wrap=>guid_create( ).
    ENDIF.

    IF io_clone_of IS BOUND.

      font->bold                 = io_clone_of->font->bold.
      font->color                = io_clone_of->font->color.
      font->family               = io_clone_of->font->family.
      font->italic               = io_clone_of->font->italic.
      font->name                 = io_clone_of->font->name.
      font->scheme               = io_clone_of->font->scheme.
      font->size                 = io_clone_of->font->size.
      font->strikethrough        = io_clone_of->font->strikethrough.
      font->underline            = io_clone_of->font->underline.
      font->underline_mode       = io_clone_of->font->underline_mode.

      fill->gradtype             = io_clone_of->fill->gradtype.
      fill->filltype             = io_clone_of->fill->filltype.
      fill->rotation             = io_clone_of->fill->rotation.
      fill->fgcolor              = io_clone_of->fill->fgcolor.
      fill->bgcolor              = io_clone_of->fill->bgcolor.

      borders->allborders        = io_clone_of->borders->allborders.
      borders->diagonal          = io_clone_of->borders->diagonal.
      borders->diagonal_mode     = io_clone_of->borders->diagonal_mode.
      borders->down              = io_clone_of->borders->down.
      borders->left              = io_clone_of->borders->left.
      borders->right             = io_clone_of->borders->right.
      borders->top               = io_clone_of->borders->top.

      alignment->horizontal      = io_clone_of->alignment->horizontal.
      alignment->vertical        = io_clone_of->alignment->vertical.
      alignment->textrotation    = io_clone_of->alignment->textrotation.
      alignment->wraptext        = io_clone_of->alignment->wraptext.
      alignment->shrinktofit     = io_clone_of->alignment->shrinktofit.
      alignment->indent          = io_clone_of->alignment->indent.

      number_format->format_code = io_clone_of->number_format->format_code.

      protection->hidden         = io_clone_of->protection->hidden.
      protection->locked         = io_clone_of->protection->locked.

    ENDIF.

  ENDMETHOD.
  METHOD get_guid.


    ep_guid = me->guid.
  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE implementation

*>>>>>>> LCL_EXCEL_STYLES <<<<<<<*

*"* macro definitions
*include Lcl_excel_styles==============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_styles==============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLES implementation.
*"* method's implementations
*include methods.
  METHOD add.


    styles->add( ip_style ).
  ENDMETHOD.
  METHOD clear.


    styles->clear( ).
  ENDMETHOD.
  METHOD constructor.


    CREATE OBJECT styles.
  ENDMETHOD.
  METHOD get.


    eo_style ?= styles->get( ip_index ).
  ENDMETHOD.
  METHOD get_iterator.


    eo_iterator ?= styles->get_iterator( ).
  ENDMETHOD.
  METHOD is_empty.


    is_empty = styles->is_empty( ).
  ENDMETHOD.
  METHOD register_new_style.


    me->add( io_style ).
    ep_style_code = me->size( ) - 1. "style count starts from 0
  ENDMETHOD.
  METHOD remove.


    styles->remove( ip_style ).
  ENDMETHOD.
  METHOD size.


    ep_size = styles->size( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_STYLES implementation

*>>>>>>> LCL_EXCEL_STYLES_COND <<<<<<<*

*"* macro definitions
*include Lcl_excel_styles_cond=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_styles_cond=========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLES_COND implementation.
*"* method's implementations
*include methods.
  METHOD add.
    styles_cond->add( ip_style_cond ).
  ENDMETHOD.
  METHOD clear.
    styles_cond->clear( ).
  ENDMETHOD.
  METHOD constructor.

    CREATE OBJECT styles_cond.

  ENDMETHOD.
  METHOD get.
    DATA lv_index TYPE i.
    lv_index = ip_index.
    eo_style_cond ?= styles_cond->get( lv_index ).
  ENDMETHOD.
  METHOD get_iterator.
    eo_iterator ?= styles_cond->get_iterator( ).
  ENDMETHOD.
  METHOD is_empty.
    is_empty = styles_cond->is_empty( ).
  ENDMETHOD.
  METHOD remove.
    styles_cond->remove( ip_style_cond ).
  ENDMETHOD.
  METHOD size.
    ep_size = styles_cond->size( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_STYLES_COND implementation

*>>>>>>> LCL_EXCEL_STYLE_ALIGNMENT <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_alignment=====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_alignment=====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_ALIGNMENT implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    horizontal  = me->c_horizontal_general.
    vertical    = me->c_vertical_bottom.
    wraptext    = abap_false.
    shrinktofit = abap_false.
  ENDMETHOD.
  METHOD get_structure.

    es_alignment-horizontal   = me->horizontal.
    es_alignment-vertical     = me->vertical.
    es_alignment-textrotation = me->textrotation.
    es_alignment-wraptext     = me->wraptext.
    es_alignment-shrinktofit  = me->shrinktofit.
    es_alignment-indent       = me->indent.

  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_ALIGNMENT implementation

*>>>>>>> LCL_EXCEL_STYLE_BORDER <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_border========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_border========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_BORDER implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    border_style = Lcl_excel_style_border=>c_border_none.
    border_color-theme     = Lcl_excel_style_color=>c_theme_not_set.
    border_color-indexed   = Lcl_excel_style_color=>c_indexed_not_set.
  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_BORDER implementation

*>>>>>>> LCL_EXCEL_STYLE_BORDERS <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_borders=======ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_borders=======ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_BORDERS implementation.
*"* method's implementations
*include methods.
  METHOD get_structure.
*initialize colors to 'not set'
    es_fill-left_color-indexed = Lcl_excel_style_color=>c_indexed_not_set.
    es_fill-left_color-theme = Lcl_excel_style_color=>c_theme_not_set.
    es_fill-right_color-indexed = Lcl_excel_style_color=>c_indexed_not_set.
    es_fill-right_color-theme = Lcl_excel_style_color=>c_theme_not_set.
    es_fill-top_color-indexed = Lcl_excel_style_color=>c_indexed_not_set.
    es_fill-top_color-theme = Lcl_excel_style_color=>c_theme_not_set.
    es_fill-bottom_color-indexed = Lcl_excel_style_color=>c_indexed_not_set.
    es_fill-bottom_color-theme = Lcl_excel_style_color=>c_theme_not_set.
    es_fill-diagonal_color-indexed = Lcl_excel_style_color=>c_indexed_not_set.
    es_fill-diagonal_color-theme = Lcl_excel_style_color=>c_theme_not_set.

* Check if all borders is set otherwise check single border
    IF me->allborders IS BOUND.
      es_fill-left_color    = me->allborders->border_color.
      es_fill-left_style    = me->allborders->border_style.
      es_fill-right_color   = me->allborders->border_color.
      es_fill-right_style   = me->allborders->border_style.
      es_fill-top_color     = me->allborders->border_color.
      es_fill-top_style     = me->allborders->border_style.
      es_fill-bottom_color  = me->allborders->border_color.
      es_fill-bottom_style  = me->allborders->border_style.
    ELSE.
      IF me->left IS BOUND.
        es_fill-left_color = me->left->border_color.
        es_fill-left_style = me->left->border_style.
      ENDIF.
      IF me->right IS BOUND.
        es_fill-right_color = me->right->border_color.
        es_fill-right_style = me->right->border_style.
      ENDIF.
      IF me->top IS BOUND.
        es_fill-top_color = me->top->border_color.
        es_fill-top_style = me->top->border_style.
      ENDIF.
      IF me->down IS BOUND.
        es_fill-bottom_color = me->down->border_color.
        es_fill-bottom_style = me->down->border_style.
      ENDIF.
    ENDIF.

* Check if diagonal is set
    IF me->diagonal IS BOUND.
      es_fill-diagonal_color = me->diagonal->border_color.
      es_fill-diagonal_style = me->diagonal->border_style.
      CASE me->diagonal_mode.
        WHEN 1.
          es_fill-diagonalup     = 1.
          es_fill-diagonaldown   = 0.
        WHEN 2.
          es_fill-diagonalup     = 0.
          es_fill-diagonaldown   = 1.
        WHEN 3.
          es_fill-diagonalup     = 1.
          es_fill-diagonaldown   = 1.
        WHEN OTHERS.
          es_fill-diagonalup     = 0.
          es_fill-diagonaldown   = 0.
      ENDCASE.
    ENDIF.

  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_BORDERS implementation

*>>>>>>> LCL_EXCEL_STYLE_COLOR <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_color=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_color=========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_COLOR implementation.
*"* method's implementations
*include methods.
  METHOD create_new_arbg_int.
    DATA: lv_red        TYPE int1,
          lv_green      TYPE int1,
          lv_blue       TYPE int1,
          lv_hex        TYPE x,
          lv_char_red   TYPE zexcel_style_color_component,
          lv_char_green TYPE zexcel_style_color_component,
          lv_char_blue  TYPE zexcel_style_color_component.

    lv_red    = iv_red MOD 256.
    lv_green  = iv_green MOD 256.
    lv_blue   = iv_blue  MOD 256.

    lv_hex        = lv_red.
    lv_char_red   = lv_hex.

    lv_hex        = lv_green.
    lv_char_green = lv_hex.

    lv_hex        = lv_blue.
    lv_char_blue  = lv_hex.


    CONCATENATE Lcl_excel_style_color=>c_alpha lv_char_red lv_char_green lv_char_blue INTO rv_color_argb.


  ENDMETHOD.
  METHOD create_new_argb.

    CONCATENATE Lcl_excel_style_color=>c_alpha ip_red ip_green ip_blu INTO ep_color_argb.

  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_COLOR implementation

*>>>>>>> LCL_EXCEL_STYLE_COND <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_cond==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_cond==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_COND implementation.
*"* method's implementations
*include methods.
  METHOD add_range.
    DATA: lv_column    TYPE zexcel_cell_column,
          lv_row_alpha TYPE string,
          lv_col_alpha TYPE string,
          lv_coords1   TYPE string,
          lv_coords2   TYPE string.


    lv_column = Lcl_excel_common=>convert_column2int( ip_start_column ).

    lv_col_alpha = ip_start_column.
    lv_row_alpha = ip_start_row.
    SHIFT lv_row_alpha RIGHT DELETING TRAILING space.
    SHIFT lv_row_alpha LEFT DELETING LEADING space.
    CONCATENATE lv_col_alpha lv_row_alpha INTO lv_coords1.

    IF ip_stop_column IS NOT INITIAL.
      lv_column = Lcl_excel_common=>convert_column2int( ip_stop_column ).
    ELSE.
      lv_column = Lcl_excel_common=>convert_column2int( ip_start_column ).
    ENDIF.

    IF ip_stop_row IS NOT INITIAL. " If we don't get explicitly a stop column use start column
      lv_row_alpha = ip_stop_row.
    ELSE.
      lv_row_alpha = ip_start_row.
    ENDIF.
    IF ip_stop_column IS NOT INITIAL. " If we don't get explicitly a stop column use start column
      lv_col_alpha = ip_stop_column.
    ELSE.
      lv_col_alpha = ip_start_column.
    ENDIF.
    SHIFT lv_row_alpha RIGHT DELETING TRAILING space.
    SHIFT lv_row_alpha LEFT DELETING LEADING space.
    CONCATENATE lv_col_alpha lv_row_alpha INTO lv_coords2.
    IF lv_coords2 IS NOT INITIAL AND lv_coords2 <> lv_coords1.
      CONCATENATE me->mv_rule_range ` ` lv_coords1 ':' lv_coords2 INTO me->mv_rule_range.
    ELSE.
      CONCATENATE me->mv_rule_range ` ` lv_coords1  INTO me->mv_rule_range.
    ENDIF.
    SHIFT me->mv_rule_range LEFT DELETING LEADING space.

  ENDMETHOD.
  METHOD constructor.

    DATA: ls_iconset TYPE zexcel_conditional_iconset.
    ls_iconset-iconset     = Lcl_excel_style_cond=>c_iconset_3trafficlights.
    ls_iconset-cfvo1_type  = Lcl_excel_style_cond=>c_cfvo_type_percent.
    ls_iconset-cfvo1_value = '0'.
    ls_iconset-cfvo2_type  = Lcl_excel_style_cond=>c_cfvo_type_percent.
    ls_iconset-cfvo2_value = '20'.
    ls_iconset-cfvo3_type  = Lcl_excel_style_cond=>c_cfvo_type_percent.
    ls_iconset-cfvo3_value = '40'.
    ls_iconset-cfvo4_type  = Lcl_excel_style_cond=>c_cfvo_type_percent.
    ls_iconset-cfvo4_value = '60'.
    ls_iconset-cfvo5_type  = Lcl_excel_style_cond=>c_cfvo_type_percent.
    ls_iconset-cfvo5_value = '80'.


    me->rule          = Lcl_excel_style_cond=>c_rule_none.
    me->mode_iconset  = ls_iconset.
    me->priority      = 1.

* inizialize dimension range
    me->mv_rule_range     = ip_dimension_range.

    IF ip_guid IS NOT INITIAL.
      me->guid = ip_guid.
    ELSE.
      me->guid = Lcl_excel_obsolete_func_wrap=>guid_create( ).
    ENDIF.

  ENDMETHOD.
  METHOD factory_cond_style_iconset.

  ENDMETHOD.
  METHOD get_dimension_range.

    ep_dimension_range = me->mv_rule_range.

  ENDMETHOD.
  METHOD get_guid.
    ep_guid = me->guid.
  ENDMETHOD.
  METHOD set_range.

    CLEAR: me->mv_rule_range.

    me->add_range( ip_start_row    = ip_start_row
                   ip_start_column = ip_start_column
                   ip_stop_row     = ip_stop_row
                   ip_stop_column  = ip_stop_column ).

  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_COND implementation

*>>>>>>> LCL_EXCEL_STYLE_FILL <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_fill==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_fill==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_FILL implementation.
*"* method's implementations
*include methods.
  METHOD build_gradient.
    CHECK check_filltype_is_gradient( ) EQ abap_true.
    CLEAR gradtype.
    CASE filltype.
      WHEN c_fill_gradient_horizontal90.
        gradtype-degree = '90'.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
      WHEN c_fill_gradient_horizontal270.
        gradtype-degree = '270'.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
      WHEN c_fill_gradient_horizontalb.
        gradtype-degree = '90'.
        gradtype-position1 = '0'.
        gradtype-position2 = '0.5'.
        gradtype-position3 = '1'.
      WHEN c_fill_gradient_vertical.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
      WHEN c_fill_gradient_fromcenter.
        gradtype-type = c_fill_gradient_path.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
        gradtype-bottom = '0.5'.
        gradtype-top = '0.5'.
        gradtype-left = '0.5'.
        gradtype-right = '0.5'.
      WHEN c_fill_gradient_diagonal45.
        gradtype-degree = '45'.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
      WHEN c_fill_gradient_diagonal45b.
        gradtype-degree = '45'.
        gradtype-position1 = '0'.
        gradtype-position2 = '0.5'.
        gradtype-position3 = '1'.
      WHEN c_fill_gradient_diagonal135.
        gradtype-degree = '135'.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
      WHEN c_fill_gradient_diagonal135b.
        gradtype-degree = '135'.
        gradtype-position1 = '0'.
        gradtype-position2 = '0.5'.
        gradtype-position3 = '1'.
      WHEN c_fill_gradient_cornerlt.
        gradtype-type = c_fill_gradient_path.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
      WHEN c_fill_gradient_cornerlb.
        gradtype-type = c_fill_gradient_path.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
        gradtype-bottom = '1'.
        gradtype-top = '1'.
      WHEN c_fill_gradient_cornerrt.
        gradtype-type = c_fill_gradient_path.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
        gradtype-left = '1'.
        gradtype-right = '1'.
      WHEN c_fill_gradient_cornerrb.
        gradtype-type = c_fill_gradient_path.
        gradtype-position1 = '0'.
        gradtype-position2 = '1'.
        gradtype-bottom = '0.5'.
        gradtype-top = '0.5'.
        gradtype-left = '0.5'.
        gradtype-right = '0.5'.
    ENDCASE.

  ENDMETHOD.                    "build_gradient
  METHOD check_filltype_is_gradient.
    CASE filltype.
      WHEN c_fill_gradient_horizontal90 OR
           c_fill_gradient_horizontal270 OR
           c_fill_gradient_horizontalb OR
           c_fill_gradient_vertical OR
           c_fill_gradient_fromcenter OR
           c_fill_gradient_diagonal45 OR
           c_fill_gradient_diagonal45b OR
           c_fill_gradient_diagonal135 OR
           c_fill_gradient_diagonal135b OR
           c_fill_gradient_cornerlt OR
           c_fill_gradient_cornerlb OR
           c_fill_gradient_cornerrt OR
           c_fill_gradient_cornerrb.
        rv_is_gradient = abap_true.
    ENDCASE.
  ENDMETHOD.                    "check_filltype_is_gradient
  METHOD constructor.
    filltype = Lcl_excel_style_fill=>c_fill_none.
    fgcolor-theme     = Lcl_excel_style_color=>c_theme_not_set.
    fgcolor-indexed   = Lcl_excel_style_color=>c_indexed_not_set.
    bgcolor-theme     = Lcl_excel_style_color=>c_theme_not_set.
    bgcolor-indexed   = Lcl_excel_style_color=>c_indexed_sys_foreground.
    rotation = 0.

  ENDMETHOD.                    "CONSTRUCTOR
  METHOD get_structure.
    es_fill-rotation  = me->rotation.
    es_fill-filltype  = me->filltype.
    es_fill-fgcolor   = me->fgcolor.
    es_fill-bgcolor   = me->bgcolor.
    me->build_gradient( ).
    es_fill-gradtype = me->gradtype.
  ENDMETHOD.                    "GET_STRUCTURE
endclass. "LCL_EXCEL_STYLE_FILL implementation

*>>>>>>> LCL_EXCEL_STYLE_FONT <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_font==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_font==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_FONT implementation.
*"* method's implementations
*include methods.
  METHOD calculate_text_width.
    " Addition to solve issue #120, contribution by Stefan Schmoecker
    r_width = strlen( i_text ).
    " use scale factor based on default 11
    " ( don't know where defaultsetting is stored currently )
    r_width = r_width * me->size / 11.
  ENDMETHOD.
  METHOD constructor.
    me->color-rgb       = Lcl_excel_style_color=>c_black.
    me->color-theme     = Lcl_excel_style_color=>c_theme_not_set.
    me->color-indexed   = Lcl_excel_style_color=>c_indexed_not_set.
    me->scheme          = Lcl_excel_style_font=>c_scheme_minor.
    me->underline_mode  = Lcl_excel_style_font=>c_underline_single.
  ENDMETHOD.
  METHOD get_structure.

    es_font-bold            = me->bold.
    es_font-italic          = me->italic.
    es_font-underline       = me->underline.
    es_font-underline_mode  = me->underline_mode.
    es_font-strikethrough   = me->strikethrough.
    es_font-size            = me->size.
    es_font-color           = me->color.
    es_font-name            = me->name.
    es_font-family          = me->family.
    es_font-scheme          = me->scheme.

  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_FONT implementation

*>>>>>>> LCL_EXCEL_STYLE_NUMBER_FORMAT <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_number_format=ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_number_format=ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_NUMBER_FORMAT implementation.
*"* method's implementations
*include methods.
  METHOD add_format.
    DATA ls_num_format LIKE LINE OF mt_built_in_num_formats.
    ls_num_format-id                  = id.
    CREATE OBJECT ls_num_format-format.
    ls_num_format-format->format_code = code.
    INSERT ls_num_format INTO TABLE mt_built_in_num_formats.
  ENDMETHOD.
  METHOD class_constructor.

    CLEAR mt_built_in_num_formats.

    add_format( id = '1' code = Lcl_excel_style_number_format=>c_format_number ).               " '0'.
    add_format( id = '2' code = Lcl_excel_style_number_format=>c_format_number_00 ).            " '0.00'.
    add_format( id = '3' code = Lcl_excel_style_number_format=>c_format_number_comma_sep0 ).    " '#,##0'.
    add_format( id = '4' code = Lcl_excel_style_number_format=>c_format_number_comma_sep1 ).    " '#,##0.00'.
    add_format( id = '5' code = Lcl_excel_style_number_format=>c_format_currency_simple ).      " '$#,##0_);($#,##0)'.
    add_format( id = '6' code = Lcl_excel_style_number_format=>c_format_currency_simple_red ).  " '$#,##0_);[Red]($#,##0)'.
    add_format( id = '7' code = Lcl_excel_style_number_format=>c_format_currency_simple2 ).     " '$#,##0.00_);($#,##0.00)'.
    add_format( id = '8' code = Lcl_excel_style_number_format=>c_format_currency_simple_red2 ). " '$#,##0.00_);[Red]($#,##0.00)'.
    add_format( id = '9' code = Lcl_excel_style_number_format=>c_format_percentage ).           " '0%'.
    add_format( id = '10' code = Lcl_excel_style_number_format=>c_format_percentage_00 ).        " '0.00%'.
    add_format( id = '11' code = Lcl_excel_style_number_format=>c_format_scientific ).           " '0.00E+00'.
    add_format( id = '12' code = Lcl_excel_style_number_format=>c_format_fraction_1 ).           " '# ?/?'.
    add_format( id = '13' code = Lcl_excel_style_number_format=>c_format_fraction_2 ).           " '# ??/??'.
    add_format( id = '14' code = Lcl_excel_style_number_format=>c_format_date_xlsx14 ).          "'m/d/yyyy'.  <--  should have been 'mm-dd-yy' like constant in Lcl_excel_style_number_format
    add_format( id = '15' code = Lcl_excel_style_number_format=>c_format_date_xlsx15 ).          "'d-mmm-yy'.
    add_format( id = '16' code = Lcl_excel_style_number_format=>c_format_date_xlsx16 ).          "'d-mmm'.
    add_format( id = '17' code = Lcl_excel_style_number_format=>c_format_date_xlsx17 ).          "'mmm-yy'.
    add_format( id = '18' code = Lcl_excel_style_number_format=>c_format_date_time1 ).           " 'h:mm AM/PM'.
    add_format( id = '19' code = Lcl_excel_style_number_format=>c_format_date_time2 ).           " 'h:mm:ss AM/PM'.
    add_format( id = '20' code = Lcl_excel_style_number_format=>c_format_date_time3 ).           " 'h:mm'.
    add_format( id = '21' code = Lcl_excel_style_number_format=>c_format_date_time4 ).           " 'h:mm:ss'.
    add_format( id = '22' code = Lcl_excel_style_number_format=>c_format_date_xlsx22 ).          " 'm/d/yyyy h:mm'.


    add_format( id = '37' code = Lcl_excel_style_number_format=>c_format_xlsx37 ).               " '#,##0_);(#,##0)'.
    add_format( id = '38' code = Lcl_excel_style_number_format=>c_format_xlsx38 ).               " '#,##0_);[Red](#,##0)'.
    add_format( id = '39' code = Lcl_excel_style_number_format=>c_format_xlsx39 ).               " '#,##0.00_);(#,##0.00)'.
    add_format( id = '40' code = Lcl_excel_style_number_format=>c_format_xlsx40 ).               " '#,##0.00_);[Red](#,##0.00)'.
    add_format( id = '41' code = Lcl_excel_style_number_format=>c_format_xlsx41 ).               " '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)'.
    add_format( id = '42' code = Lcl_excel_style_number_format=>c_format_xlsx42 ).               " '_($* #,##0_);_($* (#,##0);_($* "-"_);_(@_)'.
    add_format( id = '43' code = Lcl_excel_style_number_format=>c_format_xlsx43 ).               " '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)'.
    add_format( id = '44' code = Lcl_excel_style_number_format=>c_format_xlsx44 ).               " '_($* #,##0.00_);_($* (#,##0.00);_($* "-"??_);_(@_)'.
    add_format( id = '45' code = Lcl_excel_style_number_format=>c_format_date_xlsx45 ).          " 'mm:ss'.
    add_format( id = '46' code = Lcl_excel_style_number_format=>c_format_date_xlsx46 ).          " '[h]:mm:ss'.
    add_format( id = '47' code = Lcl_excel_style_number_format=>c_format_date_xlsx47 ).          "  'mm:ss.0'.
    add_format( id = '48' code = Lcl_excel_style_number_format=>c_format_special_01 ).           " '##0.0E+0'.
    add_format( id = '49' code = Lcl_excel_style_number_format=>c_format_text ).                 " '@'.

  ENDMETHOD.
  METHOD constructor.
    format_code = me->c_format_general.
  ENDMETHOD.
  METHOD get_structure.
    ep_number_format-numfmt = me->format_code.
  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_NUMBER_FORMAT implementation

*>>>>>>> LCL_EXCEL_STYLE_PROTECTION <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_protection====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_protection====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_STYLE_PROTECTION implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    locked = me->c_protection_locked.
    hidden = me->c_protection_unhidden.
  ENDMETHOD.
  METHOD get_structure.
    ep_protection-locked = me->locked.
    ep_protection-hidden = me->hidden.
  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_PROTECTION implementation

*>>>>>>> LCL_EXCEL_TABLE <<<<<<<*

*"* macro definitions
*include Lcl_excel_table===============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_table===============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_TABLE implementation.
*"* method's implementations
*include methods.
  METHOD get_bottom_row_integer.
    DATA: lv_table_lines TYPE i.
    FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.

    IF settings-bottom_right_row IS NOT INITIAL.
*    ev_row =  Lcl_excel_common=>convert_column2int( settings-bottom_right_row ). " del issue #246
      ev_row =  settings-bottom_right_row .                                         " ins issue #246
      RETURN.
    ENDIF.

    ASSIGN table_data->* TO <fs_table>.
    DESCRIBE TABLE <fs_table> LINES lv_table_lines.
    IF lv_table_lines = 0.
      lv_table_lines = 1. "table needs at least 1 data row
    ENDIF.

    ev_row = settings-top_left_row + lv_table_lines.

    IF me->has_totals( ) = abap_true."  ????  AND ip_include_totals_row = abap_true.
      ADD 1 TO ev_row.
    ENDIF.
  ENDMETHOD.
  METHOD get_id.
    ov_id = id.
  ENDMETHOD.
  METHOD get_name.

    IF me->name IS INITIAL.
      me->name = Lcl_excel_common=>number_to_excel_string( ip_value = me->id ).
      CONCATENATE 'table' me->name INTO me->name.
    ENDIF.

    ov_name = me->name.
  ENDMETHOD.
  METHOD get_reference.
    DATA: lv_column                TYPE zexcel_cell_column,
          lv_table_lines           TYPE i,
          lv_right_column          TYPE zexcel_cell_column_alpha,
          ls_field_catalog         TYPE zexcel_s_fieldcatalog,
          lv_bottom_row            TYPE zexcel_cell_row,
          lv_top_row_string(10)    TYPE c,
          lv_bottom_row_string(10) TYPE c.

    FIELD-SYMBOLS: <fs_table> TYPE STANDARD TABLE.

*column
    lv_column = Lcl_excel_common=>convert_column2int( settings-top_left_column ).
    lv_table_lines = 0.
    LOOP AT fieldcat INTO ls_field_catalog WHERE dynpfld EQ abap_true.
      ADD 1 TO lv_table_lines.
    ENDLOOP.
    lv_column = lv_column + lv_table_lines - 1.
    lv_right_column  = Lcl_excel_common=>convert_column2alpha( lv_column ).

*row
    ASSIGN table_data->* TO <fs_table>.
    DESCRIBE TABLE <fs_table> LINES lv_table_lines.
    IF lv_table_lines = 0.
      lv_table_lines = 1. "table needs at least 1 data row
    ENDIF.
    lv_bottom_row = settings-top_left_row + lv_table_lines .

    IF me->has_totals( ) = abap_true AND ip_include_totals_row = abap_true.
      ADD 1 TO lv_bottom_row.
    ENDIF.

    lv_top_row_string = Lcl_excel_common=>number_to_excel_string( settings-top_left_row ).
    lv_bottom_row_string = Lcl_excel_common=>number_to_excel_string( lv_bottom_row ).

    CONCATENATE settings-top_left_column lv_top_row_string
                ':'
                lv_right_column lv_bottom_row_string INTO ov_reference.

  ENDMETHOD.
  METHOD get_right_column_integer.
    DATA: ls_field_catalog  TYPE zexcel_s_fieldcatalog.

    IF settings-bottom_right_column IS NOT INITIAL.
      ev_column =  Lcl_excel_common=>convert_column2int( settings-bottom_right_column ).
      RETURN.
    ENDIF.

    ev_column =  Lcl_excel_common=>convert_column2int( settings-top_left_column ).
    LOOP AT fieldcat INTO ls_field_catalog WHERE dynpfld EQ abap_true.
      ADD 1 TO ev_column.
    ENDLOOP.

  ENDMETHOD.
  METHOD get_totals_formula.
    CONSTANTS: lc_function_id_sum     TYPE string VALUE '109',
               lc_function_id_min     TYPE string VALUE '105',
               lc_function_id_max     TYPE string VALUE '104',
               lc_function_id_count   TYPE string VALUE '103',
               lc_function_id_average TYPE string VALUE '101'.

    DATA: lv_function_id TYPE string.

    CASE ip_function.
      WHEN Lcl_excel_table=>totals_function_sum.
        lv_function_id = lc_function_id_sum.

      WHEN Lcl_excel_table=>totals_function_min.
        lv_function_id = lc_function_id_min.

      WHEN Lcl_excel_table=>totals_function_max.
        lv_function_id = lc_function_id_max.

      WHEN Lcl_excel_table=>totals_function_count.
        lv_function_id = lc_function_id_count.

      WHEN Lcl_excel_table=>totals_function_average.
        lv_function_id = lc_function_id_average.

      WHEN Lcl_excel_table=>totals_function_custom. " issue #292
        RETURN.

      WHEN OTHERS.
        Lcx_excel=>raise_text( 'Invalid totals formula. See ZCL_ for possible values' ).
    ENDCASE.

    CONCATENATE 'SUBTOTAL(' lv_function_id ',[' ip_column '])' INTO ep_formula.
  ENDMETHOD.
  METHOD has_totals.
    DATA: ls_field_catalog    TYPE zexcel_s_fieldcatalog.

    ep_result = abap_false.

    LOOP AT fieldcat INTO ls_field_catalog.
      IF ls_field_catalog-totals_function IS NOT INITIAL.
        ep_result = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.
  METHOD set_data.

    DATA lr_temp TYPE REF TO data.

    FIELD-SYMBOLS: <lt_table_temp> TYPE ANY TABLE,
                   <lt_table>      TYPE ANY TABLE.

    GET REFERENCE OF ir_data INTO lr_temp.
    ASSIGN lr_temp->* TO <lt_table_temp>.
    CREATE DATA table_data LIKE <lt_table_temp>.
    ASSIGN me->table_data->* TO <lt_table>.
    <lt_table> = <lt_table_temp>.

  ENDMETHOD.
  METHOD set_id.
    id = iv_id.
  ENDMETHOD.
endclass. "LCL_EXCEL_TABLE implementation

*>>>>>>> LCL_EXCEL_TEMPLATE_DATA <<<<<<<*

*"* macro definitions
*include Lcl_excel_template_data=======ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_template_data=======ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_TEMPLATE_DATA implementation.
*"* method's implementations
*include methods.
  METHOD add.
    FIELD-SYMBOLS: <ls_data_sheet> TYPE ts_template_data_sheet,
                   <any>           TYPE any.

    APPEND INITIAL LINE TO mt_data ASSIGNING <ls_data_sheet>.
    <ls_data_sheet>-sheet = iv_sheet.
    CREATE DATA  <ls_data_sheet>-data LIKE iv_data.

    ASSIGN <ls_data_sheet>-data->* TO <any>.
    <any> = iv_data.

  ENDMETHOD.
endclass. "LCL_EXCEL_TEMPLATE_DATA implementation

*>>>>>>> LCL_EXCEL_THEME <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme===============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme===============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_THEME implementation.
*"* method's implementations
*include methods.
  METHOD constructor.
    CREATE OBJECT elements.
    CREATE OBJECT objectdefaults.
    CREATE OBJECT extclrschemelst.
    CREATE OBJECT extlst.
  ENDMETHOD.                    "class_constructor
  METHOD read_theme.
    DATA: lo_node_theme TYPE REF TO if_ixml_element.
    DATA: lo_theme_children TYPE REF TO if_ixml_node_list.
    DATA: lo_theme_iterator TYPE REF TO if_ixml_node_iterator.
    DATA: lo_theme_element TYPE REF TO if_ixml_element.
    CHECK io_theme_xml IS NOT INITIAL.

    lo_node_theme  = io_theme_xml->get_root_element( )."   find_from_name( name = c_theme ).
    IF lo_node_theme IS BOUND.
      name = lo_node_theme->get_attribute( name = c_theme_name ).
      xmls_a = lo_node_theme->get_attribute( name = c_theme_xmlns ).
      lo_theme_children = lo_node_theme->get_children( ).
      lo_theme_iterator = lo_theme_children->create_iterator( ).
      lo_theme_element ?= lo_theme_iterator->get_next( ).
      WHILE lo_theme_element IS BOUND.
        CASE lo_theme_element->get_name( ).
          WHEN c_theme_elements.
            elements->load( io_elements = lo_theme_element ).
          WHEN c_theme_object_def.
            objectdefaults->load( io_object_def = lo_theme_element ).
          WHEN c_theme_extra_color.
            extclrschemelst->load( io_extra_color = lo_theme_element ).
          WHEN c_theme_extlst.
            extlst->load( io_extlst = lo_theme_element ).
        ENDCASE.
        lo_theme_element ?= lo_theme_iterator->get_next( ).
      ENDWHILE.
    ENDIF.
  ENDMETHOD.                    "read_theme
  METHOD set_color.
    elements->color_scheme->set_color(
      EXPORTING
        iv_type         = iv_type
        iv_srgb         = iv_srgb
        iv_syscolorname = iv_syscolorname
        iv_syscolorlast = iv_syscolorlast
    ).
  ENDMETHOD.                    "set_color
  METHOD set_color_scheme_name.
    elements->color_scheme->set_name( iv_name = iv_name ).
  ENDMETHOD.                    "set_color_scheme_name
  METHOD set_cs_font.
    elements->font_scheme->modify_cs_font(
      EXPORTING
        iv_type        = iv_type
        iv_typeface    = iv_typeface
        iv_panose      = iv_panose
        iv_pitchfamily = iv_pitchfamily
        iv_charset     = iv_charset
    ).
  ENDMETHOD.                    "set_cs_font
  METHOD set_ea_font.
    elements->font_scheme->modify_ea_font(
      EXPORTING
        iv_type        = iv_type
        iv_typeface    = iv_typeface
        iv_panose      = iv_panose
        iv_pitchfamily = iv_pitchfamily
        iv_charset     = iv_charset
    ).
  ENDMETHOD.                    "set_ea_font
  METHOD set_font.
    elements->font_scheme->modify_font(
      EXPORTING
        iv_type     = iv_type
        iv_script   = iv_script
        iv_typeface = iv_typeface
    ).
  ENDMETHOD.                    "set_font
  METHOD set_font_scheme_name.
    elements->font_scheme->set_name( iv_name = iv_name ).
  ENDMETHOD.                    "set_font_scheme_name
  METHOD set_latin_font.
    elements->font_scheme->modify_latin_font(
      EXPORTING
        iv_type        = iv_type
        iv_typeface    = iv_typeface
        iv_panose      = iv_panose
        iv_pitchfamily = iv_pitchfamily
        iv_charset     = iv_charset
    ).
  ENDMETHOD.                    "set_latin_font
  METHOD set_theme_name.
    name = iv_name.
  ENDMETHOD.
  METHOD write_theme.
    DATA: lo_ixml         TYPE REF TO if_ixml,
          lo_element_root TYPE REF TO if_ixml_element,
          lo_encoding     TYPE REF TO if_ixml_encoding.
    DATA: lo_streamfactory  TYPE REF TO if_ixml_stream_factory.
    DATA: lo_ostream TYPE REF TO if_ixml_ostream.
    DATA: lo_renderer TYPE REF TO if_ixml_renderer.
    DATA: lo_document TYPE REF TO if_ixml_document.
    lo_ixml = cl_ixml=>create( ).

    lo_encoding = lo_ixml->create_encoding( byte_order = if_ixml_encoding=>co_platform_endian
                                            character_set = 'UTF-8' ).
    lo_document = lo_ixml->create_document( ).
    lo_document->set_encoding( lo_encoding ).
    lo_document->set_standalone( abap_true ).
    lo_document->set_namespace_prefix( prefix = 'a' ).

    lo_element_root = lo_document->create_simple_element_ns( prefix = c_theme_prefix
                                                             name   = c_theme
                                                            parent = lo_document
                                                            ).
    lo_element_root->set_attribute_ns( name  = c_theme_xmlns
                                       value = c_theme_xmlns_val ).
    lo_element_root->set_attribute_ns( name  = c_theme_name
                                       value = name ).

    elements->build_xml( io_document = lo_document ).
    objectdefaults->build_xml( io_document = lo_document ).
    extclrschemelst->build_xml( io_document = lo_document ).
    extlst->build_xml( io_document = lo_document ).

    lo_streamfactory = lo_ixml->create_stream_factory( ).
    lo_ostream = lo_streamfactory->create_ostream_xstring( string = rv_xstring ).
    lo_renderer = lo_ixml->create_renderer( ostream  = lo_ostream document = lo_document ).
    lo_renderer->render( ).

  ENDMETHOD.                    "write_theme
endclass. "LCL_EXCEL_THEME implementation

*>>>>>>> LCL_EXCEL_READER_2007 <<<<<<<*

*"* macro definitions
*include Lcl_excel_reader_2007=========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_reader_2007=========ccimp.
*"* local class implementation for public class
*"* use this source file for the implementation part of
*"* local helper classes

*
  CLASS SHRITEFUH64VYIPN5I4UIDBJAAUSE4 DEFINITION
      INHERITING FROM SHRITEFUH64VYIPN5I4UIDBJAATSE4
      CREATE PRIVATE.
    PUBLIC SECTION.
      CLASS-METHODS create
        IMPORTING i_data TYPE xstring
        RETURNING VALUE(r_zip) TYPE REF TO SHRITEFUH64VYIPN5I4UIDBJAATSE4
        RAISING Lcx_excel.
      METHODS read REDEFINITION.
    PRIVATE SECTION.
      DATA: abap_zip TYPE REF TO cl_abap_zip.
      METHODS constructor IMPORTING i_data TYPE xstring
                          RAISING Lcx_excel.
  ENDCLASS.                    "SHRITEFUH64VYIPN5I4UIDBJAAUSE4 DEFINITION

*
  CLASS SHRITEFUH64VYIPN5I4UIDBJAAVSE4 DEFINITION
    INHERITING FROM SHRITEFUH64VYIPN5I4UIDBJAATSE4
    CREATE PRIVATE.
    PUBLIC SECTION.
      CLASS-METHODS create
        IMPORTING i_data TYPE xstring
                  i_alternate_zip_class TYPE seoclsname
        RETURNING VALUE(r_zip) TYPE REF TO SHRITEFUH64VYIPN5I4UIDBJAATSE4
        RAISING Lcx_excel.
      METHODS read REDEFINITION.
    PRIVATE SECTION.
      DATA: alternate_zip TYPE REF TO object.
      METHODS constructor
        IMPORTING i_data TYPE xstring
                  i_alternate_zip_class TYPE seoclsname
        RAISING Lcx_excel.
  ENDCLASS.                    "SHRITEFUH64VYIPN5I4UIDBJAAVSE4 DEFINITION

*
  CLASS SHRITEFUH64VYIPN5I4UIDBJAAUSE4 IMPLEMENTATION.
    METHOD create.
      CREATE OBJECT r_zip TYPE SHRITEFUH64VYIPN5I4UIDBJAAUSE4
        EXPORTING
          i_data = i_data.
    ENDMETHOD.                    "create
    METHOD constructor.
      DATA: lv_errormessage TYPE string.
      super->constructor( ).
      CREATE OBJECT abap_zip.
      abap_zip->load(
                 EXPORTING
                   zip = i_data
                 EXCEPTIONS
                   zip_parse_error = 1
                   OTHERS          = 2 ).
      IF sy-subrc <> 0.
        lv_errormessage = 'ZIP parse error'(002).
        RAISE EXCEPTION TYPE Lcx_excel
          EXPORTING
            error = lv_errormessage.
      ENDIF.

    ENDMETHOD.                    "constructor
    METHOD read.
      DATA: lv_errormessage TYPE string.
      CALL METHOD abap_zip->get
        EXPORTING
          name                    = i_filename
        IMPORTING
          content                 = r_content
        EXCEPTIONS
          zip_index_error         = 1
          zip_decompression_error = 2
          OTHERS                  = 3.
      IF sy-subrc <> 0.
        lv_errormessage = 'File not found in zip-archive'(003).
        RAISE EXCEPTION TYPE Lcx_excel
          EXPORTING
            error = lv_errormessage.
      ENDIF.

    ENDMETHOD.                    "read
  ENDCLASS.                    "SHRITEFUH64VYIPN5I4UIDBJAAUSE4 IMPLEMENTATION

*
  CLASS SHRITEFUH64VYIPN5I4UIDBJAAVSE4 IMPLEMENTATION.
    METHOD create.
      CREATE OBJECT r_zip TYPE SHRITEFUH64VYIPN5I4UIDBJAAVSE4
        EXPORTING
          i_alternate_zip_class = i_alternate_zip_class
          i_data                = i_data.
    ENDMETHOD.                    "create
    METHOD constructor.
      DATA: lv_errormessage TYPE string.
      super->constructor( ).
      CREATE OBJECT alternate_zip TYPE (i_alternate_zip_class).
      TRY.
          CALL METHOD alternate_zip->('LOAD')
            EXPORTING
              zip             = i_data
            EXCEPTIONS
              zip_parse_error = 1
              OTHERS          = 2.
        CATCH cx_sy_dyn_call_illegal_method.
          lv_errormessage = 'Method LOAD missing in alternative zipclass'. "#EC NOTEXT   This is a workaround until class CL_ABAP_ZIP is fixed
          RAISE EXCEPTION TYPE Lcx_excel
            EXPORTING
              error = lv_errormessage.
      ENDTRY.

      IF sy-subrc <> 0.
        lv_errormessage = 'ZIP parse error'(002).
        RAISE EXCEPTION TYPE Lcx_excel
          EXPORTING
            error = lv_errormessage.
      ENDIF.

    ENDMETHOD.                    "constructor
    METHOD read.
      DATA: lv_errormessage TYPE string.
      TRY.
          CALL METHOD alternate_zip->('GET')
            EXPORTING
              name                    = i_filename
            IMPORTING
              content                 = r_content    " Contents
            EXCEPTIONS
              zip_index_error         = 1
              zip_decompression_error = 2
              OTHERS                  = 3.
        CATCH cx_sy_dyn_call_illegal_method.
          lv_errormessage = 'Method GET missing in alternative zipclass'. "#EC NOTEXT   This is a workaround until class CL_ABAP_ZIP is fixed
          RAISE EXCEPTION TYPE Lcx_excel
            EXPORTING
              error = lv_errormessage.
      ENDTRY.
      IF sy-subrc <> 0.
        lv_errormessage = 'File not found in zip-archive'(003).
        RAISE EXCEPTION TYPE Lcx_excel
          EXPORTING
            error = lv_errormessage.
      ENDIF.

    ENDMETHOD.                    "read
  ENDCLASS.                    "SHRITEFUH64VYIPN5I4UIDBJAAVSE4 IMPLEMENTATION

*"* test class
*include Lcl_excel_reader_2007=========ccau.
*"* use this source file for your ABAP unit test classes

*CLASS SHRITEFUH64VYIPN5I4UIDBJAAYSE4 DEFINITION DEFERRED.
*CLASS Lcl_excel_reader_2007 DEFINITION LOCAL FRIENDS
*    SHRITEFUH64VYIPN5I4UIDBJAAYSE4.





class LCL_EXCEL_READER_2007 implementation.
*"* method's implementations
*include methods.
  METHOD unescape_string_value.

    DATA: lt_character_positions       TYPE TABLE OF i,
          lv_character_position        TYPE i,
          lv_character_position_plus_2 TYPE i,
          lv_character_position_plus_6 TYPE i,
          lv_unescaped_value           TYPE string.

    " The text "_x...._", with "_x" not "_X", with exactly 4 ".", each being 0-9 a-f or A-F (case insensitive), is interpreted
    " like Unicode character U+.... (e.g. "_x0041_" is rendered like "A") is for characters.
    " To not interpret it, Excel replaces the first "_" with "_x005f_".
    result = i_value.
    IF result CS '_x'.
      CLEAR lt_character_positions.
      APPEND sy-fdpos TO lt_character_positions.
      lv_character_position = sy-fdpos + 1.
      WHILE result+lv_character_position CS '_x'.
        ADD sy-fdpos TO lv_character_position.
        APPEND lv_character_position TO lt_character_positions.
        ADD 1 TO lv_character_position.
      ENDWHILE.
      SORT lt_character_positions BY table_line DESCENDING.
      LOOP AT lt_character_positions INTO lv_character_position.
        lv_character_position_plus_2 = lv_character_position + 2.
        lv_character_position_plus_6 = lv_character_position + 6.
        IF substring( val = result off = lv_character_position_plus_2 len = 4 ) CO '0123456789ABCDEFGHIJKLMNOPQRSTUVWabcdefghijklmnopqrstuvw'
          AND substring( val = result off = lv_character_position_plus_6 len = 1 ) = '_'.
          lv_unescaped_value = cl_abap_conv_in_ce=>uccp( to_upper( substring( val = result off = lv_character_position_plus_2 len = 4 ) ) ).
          REPLACE SECTION OFFSET lv_character_position LENGTH 7 OF result WITH lv_unescaped_value.
        ENDIF.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.
  METHOD create_zip_archive.
    CASE i_use_alternate_zip.
      WHEN space.
        e_zip = SHRITEFUH64VYIPN5I4UIDBJAAUSE4=>create( i_xlsx_binary ).
      WHEN OTHERS.
        e_zip = SHRITEFUH64VYIPN5I4UIDBJAAVSE4=>create( i_data                = i_xlsx_binary
                                                   i_alternate_zip_class = i_use_alternate_zip ).
    ENDCASE.
  ENDMETHOD.
  METHOD fill_row_outlines.

    TYPES: BEGIN OF lts_row_data,
             row           TYPE i,
             outline_level TYPE i,
           END OF lts_row_data,
           ltt_row_data TYPE SORTED TABLE OF lts_row_data WITH UNIQUE KEY row.

    DATA: lt_row_data             TYPE ltt_row_data,
          ls_row_data             LIKE LINE OF lt_row_data,
          lt_collapse_rows        TYPE HASHED TABLE OF i WITH UNIQUE KEY table_line,

          lv_collapsed            TYPE abap_bool,

          lv_outline_level        TYPE i,
          lv_next_consecutive_row TYPE i,
          lt_outline_rows         TYPE Lcl_excel_worksheet=>mty_ts_outlines_row,
          ls_outline_row          LIKE LINE OF lt_outline_rows,
          lo_row                  TYPE REF TO Lcl_excel_row,
          lo_row_iterator         TYPE REF TO Lcl_excel_collection_iterator,
          lv_row_offset           TYPE i,
          lv_row_collapse_flag    TYPE i.


    FIELD-SYMBOLS: <ls_row_data>      LIKE LINE OF lt_row_data.

* First collect information about outlines ( outline leven and collapsed state )
    lo_row_iterator = io_worksheet->get_rows_iterator( ).
    WHILE lo_row_iterator->has_next( ) = abap_true.
      lo_row ?= lo_row_iterator->get_next( ).
      ls_row_data-row           = lo_row->get_row_index( ).
      ls_row_data-outline_level = lo_row->get_outline_level( ).
      IF ls_row_data-outline_level IS NOT INITIAL.
        INSERT ls_row_data INTO TABLE lt_row_data.
      ENDIF.

      lv_collapsed = lo_row->get_collapsed( ).
      IF lv_collapsed = abap_true.
        INSERT lo_row->get_row_index( ) INTO TABLE lt_collapse_rows.
      ENDIF.
    ENDWHILE.

* Now parse this information - we need consecutive rows - any gap will create a new outline
    DO 7 TIMES.  " max number of outlines allowed
      lv_outline_level = sy-index.
      CLEAR lv_next_consecutive_row.
      CLEAR ls_outline_row.
      LOOP AT lt_row_data ASSIGNING <ls_row_data> WHERE outline_level >= lv_outline_level.

        IF lv_next_consecutive_row    <> <ls_row_data>-row   " A gap --> close all open outlines
          AND lv_next_consecutive_row IS NOT INITIAL.        " First time in loop.
          INSERT ls_outline_row INTO TABLE lt_outline_rows.
          CLEAR: ls_outline_row.
        ENDIF.

        IF ls_outline_row-row_from IS INITIAL.
          ls_outline_row-row_from = <ls_row_data>-row.
        ENDIF.
        ls_outline_row-row_to = <ls_row_data>-row.

        lv_next_consecutive_row = <ls_row_data>-row + 1.

      ENDLOOP.
      IF ls_outline_row-row_from IS NOT INITIAL.
        INSERT ls_outline_row INTO TABLE lt_outline_rows.
      ENDIF.
    ENDDO.

* lt_outline_rows holds all outline information
* we now need to determine whether the outline is collapsed or not
    LOOP AT lt_outline_rows INTO ls_outline_row.

      IF io_worksheet->Lif_excel_sheet_properties~summarybelow = Lif_excel_sheet_properties=>c_below_off.
        lv_row_collapse_flag = ls_outline_row-row_from - 1.
      ELSE.
        lv_row_collapse_flag = ls_outline_row-row_to + 1.
      ENDIF.
      READ TABLE lt_collapse_rows TRANSPORTING NO FIELDS WITH TABLE KEY table_line = lv_row_collapse_flag.
      IF sy-subrc = 0.
        ls_outline_row-collapsed = abap_true.
      ENDIF.
      io_worksheet->set_row_outline( iv_row_from  = ls_outline_row-row_from
                                     iv_row_to    = ls_outline_row-row_to
                                     iv_collapsed = ls_outline_row-collapsed ).

    ENDLOOP.

* Finally purge outline information ( collapsed state, outline leve)  from row_dimensions, since we want to keep these in the outline-table
    lo_row_iterator = io_worksheet->get_rows_iterator( ).
    WHILE lo_row_iterator->has_next( ) = abap_true.
      lo_row ?= lo_row_iterator->get_next( ).

      lo_row->set_outline_level( 0 ).
      lo_row->set_collapsed( abap_false ).

    ENDWHILE.

  ENDMETHOD.
  METHOD fill_struct_from_attributes.
*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-07
*              - ...
* changes: renaming variables to naming conventions
*          aligning code
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*

    DATA: lv_name       TYPE string,
          lo_attributes TYPE REF TO if_ixml_named_node_map,
          lo_attribute  TYPE REF TO if_ixml_attribute,
          lo_iterator   TYPE REF TO if_ixml_node_iterator.

    FIELD-SYMBOLS: <component>                  TYPE any.

*--------------------------------------------------------------------*
* The values of named attributes of a tag are being read and moved into corresponding
* fields of given structure
* Behaves like move-corresonding tag to structure

* Example:
*     <Relationship Target="docProps/app.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Id="rId3"/>
*   Here the attributes are Target, Type and Id.  Thus if the passed
*   structure has fieldnames Id and Target these would be filled with
*   "rId3" and "docProps/app.xml" respectively
*--------------------------------------------------------------------*
    CLEAR cp_structure.

    lo_attributes  = ip_element->get_attributes( ).
    lo_iterator    = lo_attributes->create_iterator( ).
    lo_attribute  ?= lo_iterator->get_next( ).
    WHILE lo_attribute IS BOUND.

      lv_name = lo_attribute->get_name( ).
      TRANSLATE lv_name TO UPPER CASE.
      ASSIGN COMPONENT lv_name OF STRUCTURE cp_structure TO <component>.
      IF sy-subrc = 0.
        <component> = lo_attribute->get_value( ).
      ENDIF.
      lo_attribute ?= lo_iterator->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD get_dxf_style_guid.
    DATA: lo_ixml_dxf_children          TYPE REF TO if_ixml_node_list,
          lo_ixml_iterator_dxf_children TYPE REF TO if_ixml_node_iterator,
          lo_ixml_dxf_child             TYPE REF TO if_ixml_element,

          lv_dxf_child_type             TYPE string,

          lo_ixml_element               TYPE REF TO if_ixml_element,
          lo_ixml_element2              TYPE REF TO if_ixml_element,
          lv_val                        TYPE string.

    DATA: ls_cstyle  TYPE zexcel_s_cstyle_complete,
          ls_cstylex TYPE zexcel_s_cstylex_complete.



    lo_ixml_dxf_children = io_ixml_dxf->get_children( ).
    lo_ixml_iterator_dxf_children = lo_ixml_dxf_children->create_iterator( ).
    lo_ixml_dxf_child ?= lo_ixml_iterator_dxf_children->get_next( ).
    WHILE lo_ixml_dxf_child IS BOUND.

      lv_dxf_child_type = lo_ixml_dxf_child->get_name( ).
      CASE lv_dxf_child_type.

        WHEN 'font'.
*--------------------------------------------------------------------*
* italic
*--------------------------------------------------------------------*
          lo_ixml_element = lo_ixml_dxf_child->find_from_name_ns( name = 'i' uri = namespace-main ).
          IF lo_ixml_element IS BOUND.
            CLEAR lv_val.
            lv_val  = lo_ixml_element->get_attribute_ns( 'val' ).
            IF lv_val <> '0'.
              ls_cstyle-font-italic  = 'X'.
              ls_cstylex-font-italic = 'X'.
            ENDIF.

          ENDIF.
*--------------------------------------------------------------------*
* bold
*--------------------------------------------------------------------*
          lo_ixml_element = lo_ixml_dxf_child->find_from_name_ns( name = 'b' uri = namespace-main ).
          IF lo_ixml_element IS BOUND.
            CLEAR lv_val.
            lv_val  = lo_ixml_element->get_attribute_ns( 'val' ).
            IF lv_val <> '0'.
              ls_cstyle-font-bold  = 'X'.
              ls_cstylex-font-bold = 'X'.
            ENDIF.

          ENDIF.
*--------------------------------------------------------------------*
* strikethrough
*--------------------------------------------------------------------*
          lo_ixml_element = lo_ixml_dxf_child->find_from_name_ns( name = 'strike' uri = namespace-main ).
          IF lo_ixml_element IS BOUND.
            CLEAR lv_val.
            lv_val  = lo_ixml_element->get_attribute_ns( 'val' ).
            IF lv_val <> '0'.
              ls_cstyle-font-strikethrough  = 'X'.
              ls_cstylex-font-strikethrough = 'X'.
            ENDIF.

          ENDIF.
*--------------------------------------------------------------------*
* color
*--------------------------------------------------------------------*
          lo_ixml_element = lo_ixml_dxf_child->find_from_name_ns( name = 'color' uri = namespace-main ).
          IF lo_ixml_element IS BOUND.
            CLEAR lv_val.
            lv_val  = lo_ixml_element->get_attribute_ns( 'rgb' ).
            ls_cstyle-font-color-rgb  = lv_val.
            ls_cstylex-font-color-rgb = 'X'.
          ENDIF.

        WHEN 'fill'.
          lo_ixml_element = lo_ixml_dxf_child->find_from_name_ns( name = 'patternFill' uri = namespace-main ).
          IF lo_ixml_element IS BOUND.
            lo_ixml_element2 = lo_ixml_dxf_child->find_from_name_ns( name = 'bgColor' uri = namespace-main ).
            IF lo_ixml_element2 IS BOUND.
              CLEAR lv_val.
              lv_val  = lo_ixml_element2->get_attribute_ns( 'rgb' ).
              IF lv_val IS NOT INITIAL.
                ls_cstyle-fill-filltype       = Lcl_excel_style_fill=>c_fill_solid.
                ls_cstyle-fill-bgcolor-rgb    = lv_val.
                ls_cstylex-fill-filltype      = 'X'.
                ls_cstylex-fill-bgcolor-rgb   = 'X'.
              ENDIF.
              CLEAR lv_val.
              lv_val  = lo_ixml_element2->get_attribute_ns( 'theme' ).
              IF lv_val IS NOT INITIAL.
                ls_cstyle-fill-filltype         = Lcl_excel_style_fill=>c_fill_solid.
                ls_cstyle-fill-bgcolor-theme    = lv_val.
                ls_cstylex-fill-filltype        = 'X'.
                ls_cstylex-fill-bgcolor-theme   = 'X'.
              ENDIF.
              CLEAR lv_val.
            ENDIF.
          ENDIF.

      ENDCASE.

      lo_ixml_dxf_child ?= lo_ixml_iterator_dxf_children->get_next( ).

    ENDWHILE.

    rv_style_guid = io_excel->get_static_cellstyle_guid( ip_cstyle_complete  = ls_cstyle
                                                         ip_cstylex_complete = ls_cstylex  ).


  ENDMETHOD.
  METHOD get_from_zip_archive.

    ASSERT zip IS BOUND. " zip object has to exist at this point

    r_content = zip->read(  i_filename ).

  ENDMETHOD.
  METHOD get_ixml_from_zip_archive.

    DATA: lv_content       TYPE xstring,
          lo_ixml          TYPE REF TO if_ixml,
          lo_streamfactory TYPE REF TO if_ixml_stream_factory,
          lo_istream       TYPE REF TO if_ixml_istream,
          lo_parser        TYPE REF TO if_ixml_parser.

*--------------------------------------------------------------------*
* Load XML file from archive into an input stream,
* and parse that stream into an ixml object
*--------------------------------------------------------------------*
    lv_content        = me->get_from_zip_archive( i_filename ).
    lo_ixml           = cl_ixml=>create( ).
    lo_streamfactory  = lo_ixml->create_stream_factory( ).
    lo_istream        = lo_streamfactory->create_istream_xstring( lv_content ).
    r_ixml            = lo_ixml->create_document( ).
    lo_parser         = lo_ixml->create_parser( stream_factory = lo_streamfactory
                                                istream        = lo_istream
                                                document       = r_ixml ).
    lo_parser->set_normalizing( is_normalizing ).
    lo_parser->set_validating( mode = if_ixml_parser=>co_no_validation ).
    lo_parser->parse( ).

  ENDMETHOD.
  METHOD load_comments.
    DATA: lo_comments_xml       TYPE REF TO if_ixml_document,
          lo_node_comment       TYPE REF TO if_ixml_element,
          lo_node_comment_child TYPE REF TO if_ixml_element,
          lo_node_r_child_t     TYPE REF TO if_ixml_element,
          lo_attr               TYPE REF TO if_ixml_attribute,
          lo_comment            TYPE REF TO Lcl_excel_comment,
          lv_comment_text       TYPE string,
          lv_node_value         TYPE string,
          lv_attr_value         TYPE string.

    lo_comments_xml = me->get_ixml_from_zip_archive( ip_path ).

    lo_node_comment ?= lo_comments_xml->find_from_name_ns( name = 'comment' uri = namespace-main ).
    WHILE lo_node_comment IS BOUND.

      CLEAR lv_comment_text.
      lo_attr = lo_node_comment->get_attribute_node_ns( name = 'ref' ).
      lv_attr_value  = lo_attr->get_value( ).

      lo_node_comment_child ?= lo_node_comment->get_first_child( ).
      WHILE lo_node_comment_child IS BOUND.
        " There will be rPr nodes here, but we do not support them
        " in comments right now; see 'load_shared_strings' for handling.
        " Extract the <t>...</t> part of each <r>-tag
        lo_node_r_child_t ?= lo_node_comment_child->find_from_name_ns( name = 't' uri = namespace-main ).
        IF lo_node_r_child_t IS BOUND.
          lv_node_value = lo_node_r_child_t->get_value( ).
          CONCATENATE lv_comment_text lv_node_value INTO lv_comment_text RESPECTING BLANKS.
        ENDIF.
        lo_node_comment_child ?= lo_node_comment_child->get_next( ).
      ENDWHILE.

      CREATE OBJECT lo_comment.
      lo_comment->set_text( ip_ref = lv_attr_value ip_text = lv_comment_text ).
      io_worksheet->add_comment( lo_comment ).

      lo_node_comment ?= lo_node_comment->get_next( ).
    ENDWHILE.

  ENDMETHOD.
  METHOD load_drawing_anchor.

    TYPES: BEGIN OF t_c_nv_pr,
             name TYPE string,
             id   TYPE string,
           END OF t_c_nv_pr.

    TYPES: BEGIN OF t_blip,
             cstate TYPE string,
             embed  TYPE string,
           END OF t_blip.

    TYPES: BEGIN OF t_chart,
             id TYPE string,
           END OF t_chart.

    TYPES: BEGIN OF t_ext,
             cx TYPE string,
             cy TYPE string,
           END OF t_ext.

    CONSTANTS: lc_xml_attr_true     TYPE string VALUE 'true',
               lc_xml_attr_true_int TYPE string VALUE '1'.
    CONSTANTS: lc_rel_chart TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
               lc_rel_image TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image'.

    DATA: lo_drawing     TYPE REF TO Lcl_excel_drawing,
          node           TYPE REF TO if_ixml_element,
          node2          TYPE REF TO if_ixml_element,
          node3          TYPE REF TO if_ixml_element,
          node4          TYPE REF TO if_ixml_element,

          ls_upper       TYPE zexcel_drawing_location,
          ls_lower       TYPE zexcel_drawing_location,
          ls_size        TYPE zexcel_drawing_size,
          ext            TYPE t_ext,
          lv_content     TYPE xstring,
          lv_relation_id TYPE string,
          lv_title       TYPE string,

          cnvpr          TYPE t_c_nv_pr,
          blip           TYPE t_blip,
          chart          TYPE t_chart,
          drawing_type   TYPE zexcel_drawing_type,

          rel_drawing    TYPE t_rel_drawing.

    node ?= io_anchor_element->find_from_name_ns( name = 'from' uri = namespace-xdr ).
    CHECK node IS NOT INITIAL.
    node2 ?= node->find_from_name_ns( name = 'col' uri = namespace-xdr ).
    ls_upper-col = node2->get_value( ).
    node2 ?= node->find_from_name_ns( name = 'row' uri = namespace-xdr ).
    ls_upper-row = node2->get_value( ).
    node2 ?= node->find_from_name_ns( name = 'colOff' uri = namespace-xdr ).
    ls_upper-col_offset = node2->get_value( ).
    node2 ?= node->find_from_name_ns( name = 'rowOff' uri = namespace-xdr ).
    ls_upper-row_offset = node2->get_value( ).

    node ?= io_anchor_element->find_from_name_ns( name = 'ext' uri = namespace-xdr ).
    IF node IS INITIAL.
      CLEAR ls_size.
    ELSE.
      me->fill_struct_from_attributes( EXPORTING ip_element = node CHANGING cp_structure = ext ).
      ls_size-width = ext-cx.
      ls_size-height = ext-cy.
      TRY.
          ls_size-width  = Lcl_excel_drawing=>emu2pixel( ls_size-width ).
        CATCH cx_root.
      ENDTRY.
      TRY.
          ls_size-height = Lcl_excel_drawing=>emu2pixel( ls_size-height ).
        CATCH cx_root.
      ENDTRY.
    ENDIF.

    node ?= io_anchor_element->find_from_name_ns( name = 'to' uri = namespace-xdr ).
    IF node IS INITIAL.
      CLEAR ls_lower.
    ELSE.
      node2 ?= node->find_from_name_ns( name = 'col' uri = namespace-xdr ).
      ls_lower-col = node2->get_value( ).
      node2 ?= node->find_from_name_ns( name = 'row' uri = namespace-xdr ).
      ls_lower-row = node2->get_value( ).
      node2 ?= node->find_from_name_ns( name = 'colOff' uri = namespace-xdr ).
      ls_lower-col_offset = node2->get_value( ).
      node2 ?= node->find_from_name_ns( name = 'rowOff' uri = namespace-xdr ).
      ls_lower-row_offset = node2->get_value( ).
    ENDIF.

    node ?= io_anchor_element->find_from_name_ns( name = 'pic' uri = namespace-xdr ).
    IF node IS NOT INITIAL.
      node2 ?= node->find_from_name_ns( name = 'nvPicPr' uri = namespace-xdr ).
      CHECK node2 IS NOT INITIAL.
      node3 ?= node2->find_from_name_ns( name = 'cNvPr' uri = namespace-xdr ).
      CHECK node3 IS NOT INITIAL.
      me->fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = cnvpr ).
      lv_title = cnvpr-name.

      node2 ?= node->find_from_name_ns( name = 'blipFill' uri = namespace-xdr ).
      CHECK node2 IS NOT INITIAL.
      node3 ?= node2->find_from_name_ns( name = 'blip' uri = namespace-a ).
      CHECK node3 IS NOT INITIAL.
      me->fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = blip ).
      lv_relation_id = blip-embed.

      drawing_type = Lcl_excel_drawing=>type_image.
    ENDIF.

    node ?= io_anchor_element->find_from_name_ns( name = 'graphicFrame' uri = namespace-xdr ).
    IF node IS NOT INITIAL.
      node2 ?= node->find_from_name_ns( name = 'nvGraphicFramePr' uri = namespace-xdr ).
      CHECK node2 IS NOT INITIAL.
      node3 ?= node2->find_from_name_ns( name = 'cNvPr' uri = namespace-xdr ).
      CHECK node3 IS NOT INITIAL.
      me->fill_struct_from_attributes( EXPORTING ip_element = node3 CHANGING cp_structure = cnvpr ).
      lv_title = cnvpr-name.

      node2 ?= node->find_from_name_ns( name = 'graphic' uri = namespace-a ).
      CHECK node2 IS NOT INITIAL.
      node3 ?= node2->find_from_name_ns( name = 'graphicData' uri = namespace-a ).
      CHECK node3 IS NOT INITIAL.
      node4 ?= node2->find_from_name_ns( name = 'chart' uri = namespace-c ).
      CHECK node4 IS NOT INITIAL.
      me->fill_struct_from_attributes( EXPORTING ip_element = node4 CHANGING cp_structure = chart ).
      lv_relation_id = chart-id.

      drawing_type = Lcl_excel_drawing=>type_chart.
    ENDIF.

    lo_drawing = io_worksheet->excel->add_new_drawing(
                      ip_type  = drawing_type
                      ip_title = lv_title ).
    io_worksheet->add_drawing( lo_drawing ).

    lo_drawing->set_position2(
      EXPORTING
        ip_from   = ls_upper
        ip_to     = ls_lower ).

    READ TABLE it_related_drawings INTO rel_drawing
          WITH KEY id = lv_relation_id.

    lo_drawing->set_media(
      EXPORTING
        ip_media = rel_drawing-content
        ip_media_type = rel_drawing-file_ext
        ip_width = ls_size-width
        ip_height = ls_size-height ).

    IF drawing_type = Lcl_excel_drawing=>type_chart.
*  Begin fix for Issue #551
      DATA: lo_tmp_node_2                TYPE REF TO if_ixml_element.
      lo_tmp_node_2 ?= rel_drawing-content_xml->find_from_name_ns( name = 'pieChart' uri = namespace-c ).
      IF lo_tmp_node_2 IS NOT INITIAL.
        lo_drawing->graph_type = Lcl_excel_drawing=>c_graph_pie.
      ELSE.
        lo_tmp_node_2 ?= rel_drawing-content_xml->find_from_name_ns( name = 'barChart' uri = namespace-c ).
        IF lo_tmp_node_2 IS NOT INITIAL.
          lo_drawing->graph_type = Lcl_excel_drawing=>c_graph_bars.
        ELSE.
          lo_tmp_node_2 ?= rel_drawing-content_xml->find_from_name_ns( name = 'lineChart' uri = namespace-c ).
          IF lo_tmp_node_2 IS NOT INITIAL.
            lo_drawing->graph_type = Lcl_excel_drawing=>c_graph_line.
          ENDIF.
        ENDIF.
      ENDIF.
* End fix for issue #551
      "-------------Added by Alessandro Iannacci - Should load chart attributes
      lo_drawing->load_chart_attributes( rel_drawing-content_xml ).
    ENDIF.

  ENDMETHOD.
  METHOD load_dxf_styles.

    DATA: lo_styles_xml   TYPE REF TO if_ixml_document,
          lo_node_dxfs    TYPE REF TO if_ixml_element,

          lo_nodes_dxf    TYPE REF TO if_ixml_node_collection,
          lo_iterator_dxf TYPE REF TO if_ixml_node_iterator,
          lo_node_dxf     TYPE REF TO if_ixml_element,

          lv_dxf_count    TYPE i.

    FIELD-SYMBOLS: <ls_dxf_style> LIKE LINE OF mt_dxf_styles.

*--------------------------------------------------------------------*
* Look for dxfs-node
*--------------------------------------------------------------------*
    lo_styles_xml = me->get_ixml_from_zip_archive( iv_path ).
    lo_node_dxfs  = lo_styles_xml->find_from_name_ns( name = 'dxfs' uri = namespace-main ).
    CHECK lo_node_dxfs IS BOUND.


*--------------------------------------------------------------------*
* loop through all dxf-nodes and create style for each
*--------------------------------------------------------------------*
    lo_nodes_dxf ?= lo_node_dxfs->get_elements_by_tag_name_ns( name = 'dxf' uri = namespace-main ).
    lo_iterator_dxf = lo_nodes_dxf->create_iterator( ).
    lo_node_dxf ?= lo_iterator_dxf->get_next( ).
    WHILE lo_node_dxf IS BOUND.

      APPEND INITIAL LINE TO mt_dxf_styles ASSIGNING <ls_dxf_style>.
      <ls_dxf_style>-dxf = lv_dxf_count. " We start counting at 0
      ADD 1 TO lv_dxf_count.             " prepare next entry

      <ls_dxf_style>-guid = get_dxf_style_guid( io_ixml_dxf = lo_node_dxf
                                                io_excel    = io_excel ).
      lo_node_dxf ?= lo_iterator_dxf->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD load_shared_strings.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   Support partial formatting of strings in cells
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-11
*              - ...
* changes: renaming variables to naming conventions
*          renaming variables to indicate what they are used for
*          aligning code
*          adding comments to explain what we are trying to achieve
*          rewriting code for better readibility
*--------------------------------------------------------------------*



    DATA:
      lo_shared_strings_xml TYPE REF TO if_ixml_document,
      lo_node_si            TYPE REF TO if_ixml_element,
      lo_node_si_child      TYPE REF TO if_ixml_element,
      lo_node_r_child_t     TYPE REF TO if_ixml_element,
      lo_node_r_child_rpr   TYPE REF TO if_ixml_element,
      lo_font               TYPE REF TO Lcl_excel_style_font,
      ls_rtf                TYPE zexcel_s_rtf,
      lv_current_offset     TYPE int2,
      lv_tag_name           TYPE string,
      lv_node_value         TYPE string.

    FIELD-SYMBOLS: <ls_shared_string>           LIKE LINE OF me->shared_strings.

*--------------------------------------------------------------------*

* §1  Parse shared strings file and get into internal table
*   So far I have encountered 2 ways how a string can be represented in the shared strings file
*   §1.1 - "simple" strings
*   §1.2 - rich text formatted strings

*     Following is an example how this file could be set up; 2 strings in simple formatting, 3rd string rich textformatted


*        <?xml version="1.0" encoding="UTF-8" standalone="true"?>
*        <sst uniqueCount="6" count="6" xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
*            <si>
*                <t>This is a teststring 1</t>
*            </si>
*            <si>
*                <t>This is a teststring 2</t>
*            </si>
*            <si>
*                <r>
*                  <t>T</t>
*                </r>
*                <r>
*                    <rPr>
*                        <sz val="11"/>
*                        <color rgb="FFFF0000"/>
*                        <rFont val="Calibri"/>
*                        <family val="2"/>
*                        <scheme val="minor"/>
*                    </rPr>
*                    <t xml:space="preserve">his is a </t>
*                </r>
*                <r>
*                    <rPr>
*                        <sz val="11"/>
*                        <color theme="1"/>
*                        <rFont val="Calibri"/>
*                        <family val="2"/>
*                        <scheme val="minor"/>
*                    </rPr>
*                    <t>teststring 3</t>
*                </r>
*            </si>
*        </sst>
*--------------------------------------------------------------------*

    lo_shared_strings_xml = me->get_ixml_from_zip_archive( i_filename     = ip_path
                                                           is_normalizing = space ).  " NO!!! normalizing - otherwise leading blanks will be omitted and that is not really desired for the stringtable
    lo_node_si ?= lo_shared_strings_xml->find_from_name_ns( name = 'si' uri = namespace-main ).
    WHILE lo_node_si IS BOUND.

      APPEND INITIAL LINE TO me->shared_strings ASSIGNING <ls_shared_string>.            " Each <si>-entry in the xml-file must lead to an entry in our stringtable
      lo_node_si_child ?= lo_node_si->get_first_child( ).
      IF lo_node_si_child IS BOUND.
        lv_tag_name = lo_node_si_child->get_name( ).
        IF lv_tag_name = 't'.
*--------------------------------------------------------------------*
*   §1.1 - "simple" strings
*                Example:  see above
*--------------------------------------------------------------------*
          <ls_shared_string>-value = unescape_string_value( lo_node_si_child->get_value( ) ).
        ELSE.
*--------------------------------------------------------------------*
*   §1.2 - rich text formatted strings
*       it is sufficient to strip the <t>...</t> tag from each <r>-tag and concatenate these
*       as long as rich text formatting is not supported (2do§1) ignore all info about formatting
*                Example:  see above
*--------------------------------------------------------------------*
          CLEAR: lv_current_offset.
          WHILE lo_node_si_child IS BOUND.                                             " actually these children of <si> are <r>-tags
            CLEAR: ls_rtf.

            " extracting rich text formating data
            lo_node_r_child_rpr ?= lo_node_si_child->find_from_name_ns( name = 'rPr' uri = namespace-main ).
            IF lo_node_r_child_rpr IS BOUND.
              lo_font = load_style_font( lo_node_r_child_rpr ).
              ls_rtf-font = lo_font->get_structure( ).
            ENDIF.
            ls_rtf-offset = lv_current_offset.
            " extract the <t>...</t> part of each <r>-tag
            lo_node_r_child_t ?= lo_node_si_child->find_from_name_ns( name = 't' uri = namespace-main ).
            IF lo_node_r_child_t IS BOUND.
              lv_node_value = unescape_string_value( lo_node_r_child_t->get_value( ) ).
              CONCATENATE <ls_shared_string>-value lv_node_value INTO <ls_shared_string>-value RESPECTING BLANKS.
              ls_rtf-length = strlen( lv_node_value ).
            ENDIF.

            lv_current_offset = strlen( <ls_shared_string>-value ).
            APPEND ls_rtf TO <ls_shared_string>-rtf.

            lo_node_si_child ?= lo_node_si_child->get_next( ).

          ENDWHILE.
        ENDIF.
      ENDIF.

      lo_node_si ?= lo_node_si->get_next( ).
    ENDWHILE.

  ENDMETHOD.
  METHOD load_styles.

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (wip )              2012-11-25
*              - ...
* changes: renaming variables and types to naming conventions
*          aligning code
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*
    TYPES: BEGIN OF lty_xf,
             applyalignment    TYPE string,
             applyborder       TYPE string,
             applyfill         TYPE string,
             applyfont         TYPE string,
             applynumberformat TYPE string,
             applyprotection   TYPE string,
             borderid          TYPE string,
             fillid            TYPE string,
             fontid            TYPE string,
             numfmtid          TYPE string,
             pivotbutton       TYPE string,
             quoteprefix       TYPE string,
             xfid              TYPE string,
           END OF lty_xf.

    TYPES: BEGIN OF lty_alignment,
             horizontal      TYPE string,
             indent          TYPE string,
             justifylastline TYPE string,
             readingorder    TYPE string,
             relativeindent  TYPE string,
             shrinktofit     TYPE string,
             textrotation    TYPE string,
             vertical        TYPE string,
             wraptext        TYPE string,
           END OF lty_alignment.

    TYPES: BEGIN OF lty_protection,
             hidden TYPE string,
             locked TYPE string,
           END OF lty_protection.

    DATA: lo_styles_xml                 TYPE REF TO if_ixml_document,
          lo_style                      TYPE REF TO Lcl_excel_style,

          lt_num_formats                TYPE Lcl_excel_style_number_format=>t_num_formats,
          lt_fills                      TYPE t_fills,
          lt_borders                    TYPE t_borders,
          lt_fonts                      TYPE t_fonts,

          ls_num_format                 TYPE Lcl_excel_style_number_format=>t_num_format,
          ls_fill                       TYPE REF TO Lcl_excel_style_fill,
          ls_cell_border                TYPE REF TO Lcl_excel_style_borders,
          ls_font                       TYPE REF TO Lcl_excel_style_font,

          lo_node_cellxfs               TYPE REF TO if_ixml_element,
          lo_node_cellxfs_xf            TYPE REF TO if_ixml_element,
          lo_node_cellxfs_xf_alignment  TYPE REF TO if_ixml_element,
          lo_node_cellxfs_xf_protection TYPE REF TO if_ixml_element,

          lo_nodes_xf                   TYPE REF TO if_ixml_node_collection,
          lo_iterator_cellxfs           TYPE REF TO if_ixml_node_iterator,

          ls_xf                         TYPE lty_xf,
          ls_alignment                  TYPE lty_alignment,
          ls_protection                 TYPE lty_protection,
          lv_index                      TYPE i.

*--------------------------------------------------------------------*
* To build a complete style that fully describes how a cell looks like
* we need the various parts
* §1 - Numberformat
* §2 - Fillstyle
* §3 - Borders
* §4 - Font
* §5 - Alignment
* §6 - Protection

*          Following is an example how this part of a file could be set up
*              ...
*              parts with various formatinformation - see §1,§2,§3,§4
*              ...
*          <cellXfs count="26">
*              <xf numFmtId="0" borderId="0" fillId="0" fontId="0" xfId="0"/>
*              <xf numFmtId="0" borderId="0" fillId="2" fontId="0" xfId="0" applyFill="1"/>
*              <xf numFmtId="0" borderId="1" fillId="3" fontId="0" xfId="0" applyFill="1" applyBorder="1"/>
*              <xf numFmtId="0" borderId="2" fillId="3" fontId="0" xfId="0" applyFill="1" applyBorder="1"/>
*              <xf numFmtId="0" borderId="3" fillId="3" fontId="0" xfId="0" applyFill="1" applyBorder="1"/>
*              <xf numFmtId="0" borderId="4" fillId="3" fontId="0" xfId="0" applyFill="1" applyBorder="1"/>
*              <xf numFmtId="0" borderId="0" fillId="3" fontId="0" xfId="0" applyFill="1" applyBorder="1"/>
*              ...
*          </cellXfs>
*--------------------------------------------------------------------*

    lo_styles_xml = me->get_ixml_from_zip_archive( ip_path ).

*--------------------------------------------------------------------*
* The styles are build up from
* §1 number formats
* §2 fill styles
* §3 border styles
* §4 fonts
* These need to be read before we can try to build up a complete
* style that describes the look of a cell
*--------------------------------------------------------------------*
    lt_num_formats   = load_style_num_formats( lo_styles_xml ).   " §1
    lt_fills         = load_style_fills( lo_styles_xml ).         " §2
    lt_borders       = load_style_borders( lo_styles_xml ).       " §3
    lt_fonts         = load_style_fonts( lo_styles_xml ).         " §4

*--------------------------------------------------------------------*
* Now everything is prepared to build a "full" style
*--------------------------------------------------------------------*
    lo_node_cellxfs  = lo_styles_xml->find_from_name_ns( name = 'cellXfs' uri = namespace-main ).
    IF lo_node_cellxfs IS BOUND.
      lo_nodes_xf         = lo_node_cellxfs->get_elements_by_tag_name_ns( name = 'xf' uri = namespace-main ).
      lo_iterator_cellxfs = lo_nodes_xf->create_iterator( ).
      lo_node_cellxfs_xf ?= lo_iterator_cellxfs->get_next( ).
      WHILE lo_node_cellxfs_xf IS BOUND.

        lo_style = ip_excel->add_new_style( ).
        fill_struct_from_attributes( EXPORTING
                                       ip_element   =  lo_node_cellxfs_xf
                                     CHANGING
                                       cp_structure = ls_xf ).
*--------------------------------------------------------------------*
* §2 fill style
*--------------------------------------------------------------------*
        IF ls_xf-applyfill = '1' AND ls_xf-fillid IS NOT INITIAL.
          lv_index = ls_xf-fillid + 1.
          READ TABLE lt_fills INTO ls_fill INDEX lv_index.
          IF sy-subrc = 0.
            lo_style->fill = ls_fill.
          ENDIF.
        ENDIF.

*--------------------------------------------------------------------*
* §1 number format
*--------------------------------------------------------------------*
        IF ls_xf-numfmtid IS NOT INITIAL.
          READ TABLE lt_num_formats INTO ls_num_format WITH TABLE KEY id = ls_xf-numfmtid.
          IF sy-subrc = 0.
            lo_style->number_format = ls_num_format-format.
          ENDIF.
        ENDIF.

*--------------------------------------------------------------------*
* §3 border style
*--------------------------------------------------------------------*
        IF ls_xf-applyborder = '1' AND ls_xf-borderid IS NOT INITIAL.
          lv_index = ls_xf-borderid + 1.
          READ TABLE lt_borders INTO ls_cell_border INDEX lv_index.
          IF sy-subrc = 0.
            lo_style->borders = ls_cell_border.
          ENDIF.
        ENDIF.

*--------------------------------------------------------------------*
* §4 font
*--------------------------------------------------------------------*
        IF ls_xf-applyfont = '1' AND ls_xf-fontid IS NOT INITIAL.
          lv_index = ls_xf-fontid + 1.
          READ TABLE lt_fonts INTO ls_font INDEX lv_index.
          IF sy-subrc = 0.
            lo_style->font = ls_font.
          ENDIF.
        ENDIF.

*--------------------------------------------------------------------*
* §5 - Alignment
*--------------------------------------------------------------------*
        lo_node_cellxfs_xf_alignment ?= lo_node_cellxfs_xf->find_from_name_ns( name = 'alignment' uri = namespace-main ).
        IF lo_node_cellxfs_xf_alignment IS BOUND.
          fill_struct_from_attributes( EXPORTING
                                         ip_element   =  lo_node_cellxfs_xf_alignment
                                       CHANGING
                                         cp_structure = ls_alignment ).
          IF ls_alignment-horizontal IS NOT INITIAL.
            lo_style->alignment->horizontal = ls_alignment-horizontal.
          ENDIF.

          IF ls_alignment-vertical IS NOT INITIAL.
            lo_style->alignment->vertical = ls_alignment-vertical.
          ENDIF.

          IF ls_alignment-textrotation IS NOT INITIAL.
            lo_style->alignment->textrotation = ls_alignment-textrotation.
          ENDIF.

          IF ls_alignment-wraptext = '1' OR ls_alignment-wraptext = 'true'.
            lo_style->alignment->wraptext = abap_true.
          ENDIF.

          IF ls_alignment-shrinktofit = '1' OR ls_alignment-shrinktofit = 'true'.
            lo_style->alignment->shrinktofit = abap_true.
          ENDIF.

          IF ls_alignment-indent IS NOT INITIAL.
            lo_style->alignment->indent = ls_alignment-indent.
          ENDIF.
        ENDIF.

*--------------------------------------------------------------------*
* §6 - Protection
*--------------------------------------------------------------------*
        lo_node_cellxfs_xf_protection ?= lo_node_cellxfs_xf->find_from_name_ns( name = 'protection' uri = namespace-main ).
        IF lo_node_cellxfs_xf_protection IS BOUND.
          fill_struct_from_attributes( EXPORTING
                                         ip_element   = lo_node_cellxfs_xf_protection
                                       CHANGING
                                         cp_structure = ls_protection ).
          IF ls_protection-locked = '1' OR ls_protection-locked = 'true'.
            lo_style->protection->locked = Lcl_excel_style_protection=>c_protection_locked.
          ELSE.
            lo_style->protection->locked = Lcl_excel_style_protection=>c_protection_unlocked.
          ENDIF.

          IF ls_protection-hidden = '1' OR ls_protection-hidden = 'true'.
            lo_style->protection->hidden = Lcl_excel_style_protection=>c_protection_hidden.
          ELSE.
            lo_style->protection->hidden = Lcl_excel_style_protection=>c_protection_unhidden.
          ENDIF.

        ENDIF.

        INSERT lo_style INTO TABLE me->styles.

        lo_node_cellxfs_xf ?= lo_iterator_cellxfs->get_next( ).

      ENDWHILE.
    ENDIF.

  ENDMETHOD.
  METHOD load_style_borders.

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-25
*              - ...
* changes: renaming variables and types to naming conventions
*          aligning code
*          renaming variables to indicate what they are used for
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*
    DATA: lo_node_border      TYPE REF TO if_ixml_element,
          lo_node_bordertype  TYPE REF TO if_ixml_element,
          lo_node_bordercolor TYPE REF TO if_ixml_element,
          lo_cell_border      TYPE REF TO Lcl_excel_style_borders,
          lo_border           TYPE REF TO Lcl_excel_style_border,
          ls_color            TYPE t_color.

*--------------------------------------------------------------------*
* We need a table of used borderformats to build up our styles
* §1    A cell has 4 outer borders and 2 diagonal "borders"
*       These borders can be formatted separately but the diagonal borders
*       are always being formatted the same
*       We'll parse through the <border>-tag for each of the bordertypes
* §2    and read the corresponding formatting information

*          Following is an example how this part of a file could be set up
*          <border diagonalDown="1">
*              <left style="mediumDashDotDot">
*                  <color rgb="FFFF0000"/>
*              </left>
*              <right/>
*              <top style="thick">
*                  <color rgb="FFFF0000"/>
*              </top>
*              <bottom style="thick">
*                  <color rgb="FFFF0000"/>
*              </bottom>
*              <diagonal style="thick">
*                  <color rgb="FFFF0000"/>
*              </diagonal>
*          </border>
*--------------------------------------------------------------------*
    lo_node_border ?= ip_xml->find_from_name_ns( name = 'border' uri = namespace-main ).
    WHILE lo_node_border IS BOUND.

      CREATE OBJECT lo_cell_border.

*--------------------------------------------------------------------*
* Diagonal borderlines are formatted the equally.  Determine what kind of diagonal borders are present if any
*--------------------------------------------------------------------*
* DiagonalNone = 0
* DiagonalUp   = 1
* DiagonalDown = 2
* DiagonalBoth = 3
*--------------------------------------------------------------------*
      IF lo_node_border->get_attribute( 'diagonalDown' ) IS NOT INITIAL.
        ADD Lcl_excel_style_borders=>c_diagonal_down TO lo_cell_border->diagonal_mode.
      ENDIF.

      IF lo_node_border->get_attribute( 'diagonalUp' ) IS NOT INITIAL.
        ADD Lcl_excel_style_borders=>c_diagonal_up TO lo_cell_border->diagonal_mode.
      ENDIF.

      lo_node_bordertype ?= lo_node_border->get_first_child( ).
      WHILE lo_node_bordertype IS BOUND.
*--------------------------------------------------------------------*
* §1 Determine what kind of border we are talking about
*--------------------------------------------------------------------*
* Up, down, left, right, diagonal
*--------------------------------------------------------------------*
        CREATE OBJECT lo_border.

        CASE lo_node_bordertype->get_name( ).

          WHEN 'left'.
            lo_cell_border->left = lo_border.

          WHEN 'right'.
            lo_cell_border->right = lo_border.

          WHEN 'top'.
            lo_cell_border->top = lo_border.

          WHEN 'bottom'.
            lo_cell_border->down = lo_border.

          WHEN 'diagonal'.
            lo_cell_border->diagonal = lo_border.

        ENDCASE.

*--------------------------------------------------------------------*
* §2 Read the border-formatting
*--------------------------------------------------------------------*
        lo_border->border_style = lo_node_bordertype->get_attribute( 'style' ).
        lo_node_bordercolor ?= lo_node_bordertype->find_from_name_ns( name = 'color' uri = namespace-main ).
        IF lo_node_bordercolor IS BOUND.
          fill_struct_from_attributes( EXPORTING
                                         ip_element   =  lo_node_bordercolor
                                       CHANGING
                                         cp_structure = ls_color ).

          lo_border->border_color-rgb = ls_color-rgb.
          IF ls_color-indexed IS NOT INITIAL.
            lo_border->border_color-indexed = ls_color-indexed.
          ENDIF.

          IF ls_color-theme IS NOT INITIAL.
            lo_border->border_color-theme = ls_color-theme.
          ENDIF.
          lo_border->border_color-tint = ls_color-tint.
        ENDIF.

        lo_node_bordertype ?= lo_node_bordertype->get_next( ).

      ENDWHILE.

      INSERT lo_cell_border INTO TABLE ep_borders.

      lo_node_border ?= lo_node_border->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD load_style_fills.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   Support gradientFill
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-25
*              - ...
* changes: renaming variables and types to naming conventions
*          aligning code
*          commenting on problems/future enhancements/todos we already know of or should decide upon
*          adding comments to explain what we are trying to achieve
*          renaming variables to indicate what they are used for
*--------------------------------------------------------------------*
    DATA: lv_value           TYPE string,
          lo_node_fill       TYPE REF TO if_ixml_element,
          lo_node_fill_child TYPE REF TO if_ixml_element,
          lo_node_bgcolor    TYPE REF TO if_ixml_element,
          lo_node_fgcolor    TYPE REF TO if_ixml_element,
          lo_node_stop       TYPE REF TO if_ixml_element,
          lo_fill            TYPE REF TO Lcl_excel_style_fill,
          ls_color           TYPE t_color.

*--------------------------------------------------------------------*
* We need a table of used fillformats to build up our styles

*          Following is an example how this part of a file could be set up
*          <fill>
*              <patternFill patternType="gray125"/>
*          </fill>
*          <fill>
*              <patternFill patternType="solid">
*                  <fgColor rgb="FFFFFF00"/>
*                  <bgColor indexed="64"/>
*              </patternFill>
*          </fill>
*--------------------------------------------------------------------*

    lo_node_fill ?= ip_xml->find_from_name_ns( name = 'fill' uri = namespace-main ).
    WHILE lo_node_fill IS BOUND.

      CREATE OBJECT lo_fill.
      lo_node_fill_child ?= lo_node_fill->get_first_child( ).
      lv_value            = lo_node_fill_child->get_name( ).
      CASE lv_value.

*--------------------------------------------------------------------*
* Patternfill
*--------------------------------------------------------------------*
        WHEN 'patternFill'.
          lo_fill->filltype = lo_node_fill_child->get_attribute( 'patternType' ).
*--------------------------------------------------------------------*
* Patternfill - background color
*--------------------------------------------------------------------*
          lo_node_bgcolor = lo_node_fill_child->find_from_name_ns( name = 'bgColor' uri = namespace-main ).
          IF lo_node_bgcolor IS BOUND.
            fill_struct_from_attributes( EXPORTING
                                           ip_element   = lo_node_bgcolor
                                         CHANGING
                                           cp_structure = ls_color ).

            lo_fill->bgcolor-rgb = ls_color-rgb.
            IF ls_color-indexed IS NOT INITIAL.
              lo_fill->bgcolor-indexed = ls_color-indexed.
            ENDIF.

            IF ls_color-theme IS NOT INITIAL.
              lo_fill->bgcolor-theme = ls_color-theme.
            ENDIF.
            lo_fill->bgcolor-tint = ls_color-tint.
          ENDIF.

*--------------------------------------------------------------------*
* Patternfill - foreground color
*--------------------------------------------------------------------*
          lo_node_fgcolor = lo_node_fill->find_from_name_ns( name = 'fgColor' uri = namespace-main ).
          IF lo_node_fgcolor IS BOUND.
            fill_struct_from_attributes( EXPORTING
                                           ip_element   = lo_node_fgcolor
                                         CHANGING
                                           cp_structure = ls_color ).

            lo_fill->fgcolor-rgb = ls_color-rgb.
            IF ls_color-indexed IS NOT INITIAL.
              lo_fill->fgcolor-indexed = ls_color-indexed.
            ENDIF.

            IF ls_color-theme IS NOT INITIAL.
              lo_fill->fgcolor-theme = ls_color-theme.
            ENDIF.
            lo_fill->fgcolor-tint = ls_color-tint.
          ENDIF.


*--------------------------------------------------------------------*
* gradientFill
*--------------------------------------------------------------------*
        WHEN 'gradientFill'.
          lo_fill->gradtype-type   = lo_node_fill_child->get_attribute( 'type' ).
          lo_fill->gradtype-top    = lo_node_fill_child->get_attribute( 'top' ).
          lo_fill->gradtype-left   = lo_node_fill_child->get_attribute( 'left' ).
          lo_fill->gradtype-right  = lo_node_fill_child->get_attribute( 'right' ).
          lo_fill->gradtype-bottom = lo_node_fill_child->get_attribute( 'bottom' ).
          lo_fill->gradtype-degree = lo_node_fill_child->get_attribute( 'degree' ).
          FREE lo_node_stop.
          lo_node_stop ?= lo_node_fill_child->find_from_name_ns( name = 'stop' uri = namespace-main ).
          WHILE lo_node_stop IS BOUND.
            IF lo_fill->gradtype-position1 IS INITIAL.
              lo_fill->gradtype-position1 = lo_node_stop->get_attribute( 'position' ).
              lo_node_bgcolor = lo_node_stop->find_from_name_ns( name = 'color' uri = namespace-main ).
              IF lo_node_bgcolor IS BOUND.
                fill_struct_from_attributes( EXPORTING
                                                ip_element   = lo_node_bgcolor
                                              CHANGING
                                                cp_structure = ls_color ).

                lo_fill->bgcolor-rgb = ls_color-rgb.
                IF ls_color-indexed IS NOT INITIAL.
                  lo_fill->bgcolor-indexed = ls_color-indexed.
                ENDIF.

                IF ls_color-theme IS NOT INITIAL.
                  lo_fill->bgcolor-theme = ls_color-theme.
                ENDIF.
                lo_fill->bgcolor-tint = ls_color-tint.
              ENDIF.
            ELSEIF lo_fill->gradtype-position2 IS INITIAL.
              lo_fill->gradtype-position2 = lo_node_stop->get_attribute( 'position' ).
              lo_node_fgcolor = lo_node_stop->find_from_name_ns( name = 'color' uri = namespace-main ).
              IF lo_node_fgcolor IS BOUND.
                fill_struct_from_attributes( EXPORTING
                                               ip_element   = lo_node_fgcolor
                                             CHANGING
                                               cp_structure = ls_color ).

                lo_fill->fgcolor-rgb = ls_color-rgb.
                IF ls_color-indexed IS NOT INITIAL.
                  lo_fill->fgcolor-indexed = ls_color-indexed.
                ENDIF.

                IF ls_color-theme IS NOT INITIAL.
                  lo_fill->fgcolor-theme = ls_color-theme.
                ENDIF.
                lo_fill->fgcolor-tint = ls_color-tint.
              ENDIF.
            ELSEIF lo_fill->gradtype-position3 IS INITIAL.
              lo_fill->gradtype-position3 = lo_node_stop->get_attribute( 'position' ).
              "BGColor is filled already with position 1 no need to check again
            ENDIF.

            lo_node_stop ?= lo_node_stop->get_next( ).
          ENDWHILE.

        WHEN OTHERS.

      ENDCASE.


      INSERT lo_fill INTO TABLE ep_fills.

      lo_node_fill ?= lo_node_fill->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD load_style_font.

    DATA: lo_node_font TYPE REF TO if_ixml_element,
          lo_node2     TYPE REF TO if_ixml_element,
          lo_font      TYPE REF TO Lcl_excel_style_font,
          ls_color     TYPE t_color.

    lo_node_font = io_xml_element.

    CREATE OBJECT lo_font.
*--------------------------------------------------------------------*
*   Bold
*--------------------------------------------------------------------*
    IF lo_node_font->find_from_name_ns( name = 'b' uri = namespace-main ) IS BOUND.
      lo_font->bold = abap_true.
    ENDIF.

*--------------------------------------------------------------------*
*   Italic
*--------------------------------------------------------------------*
    IF lo_node_font->find_from_name_ns( name = 'i' uri = namespace-main ) IS BOUND.
      lo_font->italic = abap_true.
    ENDIF.

*--------------------------------------------------------------------*
*   Underline
*--------------------------------------------------------------------*
    lo_node2 = lo_node_font->find_from_name_ns( name = 'u' uri = namespace-main ).
    IF lo_node2 IS BOUND.
      lo_font->underline      = abap_true.
      lo_font->underline_mode = lo_node2->get_attribute( 'val' ).
    ENDIF.

*--------------------------------------------------------------------*
*   StrikeThrough
*--------------------------------------------------------------------*
    IF lo_node_font->find_from_name_ns( name = 'strike' uri = namespace-main ) IS BOUND.
      lo_font->strikethrough = abap_true.
    ENDIF.

*--------------------------------------------------------------------*
*   Fontsize
*--------------------------------------------------------------------*
    lo_node2 = lo_node_font->find_from_name_ns( name = 'sz' uri = namespace-main ).
    IF lo_node2 IS BOUND.
      lo_font->size = lo_node2->get_attribute( 'val' ).
    ENDIF.

*--------------------------------------------------------------------*
*   Fontname
*--------------------------------------------------------------------*
    lo_node2 = lo_node_font->find_from_name_ns( name = 'name' uri = namespace-main ).
    IF lo_node2 IS BOUND.
      lo_font->name = lo_node2->get_attribute( 'val' ).
    ELSE.
      lo_node2 = lo_node_font->find_from_name_ns( name = 'rFont' uri = namespace-main ).
      IF lo_node2 IS BOUND.
        lo_font->name = lo_node2->get_attribute( 'val' ).
      ENDIF.
    ENDIF.

*--------------------------------------------------------------------*
*   Fontfamily
*--------------------------------------------------------------------*
    lo_node2 = lo_node_font->find_from_name_ns( name = 'family' uri = namespace-main ).
    IF lo_node2 IS BOUND.
      lo_font->family = lo_node2->get_attribute( 'val' ).
    ENDIF.

*--------------------------------------------------------------------*
*   Fontscheme
*--------------------------------------------------------------------*
    lo_node2 = lo_node_font->find_from_name_ns( name = 'scheme' uri = namespace-main ).
    IF lo_node2 IS BOUND.
      lo_font->scheme = lo_node2->get_attribute( 'val' ).
    ELSE.
      CLEAR lo_font->scheme.
    ENDIF.

*--------------------------------------------------------------------*
*   Fontcolor
*--------------------------------------------------------------------*
    lo_node2 = lo_node_font->find_from_name_ns( name = 'color' uri = namespace-main ).
    IF lo_node2 IS BOUND.
      fill_struct_from_attributes( EXPORTING
                                     ip_element   =  lo_node2
                                   CHANGING
                                     cp_structure = ls_color ).
      lo_font->color-rgb = ls_color-rgb.
      IF ls_color-indexed IS NOT INITIAL.
        lo_font->color-indexed = ls_color-indexed.
      ENDIF.

      IF ls_color-theme IS NOT INITIAL.
        lo_font->color-theme = ls_color-theme.
      ENDIF.
      lo_font->color-tint = ls_color-tint.
    ENDIF.

    ro_font = lo_font.

  ENDMETHOD.
  METHOD load_style_fonts.

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-25
*              - ...
* changes: renaming variables and types to naming conventions
*          aligning code
*          removing unused variables
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*
    DATA: lo_node_font TYPE REF TO if_ixml_element,
          lo_font      TYPE REF TO Lcl_excel_style_font.

*--------------------------------------------------------------------*
* We need a table of used fonts to build up our styles

*          Following is an example how this part of a file could be set up
*          <font>
*              <sz val="11"/>
*              <color theme="1"/>
*              <name val="Calibri"/>
*              <family val="2"/>
*              <scheme val="minor"/>
*          </font>
*--------------------------------------------------------------------*
    lo_node_font ?= ip_xml->find_from_name_ns( name = 'font' uri = namespace-main ).
    WHILE lo_node_font IS BOUND.

      lo_font = load_style_font( lo_node_font ).
      INSERT lo_font INTO TABLE ep_fonts.

      lo_node_font ?= lo_node_font->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD load_style_num_formats.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   Explain gaps in predefined formats
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-25
*              - ...
* changes: renaming variables and types to naming conventions
*          adding comments to explain what we are trying to achieve
*          aligning code
*--------------------------------------------------------------------*
    DATA: lo_node_numfmt TYPE REF TO if_ixml_element,
          ls_num_format  TYPE Lcl_excel_style_number_format=>t_num_format.

*--------------------------------------------------------------------*
* We need a table of used numberformats to build up our styles
* there are two kinds of numberformats
* §1 built-in numberformats
* §2 and those that have been explicitly added by the createor of the excel-file
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* §1 built-in numberformats
*--------------------------------------------------------------------*
    ep_num_formats = Lcl_excel_style_number_format=>mt_built_in_num_formats.

*--------------------------------------------------------------------*
* §2   Get non-internal numberformats that are found in the file explicitly

*         Following is an example how this part of a file could be set up
*         <numFmts count="1">
*             <numFmt formatCode="#,###,###,###,##0.00" numFmtId="164"/>
*         </numFmts>
*--------------------------------------------------------------------*
    lo_node_numfmt ?= ip_xml->find_from_name_ns( name = 'numFmt' uri = namespace-main ).
    WHILE lo_node_numfmt IS BOUND.

      CLEAR ls_num_format.

      CREATE OBJECT ls_num_format-format.
      ls_num_format-format->format_code = lo_node_numfmt->get_attribute( 'formatCode' ).
      ls_num_format-id                  = lo_node_numfmt->get_attribute( 'numFmtId' ).
      INSERT ls_num_format INTO TABLE ep_num_formats.

      lo_node_numfmt                          ?= lo_node_numfmt->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD load_theme.
    DATA theme TYPE REF TO Lcl_excel_theme.
    DATA: lo_theme_xml TYPE REF TO if_ixml_document.
    CREATE OBJECT theme.
    lo_theme_xml = me->get_ixml_from_zip_archive( iv_path ).
    theme->read_theme( io_theme_xml = lo_theme_xml  ).
    ip_excel->set_theme( io_theme = theme ).
  ENDMETHOD.
  METHOD load_workbook.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   Move macro-reading from Lcl_excel_reader_xlsm to this class
*                autodetect existance of macro/vba content
*                Allow inputparameter to explicitly tell reader to ignore vba-content
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-10
*              - ...
* changes: renaming variables to naming conventions
*          aligning code
*          removing unused variables
*          adding me-> where possible
*          renaming variables to indicate what they are used for
*          adding comments to explain what we are trying to achieve
*          renaming i/o parameters:  previous input-parameter ip_path  holds a (full) filename and not a path   --> rename to iv_workbook_full_filename
*                                                             ip_excel renamed while being at it                --> rename to io_excel
*--------------------------------------------------------------------*
* issue #232   - Read worksheetstate hidden/veryHidden
*              - Stefan Schmoecker,                          2012-11-11
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns
*           - Stefan Schmoecker,                             2012-12-02
* changes:    correction in named ranges to correctly attach
*             sheetlocal names/ranges to the correct sheet
*--------------------------------------------------------------------*
* issue#284 - Copied formulae ignored when reading excelfile
*           - Stefan Schmoecker,                             2013-08-02
* changes:    initialize area to hold referenced formulaedata
*             after all worksheets have been read resolve formuae
*--------------------------------------------------------------------*

    CONSTANTS: lcv_shared_strings             TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings',
               lcv_worksheet                  TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet',
               lcv_styles                     TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles',
               lcv_vba_project                TYPE string VALUE 'http://schemas.microsoft.com/office/2006/relationships/vbaProject', "#EC NEEDED     for future incorporation of XLSM-reader
               lcv_theme                      TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme',
*--------------------------------------------------------------------*
* #232: Read worksheetstate hidden/veryHidden - begin data declarations
*--------------------------------------------------------------------*
               lcv_worksheet_state_hidden     TYPE string VALUE 'hidden',
               lcv_worksheet_state_veryhidden TYPE string VALUE 'veryHidden'.
*--------------------------------------------------------------------*
* #232: Read worksheetstate hidden/veryHidden - end data declarations
*--------------------------------------------------------------------*

    DATA:
      lv_path                    TYPE string,
      lv_filename                TYPE chkfile,
      lv_full_filename           TYPE string,

      lo_rels_workbook           TYPE REF TO if_ixml_document,
      lt_worksheets              TYPE STANDARD TABLE OF t_relationship WITH NON-UNIQUE DEFAULT KEY,
      lo_workbook                TYPE REF TO if_ixml_document,
      lv_workbook_index          TYPE i,
      lv_worksheet_path          TYPE string,
      ls_sheet                   TYPE t_sheet,

      lo_node                    TYPE REF TO if_ixml_element,
      ls_relationship            TYPE t_relationship,
      lo_worksheet               TYPE REF TO Lcl_excel_worksheet,
      lo_range                   TYPE REF TO Lcl_excel_range,
      lv_worksheet_title         TYPE zexcel_sheet_title,
      lv_tabix                   TYPE i,            " #235 - repeat rows/cols.  Needed to link defined name to correct worksheet

      ls_range                   TYPE t_range,
      lv_range_value             TYPE zexcel_range_value,
      lv_position_temp           TYPE i,
*--------------------------------------------------------------------*
* #229: Set active worksheet - begin data declarations
*--------------------------------------------------------------------*
      lv_active_sheet_string     TYPE string,
      lv_zexcel_active_worksheet TYPE zexcel_active_worksheet,
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns  - added autofilter support while changing this section
      lo_autofilter              TYPE REF TO Lcl_excel_autofilter,
      ls_area                    TYPE zexcel_s_autofilter_area,
      lv_col_start_alpha         TYPE zexcel_cell_column_alpha,
      lv_col_end_alpha           TYPE zexcel_cell_column_alpha,
      lv_row_start               TYPE zexcel_cell_row,
      lv_row_end                 TYPE zexcel_cell_row,
      lv_regex                   TYPE string,
      lv_range_value_1           TYPE zexcel_range_value,
      lv_range_value_2           TYPE zexcel_range_value.
*--------------------------------------------------------------------*
* #229: Set active worksheet - end data declarations
*--------------------------------------------------------------------*
    FIELD-SYMBOLS: <worksheet> TYPE t_relationship.


*--------------------------------------------------------------------*

* §1  Get the position of files related to this workbook
*         Usually this will be <root>/xl/workbook.xml
*         Thus the workbookroot will be <root>/xl/
*         The position of all related files will be given in file
*         <workbookroot>/_rels/<workbookfilename>.rels and their positions
*         be be given relative to the workbookroot

*     Following is an example how this file could be set up

*        <?xml version="1.0" encoding="UTF-8" standalone="true"?>
*        <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
*            <Relationship Target="styles.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Id="rId6"/>
*            <Relationship Target="theme/theme1.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Id="rId5"/>
*            <Relationship Target="worksheets/sheet1.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Id="rId1"/>
*            <Relationship Target="worksheets/sheet2.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Id="rId2"/>
*            <Relationship Target="worksheets/sheet3.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Id="rId3"/>
*            <Relationship Target="worksheets/sheet4.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Id="rId4"/>
*            <Relationship Target="sharedStrings.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Id="rId7"/>
*        </Relationships>
*
* §2  Load data that is relevant to the complete workbook
*     Currently supported is:
*   §2.1    Shared strings  - This holds all strings that are used in all worksheets
*   §2.2    Styles          - This holds all styles that are used in all worksheets
*   §2.3    Worksheets      - For each worksheet in the workbook one entry appears here to point to the file that holds the content of this worksheet
*   §2.4    [Themes]                - not supported
*   §2.5    [VBA (Macro)]           - supported in class Lcl_excel_reader_xlsm but should be moved here and autodetect
*   ...
*
* §3  Some information is held in the workbookfile as well
*   §3.1    Names and order of of worksheets
*   §3.2    Active worksheet
*   §3.3    Defined names
*   ...
*     Following is an example how this file could be set up

*        <?xml version="1.0" encoding="UTF-8" standalone="true"?>
*        <workbook xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
*            <fileVersion rupBuild="4506" lowestEdited="4" lastEdited="4" appName="xl"/>
*            <workbookPr defaultThemeVersion="124226"/>
*            <bookViews>
*                <workbookView activeTab="1" windowHeight="8445" windowWidth="19035" yWindow="120" xWindow="120"/>
*            </bookViews>
*            <sheets>
*                <sheet r:id="rId1" sheetId="1" name="Sheet1"/>
*                <sheet r:id="rId2" sheetId="2" name="Sheet2"/>
*                <sheet r:id="rId3" sheetId="3" name="Sheet3" state="hidden"/>
*                <sheet r:id="rId4" sheetId="4" name="Sheet4"/>
*            </sheets>
*            <definedNames/>
*            <calcPr calcId="125725"/>
*        </workbook>
*--------------------------------------------------------------------*

    CLEAR me->mt_ref_formulae.                                                                              " ins issue#284

*--------------------------------------------------------------------*
* §1  Get the position of files related to this workbook
*     Entry into this method is with the filename of the workbook
*--------------------------------------------------------------------*
    CALL FUNCTION 'TRINT_SPLIT_FILE_AND_PATH'
      EXPORTING
        full_name     = iv_workbook_full_filename
      IMPORTING
        stripped_name = lv_filename
        file_path     = lv_path.

    CONCATENATE lv_path '_rels/' lv_filename '.rels'
        INTO lv_full_filename.
    lo_rels_workbook = me->get_ixml_from_zip_archive( lv_full_filename ).

    lo_node ?= lo_rels_workbook->find_from_name_ns( name = 'Relationship' uri = namespace-relationships ). "#EC NOTEXT
    WHILE lo_node IS BOUND.

      me->fill_struct_from_attributes( EXPORTING ip_element = lo_node CHANGING cp_structure = ls_relationship ).

      CASE ls_relationship-type.

*--------------------------------------------------------------------*
*   §2.1    Shared strings  - This holds all strings that are used in all worksheets
*--------------------------------------------------------------------*
        WHEN lcv_shared_strings.
          CONCATENATE lv_path ls_relationship-target
              INTO lv_full_filename.
          me->load_shared_strings( lv_full_filename ).

*--------------------------------------------------------------------*
*   §2.3    Worksheets
*           For each worksheet in the workbook one entry appears here to point to the file that holds the content of this worksheet
*           Shared strings and styles have to be present before we can start with creating the worksheets
*           thus we only store this information for use when parsing the workbookfile for sheetinformations
*--------------------------------------------------------------------*
        WHEN lcv_worksheet.
          APPEND ls_relationship TO lt_worksheets.

*--------------------------------------------------------------------*
*   §2.2    Styles           - This holds the styles that are used in all worksheets
*--------------------------------------------------------------------*
        WHEN lcv_styles.
          CONCATENATE lv_path ls_relationship-target
              INTO lv_full_filename.
          me->load_styles( ip_path  = lv_full_filename
                           ip_excel = io_excel ).
          me->load_dxf_styles( iv_path  = lv_full_filename
                               io_excel = io_excel ).
        WHEN lcv_theme.
          CONCATENATE lv_path ls_relationship-target
              INTO lv_full_filename.
          me->load_theme(
                  EXPORTING
                    iv_path  = lv_full_filename
                    ip_excel = io_excel   " Excel creator
                    ).
        WHEN OTHERS.

      ENDCASE.

      lo_node ?= lo_node->get_next( ).

    ENDWHILE.

*--------------------------------------------------------------------*
* §3  Some information held in the workbookfile
*--------------------------------------------------------------------*
    lo_workbook = me->get_ixml_from_zip_archive( iv_workbook_full_filename ).

*--------------------------------------------------------------------*
*   §3.1    Names and order of of worksheets
*--------------------------------------------------------------------*
    lo_node           ?= lo_workbook->find_from_name_ns( name = 'sheet' uri = namespace-main ).
    lv_workbook_index  = 1.
    WHILE lo_node IS BOUND.

      me->fill_struct_from_attributes( EXPORTING
                                         ip_element   = lo_node
                                       CHANGING
                                         cp_structure = ls_sheet ).
*--------------------------------------------------------------------*
*       Create new worksheet in workbook with correct name
*--------------------------------------------------------------------*
      lv_worksheet_title = ls_sheet-name.
      IF lv_workbook_index = 1.                                               " First sheet has been added automatically by creating io_excel
        lo_worksheet = io_excel->get_active_worksheet( ).
        lo_worksheet->set_title( lv_worksheet_title ).
      ELSE.
        lo_worksheet = io_excel->add_new_worksheet( lv_worksheet_title ).
      ENDIF.
*--------------------------------------------------------------------*
* #232   - Read worksheetstate hidden/veryHidden - begin of coding
*       Set status hidden if necessary
*--------------------------------------------------------------------*
      CASE ls_sheet-state.

        WHEN lcv_worksheet_state_hidden.
          lo_worksheet->Lif_excel_sheet_properties~hidden = Lif_excel_sheet_properties=>c_hidden.

        WHEN lcv_worksheet_state_veryhidden.
          lo_worksheet->Lif_excel_sheet_properties~hidden = Lif_excel_sheet_properties=>c_veryhidden.

      ENDCASE.
*--------------------------------------------------------------------*
* #232   - Read worksheetstate hidden/veryHidden - end of coding
*--------------------------------------------------------------------*
*--------------------------------------------------------------------*
*       Load worksheetdata
*--------------------------------------------------------------------*
      READ TABLE lt_worksheets ASSIGNING <worksheet> WITH KEY id = ls_sheet-id.
      IF sy-subrc = 0.
        <worksheet>-sheetid = ls_sheet-sheetid.                                "ins #235 - repeat rows/cols - needed to identify correct sheet
        <worksheet>-localsheetid = |{ lv_workbook_index - 1 }|.
        CONCATENATE lv_path <worksheet>-target
            INTO lv_worksheet_path.
        me->load_worksheet( ip_path      = lv_worksheet_path
                            io_worksheet = lo_worksheet ).
        <worksheet>-worksheet = lo_worksheet.
      ENDIF.

      lo_node ?= lo_node->get_next( ).
      ADD 1 TO lv_workbook_index.

    ENDWHILE.
    SORT lt_worksheets BY sheetid.                                              " needed for localSheetid -referencing

*--------------------------------------------------------------------*
*   #284: Set active worksheet - Resolve referenced formulae to
*                                explicit formulae those cells
*--------------------------------------------------------------------*
    me->resolve_referenced_formulae( ).
    " ins issue#284
*--------------------------------------------------------------------*
*   #229: Set active worksheet - begin coding
*   §3.2    Active worksheet
*--------------------------------------------------------------------*
    lv_zexcel_active_worksheet = 1.                                 " First sheet = active sheet if nothing else specified.
    lo_node ?=  lo_workbook->find_from_name_ns( name = 'workbookView' uri = namespace-main ).
    IF lo_node IS BOUND.
      lv_active_sheet_string = lo_node->get_attribute( 'activeTab' ).
      TRY.
          lv_zexcel_active_worksheet = lv_active_sheet_string + 1.  " EXCEL numbers the sheets from 0 onwards --> index into worksheettable is increased by one
        CATCH cx_sy_conversion_error. "#EC NO_HANDLER    - error here --> just use the default 1st sheet
      ENDTRY.
    ENDIF.
    io_excel->set_active_sheet_index( lv_zexcel_active_worksheet ).
*--------------------------------------------------------------------*
* #229: Set active worksheet - end coding
*--------------------------------------------------------------------*


*--------------------------------------------------------------------*
*   §3.3    Defined names
*           So far I have encountered these
*             - named ranges      - sheetlocal
*             - named ranges      - workbookglobal
*             - autofilters       - sheetlocal  ( special range )
*             - repeat rows/cols  - sheetlocal ( special range )
*
*--------------------------------------------------------------------*
    lo_node ?=  lo_workbook->find_from_name_ns( name = 'definedName' uri = namespace-main ).
    WHILE lo_node IS BOUND.

      CLEAR lo_range.                                                                                       "ins issue #235 - repeat rows/cols
      me->fill_struct_from_attributes(  EXPORTING
                                        ip_element   =  lo_node
                                       CHANGING
                                         cp_structure = ls_range ).
      lv_range_value = lo_node->get_value( ).

      IF ls_range-localsheetid IS NOT INITIAL.                                                              " issue #163+
*      READ TABLE lt_worksheets ASSIGNING <worksheet> WITH KEY id = ls_range-localsheetid.                "del issue #235 - repeat rows/cols " issue #163+
*        lo_range = <worksheet>-worksheet->add_new_range( ).                                              "del issue #235 - repeat rows/cols " issue #163+
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns - begin
*--------------------------------------------------------------------*
        READ TABLE lt_worksheets ASSIGNING <worksheet> WITH KEY localsheetid = ls_range-localsheetid.
        IF sy-subrc = 0.
          CASE ls_range-name.

*--------------------------------------------------------------------*
* insert autofilters
*--------------------------------------------------------------------*
            WHEN Lcl_excel_autofilters=>c_autofilter.
              " begin Dennis Schaaf
              TRY.
                  Lcl_excel_common=>convert_range2column_a_row( EXPORTING i_range        = lv_range_value
                                                                IMPORTING e_column_start = lv_col_start_alpha
                                                                          e_column_end   = lv_col_end_alpha
                                                                          e_row_start    = ls_area-row_start
                                                                          e_row_end      = ls_area-row_end ).
                  ls_area-col_start = Lcl_excel_common=>convert_column2int( lv_col_start_alpha ).
                  ls_area-col_end   = Lcl_excel_common=>convert_column2int( lv_col_end_alpha ).
                  lo_autofilter = io_excel->add_new_autofilter( io_sheet = <worksheet>-worksheet ) .
                  lo_autofilter->set_filter_area( is_area = ls_area ).
                CATCH Lcx_excel.
                  " we expected a range but it was not usable, so just ignore it
              ENDTRY.
              " end Dennis Schaaf

*--------------------------------------------------------------------*
* repeat print rows/columns
*--------------------------------------------------------------------*
            WHEN Lif_excel_sheet_printsettings=>gcv_print_title_name.
              lo_range = <worksheet>-worksheet->add_new_range( ).
              lo_range->name = Lif_excel_sheet_printsettings=>gcv_print_title_name.
*--------------------------------------------------------------------*
* This might be a temporary solution.  Maybe ranges get be reworked
* to support areas consisting of multiple rectangles
* But for now just split the range into row and columnpart
*--------------------------------------------------------------------*
              CLEAR:lv_range_value_1,
                    lv_range_value_2.
              IF lv_range_value IS INITIAL.
* Empty --> nothing to do
              ELSE.
                IF lv_range_value(1) = `'`.  " Escaped
                  lv_regex = `^('[^']*')+![^,]*,`.
                ELSE.
                  lv_regex = `^[^!]*![^,]*,`.
                ENDIF.
* Split into two ranges if necessary
                FIND REGEX lv_regex IN lv_range_value MATCH LENGTH lv_position_temp.
                IF sy-subrc = 0 AND lv_position_temp > 0.
                  lv_range_value_2 = lv_range_value+lv_position_temp.
                  SUBTRACT 1 FROM lv_position_temp.
                  lv_range_value_1 = lv_range_value(lv_position_temp).
                ELSE.
                  lv_range_value_1 = lv_range_value.
                ENDIF.
              ENDIF.
* 1st range
              Lcl_excel_common=>convert_range2column_a_row( EXPORTING i_range            = lv_range_value_1
                                                                      i_allow_1dim_range = abap_true
                                                            IMPORTING e_column_start     = lv_col_start_alpha
                                                                      e_column_end       = lv_col_end_alpha
                                                                      e_row_start        = lv_row_start
                                                                      e_row_end          = lv_row_end ).
              IF lv_col_start_alpha IS NOT INITIAL.
                <worksheet>-worksheet->Lif_excel_sheet_printsettings~set_print_repeat_columns( iv_columns_from = lv_col_start_alpha
                                                                                      iv_columns_to   = lv_col_end_alpha ).
              ENDIF.
              IF lv_row_start IS NOT INITIAL.
                <worksheet>-worksheet->Lif_excel_sheet_printsettings~set_print_repeat_rows( iv_rows_from = lv_row_start
                                                                                   iv_rows_to   = lv_row_end ).
              ENDIF.

* 2nd range
              Lcl_excel_common=>convert_range2column_a_row( EXPORTING i_range            = lv_range_value_2
                                                                      i_allow_1dim_range = abap_true
                                                            IMPORTING e_column_start     = lv_col_start_alpha
                                                                      e_column_end       = lv_col_end_alpha
                                                                      e_row_start        = lv_row_start
                                                                      e_row_end          = lv_row_end ).
              IF lv_col_start_alpha IS NOT INITIAL.
                <worksheet>-worksheet->Lif_excel_sheet_printsettings~set_print_repeat_columns( iv_columns_from = lv_col_start_alpha
                                                                                      iv_columns_to   = lv_col_end_alpha ).
              ENDIF.
              IF lv_row_start IS NOT INITIAL.
                <worksheet>-worksheet->Lif_excel_sheet_printsettings~set_print_repeat_rows( iv_rows_from = lv_row_start
                                                                                   iv_rows_to   = lv_row_end ).
              ENDIF.

            WHEN OTHERS.

          ENDCASE.
        ENDIF.
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns - end
*--------------------------------------------------------------------*
      ELSE.                                                                                                 " issue #163+
        lo_range = io_excel->add_new_range( ).                                                              " issue #163+
      ENDIF.                                                                                                " issue #163+
*    lo_range = ip_excel->add_new_range( ).                                                               " issue #163-
      IF lo_range IS BOUND.                                                                                 "ins issue #235 - repeat rows/cols
        lo_range->name = ls_range-name.
        lo_range->set_range_value( lv_range_value ).
      ENDIF.                                                                                                "ins issue #235 - repeat rows/cols
      lo_node ?= lo_node->get_next( ).

    ENDWHILE.

  ENDMETHOD.
  METHOD load_worksheet.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   Header/footer
*
*                Please don't just delete these ToDos if they are not
*                needed but leave a comment that states this
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,
*              - ...
* changes: renaming variables to naming conventions
*          aligning code                                            (started)
*          add a list of open ToDos here
*          adding comments to explain what we are trying to achieve (started)
*--------------------------------------------------------------------*
* issue #345 - Dump on small pagemargins
*              Took the chance to modularize this very long method
*              by extracting the code that needed correction into
*              own method ( load_worksheet_pagemargins )
*--------------------------------------------------------------------*
    TYPES: BEGIN OF lty_cell,
             r TYPE string,
             t TYPE string,
             s TYPE string,
           END OF lty_cell.

    TYPES: BEGIN OF lty_column,
             min          TYPE string,
             max          TYPE string,
             width        TYPE f,
             customwidth  TYPE string,
             style        TYPE string,
             bestfit      TYPE string,
             collapsed    TYPE string,
             hidden       TYPE string,
             outlinelevel TYPE string,
           END OF lty_column.

    TYPES: BEGIN OF lty_sheetview,
             showgridlines     TYPE zexcel_show_gridlines,
             tabselected       TYPE string,
             zoomscalenormal   TYPE string,
             workbookviewid    TYPE string,
             showrowcolheaders TYPE string,
             righttoleft       TYPE string,
           END OF lty_sheetview.

    TYPES: BEGIN OF lty_mergecell,
             ref TYPE string,
           END OF lty_mergecell.

    TYPES: BEGIN OF lty_row,
             r            TYPE string,
             customheight TYPE string,
             ht           TYPE f,
             spans        TYPE string,
             thickbot     TYPE string,
             customformat TYPE string,
             thicktop     TYPE string,
             collapsed    TYPE string,
             hidden       TYPE string,
             outlinelevel TYPE string,
           END OF lty_row.

    TYPES: BEGIN OF lty_page_setup,
             id          TYPE string,
             orientation TYPE string,
             scale       TYPE string,
             fittoheight TYPE string,
             fittowidth  TYPE string,
             papersize   TYPE string,
             paperwidth  TYPE string,
             paperheight TYPE string,
           END OF lty_page_setup.

    TYPES: BEGIN OF lty_sheetformatpr,
             customheight     TYPE string,
             defaultrowheight TYPE string,
             customwidth      TYPE string,
             defaultcolwidth  TYPE string,
           END OF lty_sheetformatpr.

    TYPES: BEGIN OF lty_headerfooter,
             alignwithmargins TYPE string,
             differentoddeven TYPE string,
           END OF lty_headerfooter.

    TYPES: BEGIN OF lty_tabcolor,
             rgb   TYPE string,
             theme TYPE string,
           END OF lty_tabcolor.

    TYPES: BEGIN OF lty_datavalidation,
             type             TYPE zexcel_data_val_type,
             allowblank       TYPE flag,
             showinputmessage TYPE flag,
             showerrormessage TYPE flag,
             showdropdown     TYPE flag,
             operator         TYPE zexcel_data_val_operator,
             formula1         TYPE zexcel_validation_formula1,
             formula2         TYPE zexcel_validation_formula1,
             sqref            TYPE string,
             cell_column      TYPE zexcel_cell_column_alpha,
             cell_column_to   TYPE zexcel_cell_column_alpha,
             cell_row         TYPE zexcel_cell_row,
             cell_row_to      TYPE zexcel_cell_row,
             error            TYPE string,
             errortitle       TYPE string,
             prompt           TYPE string,
             prompttitle      TYPE string,
             errorstyle       TYPE zexcel_data_val_error_style,
           END OF lty_datavalidation.



    CONSTANTS: lc_xml_attr_true     TYPE string VALUE 'true',
               lc_xml_attr_true_int TYPE string VALUE '1',
               lc_rel_drawing       TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing',
               lc_rel_hyperlink     TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink',
               lc_rel_comments      TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments',
               lc_rel_printer       TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/printerSettings'.
    CONSTANTS lc_rel_table TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/table'.

    DATA: lo_ixml_worksheet           TYPE REF TO if_ixml_document,
          lo_ixml_cells               TYPE REF TO if_ixml_node_collection,
          lo_ixml_iterator            TYPE REF TO if_ixml_node_iterator,
          lo_ixml_iterator2           TYPE REF TO if_ixml_node_iterator,
          lo_ixml_row_elem            TYPE REF TO if_ixml_element,
          lo_ixml_cell_elem           TYPE REF TO if_ixml_element,
          ls_cell                     TYPE lty_cell,
          lv_index                    TYPE i,
          lv_index_temp               TYPE i,
          lo_ixml_value_elem          TYPE REF TO if_ixml_element,
          lo_ixml_formula_elem        TYPE REF TO if_ixml_element,
          lv_cell_value               TYPE zexcel_cell_value,
          lv_cell_formula             TYPE zexcel_cell_formula,
          lv_cell_column              TYPE zexcel_cell_column_alpha,
          lv_cell_row                 TYPE zexcel_cell_row,
          lo_excel_style              TYPE REF TO Lcl_excel_style,
          lv_style_guid               TYPE zexcel_cell_style,

          lo_ixml_imension_elem       TYPE REF TO if_ixml_element, "#+234
          lv_dimension_range          TYPE string,  "#+234

          lo_ixml_sheetview_elem      TYPE REF TO if_ixml_element,
          ls_sheetview                TYPE lty_sheetview,
          lo_ixml_pane_elem           TYPE REF TO if_ixml_element,
          ls_excel_pane               TYPE zexcel_pane,
          lv_pane_cell_row            TYPE zexcel_cell_row,
          lv_pane_cell_col_a          TYPE zexcel_cell_column_alpha,
          lv_pane_cell_col            TYPE zexcel_cell_column,

          lo_ixml_mergecells          TYPE REF TO if_ixml_node_collection,
          lo_ixml_mergecell_elem      TYPE REF TO if_ixml_element,
          ls_mergecell                TYPE lty_mergecell,
          lv_merge_column_start       TYPE zexcel_cell_column_alpha,
          lv_merge_column_end         TYPE zexcel_cell_column_alpha,
          lv_merge_row_start          TYPE zexcel_cell_row,
          lv_merge_row_end            TYPE zexcel_cell_row,

          lo_ixml_sheetformatpr_elem  TYPE REF TO if_ixml_element,
          ls_sheetformatpr            TYPE lty_sheetformatpr,
          lv_height                   TYPE f,

          lo_ixml_headerfooter_elem   TYPE REF TO if_ixml_element,
          ls_headerfooter             TYPE lty_headerfooter,
          ls_odd_header               TYPE zexcel_s_worksheet_head_foot,
          ls_odd_footer               TYPE zexcel_s_worksheet_head_foot,
          ls_even_header              TYPE zexcel_s_worksheet_head_foot,
          ls_even_footer              TYPE zexcel_s_worksheet_head_foot,
          lo_ixml_hf_value_elem       TYPE REF TO if_ixml_element,

          lo_ixml_pagesetup_elem      TYPE REF TO if_ixml_element,
          lo_ixml_sheetpr             TYPE REF TO if_ixml_element,
          lv_fit_to_page              TYPE string,
          ls_pagesetup                TYPE lty_page_setup,

          lo_ixml_columns             TYPE REF TO if_ixml_node_collection,
          lo_ixml_column_elem         TYPE REF TO if_ixml_element,
          ls_column                   TYPE lty_column,
          lv_column_alpha             TYPE zexcel_cell_column_alpha,
          lo_column                   TYPE REF TO Lcl_excel_column,
          lv_outline_level            TYPE int4,

          lo_ixml_tabcolor            TYPE REF TO if_ixml_element,
          ls_tabcolor                 TYPE lty_tabcolor,
          ls_excel_s_tabcolor         TYPE zexcel_s_tabcolor,

          lo_ixml_rows                TYPE REF TO if_ixml_node_collection,
          ls_row                      TYPE lty_row,
          lv_max_col                  TYPE i,     "for use with SPANS element
*              lv_min_col                     TYPE i,     "for use with SPANS element                    " not in use currently
          lv_max_col_s                TYPE char10,     "for use with SPANS element
          lv_min_col_s                TYPE char10,     "for use with SPANS element
          lo_row                      TYPE REF TO Lcl_excel_row,
*---    End of current code aligning -------------------------------------------------------------------

          lv_path                     TYPE string,
          lo_ixml_node                TYPE REF TO if_ixml_element,
          ls_relationship             TYPE t_relationship,
          lo_ixml_rels_worksheet      TYPE REF TO if_ixml_document,
          lv_rels_worksheet_path      TYPE string,
          lv_stripped_name            TYPE chkfile,
          lv_dirname                  TYPE string,

          lt_external_hyperlinks      TYPE gtt_external_hyperlinks,
          ls_external_hyperlink       LIKE LINE OF lt_external_hyperlinks,

          lo_ixml_datavalidations     TYPE REF TO if_ixml_node_collection,
          lo_ixml_datavalidation_elem TYPE REF TO if_ixml_element,
          ls_datavalidation           TYPE lty_datavalidation,
          lo_data_validation          TYPE REF TO Lcl_excel_data_validation,
          lv_datavalidation_range     TYPE string,
          lt_datavalidation_range     TYPE TABLE OF string,
          lt_rtf                      TYPE zexcel_t_rtf,
          ex                          TYPE REF TO cx_root.
    DATA lt_tables TYPE t_tables.
    DATA ls_table TYPE t_table.

    FIELD-SYMBOLS:
      <ls_shared_string> TYPE t_shared_string.

*--------------------------------------------------------------------*
* §2  We need to read the the file "\\_rels\.rels" because it tells
*     us where in this folder structure the data for the workbook
*     is located in the xlsx zip-archive
*
*     The xlsx Zip-archive has generally the following folder structure:
*       <root> |
*              |-->  _rels
*              |-->  doc_Props
*              |-->  xl |
*                       |-->  _rels
*                       |-->  theme
*                       |-->  worksheets
*--------------------------------------------------------------------*

    " Read Workbook Relationships
    CALL FUNCTION 'TRINT_SPLIT_FILE_AND_PATH'
      EXPORTING
        full_name     = ip_path
      IMPORTING
        stripped_name = lv_stripped_name
        file_path     = lv_dirname.
    CONCATENATE lv_dirname '_rels/' lv_stripped_name '.rels'
      INTO lv_rels_worksheet_path.
    TRY.                                                                          " +#222  _rels/xxx.rels might not be present.  If not found there can be no drawings --> just ignore this section
        lo_ixml_rels_worksheet = me->get_ixml_from_zip_archive( lv_rels_worksheet_path ).
        lo_ixml_node ?= lo_ixml_rels_worksheet->find_from_name_ns( name = 'Relationship' uri = namespace-relationships ).
      CATCH Lcx_excel.                            "#EC NO_HANDLER +#222
        " +#222   No errorhandling necessary - node will be unbound if error occurs
    ENDTRY.                                                   " +#222
    WHILE lo_ixml_node IS BOUND.
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_node
                                   CHANGING
                                     cp_structure = ls_relationship ).
      CONCATENATE lv_dirname ls_relationship-target INTO lv_path.
      lv_path = resolve_path( lv_path ).

      CASE ls_relationship-type.
        WHEN lc_rel_drawing.
          " Read Drawings
* Issue # 339       Not all drawings are in the path mentioned below.
*                   Some Excel elements like textfields (which we don't support ) have a drawing-part in the relationsships
*                   but no "xl/drawings/_rels/drawing____.xml.rels" part.
*                   Since we don't support these there is no need to read them.  Catching exceptions thrown
*                   in the "load_worksheet_drawing" shouldn't lead to an abortion of the reading
          TRY.
              me->load_worksheet_drawing( ip_path      = lv_path
                                        io_worksheet = io_worksheet ).
            CATCH Lcx_excel. "--> then ignore it
          ENDTRY.

        WHEN lc_rel_printer.
          " Read Printer settings

        WHEN lc_rel_hyperlink.
          MOVE-CORRESPONDING ls_relationship TO ls_external_hyperlink.
          INSERT ls_external_hyperlink INTO TABLE lt_external_hyperlinks.

        WHEN lc_rel_comments.
          TRY.
              me->load_comments( ip_path      = lv_path
                                 io_worksheet = io_worksheet ).
            CATCH Lcx_excel.
          ENDTRY.

        WHEN lc_rel_table.
          MOVE-CORRESPONDING ls_relationship TO ls_table.
          INSERT ls_table INTO TABLE lt_tables.

        WHEN OTHERS.
      ENDCASE.

      lo_ixml_node ?= lo_ixml_node->get_next( ).
    ENDWHILE.


    lo_ixml_worksheet = me->get_ixml_from_zip_archive( ip_path ).


    lo_ixml_tabcolor ?= lo_ixml_worksheet->find_from_name_ns( name = 'tabColor' uri = namespace-main ).
    IF lo_ixml_tabcolor IS BOUND.
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_tabcolor
                                  CHANGING
                                    cp_structure = ls_tabcolor ).
* Theme not supported yet
      IF ls_tabcolor-rgb IS NOT INITIAL.
        ls_excel_s_tabcolor-rgb = ls_tabcolor-rgb.
        io_worksheet->set_tabcolor( ls_excel_s_tabcolor ).
      ENDIF.
    ENDIF.

    " Read tables (must be done before loading sheet contents)
    TRY.
        me->load_worksheet_tables( io_ixml_worksheet = lo_ixml_worksheet
                                   io_worksheet      = io_worksheet
                                   iv_dirname        = lv_dirname
                                   it_tables         = lt_tables ).
      CATCH Lcx_excel. " Ignore reading errors - pass everything we were able to identify
    ENDTRY.

    " Sheet contents
    lo_ixml_rows = lo_ixml_worksheet->get_elements_by_tag_name_ns( name = 'row' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_rows->create_iterator( ).
    lo_ixml_row_elem ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml_row_elem IS BOUND.

      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_row_elem
                                   CHANGING
                                     cp_structure = ls_row ).
      SPLIT ls_row-spans AT ':' INTO lv_min_col_s lv_max_col_s.
      lv_index = lv_max_col_s.
      IF lv_index > lv_max_col.
        lv_max_col = lv_index.
      ENDIF.
      lv_cell_row = ls_row-r.
      lo_row = io_worksheet->get_row( lv_cell_row ).
      IF ls_row-customheight = '1'.
        lo_row->set_row_height( ip_row_height = ls_row-ht ip_custom_height = abap_true ).
      ELSEIF ls_row-ht > 0.
        lo_row->set_row_height( ip_row_height = ls_row-ht ip_custom_height = abap_false ).
      ENDIF.

      IF   ls_row-collapsed = lc_xml_attr_true
        OR ls_row-collapsed = lc_xml_attr_true_int.
        lo_row->set_collapsed( abap_true ).
      ENDIF.

      IF   ls_row-hidden = lc_xml_attr_true
        OR ls_row-hidden = lc_xml_attr_true_int.
        lo_row->set_visible( abap_false ).
      ENDIF.

      IF ls_row-outlinelevel > ''.
*        outline_level = condense( row-outlineLevel ).  "For basis 7.02 and higher
        CONDENSE  ls_row-outlinelevel.
        lv_outline_level = ls_row-outlinelevel.
        IF lv_outline_level > 0.
          lo_row->set_outline_level( lv_outline_level ).
        ENDIF.
      ENDIF.

      lo_ixml_cells = lo_ixml_row_elem->get_elements_by_tag_name_ns( name = 'c' uri = namespace-main ).
      lo_ixml_iterator2 = lo_ixml_cells->create_iterator( ).
      lo_ixml_cell_elem ?= lo_ixml_iterator2->get_next( ).
      WHILE lo_ixml_cell_elem IS BOUND.
        CLEAR: lv_cell_value,
               lv_cell_formula,
               lv_style_guid.

        fill_struct_from_attributes( EXPORTING ip_element = lo_ixml_cell_elem CHANGING cp_structure = ls_cell ).

        lo_ixml_value_elem = lo_ixml_cell_elem->find_from_name_ns( name = 'v' uri = namespace-main ).

        CASE ls_cell-t.
          WHEN 's'. " String values are stored as index in shared string table
            IF lo_ixml_value_elem IS BOUND.
              lv_index = lo_ixml_value_elem->get_value( ) + 1.
              READ TABLE shared_strings ASSIGNING <ls_shared_string> INDEX lv_index.
              IF sy-subrc = 0.
                lv_cell_value = <ls_shared_string>-value.
                lt_rtf = <ls_shared_string>-rtf.
              ENDIF.
            ENDIF.
          WHEN 'inlineStr'. " inlineStr values are kept in special node
            lo_ixml_value_elem = lo_ixml_cell_elem->find_from_name_ns( name = 'is' uri = namespace-main ).
            IF lo_ixml_value_elem IS BOUND.
              lv_cell_value = lo_ixml_value_elem->get_value( ).
            ENDIF.
          WHEN OTHERS. "other types are stored directly
            IF lo_ixml_value_elem IS BOUND.
              lv_cell_value = lo_ixml_value_elem->get_value( ).
            ENDIF.
        ENDCASE.

        CLEAR lv_style_guid.
        "read style based on index
        IF ls_cell-s IS NOT INITIAL.
          lv_index = ls_cell-s + 1.
          READ TABLE styles INTO lo_excel_style INDEX lv_index.
          IF sy-subrc = 0.
            lv_style_guid = lo_excel_style->get_guid( ).
          ENDIF.
        ENDIF.

        lo_ixml_formula_elem = lo_ixml_cell_elem->find_from_name_ns( name = 'f' uri = namespace-main ).
        IF lo_ixml_formula_elem IS BOUND.
          lv_cell_formula = lo_ixml_formula_elem->get_value( ).
*--------------------------------------------------------------------*
* Begin of insertion issue#284 - Copied formulae not
*--------------------------------------------------------------------*
          DATA: BEGIN OF ls_formula_attributes,
                  ref TYPE string,
                  si  TYPE i,
                  t   TYPE string,
                END OF ls_formula_attributes,
                ls_ref_formula TYPE ty_ref_formulae.

          fill_struct_from_attributes( EXPORTING ip_element = lo_ixml_formula_elem CHANGING cp_structure = ls_formula_attributes ).
          IF ls_formula_attributes-t = 'shared'.
            Lcl_excel_common=>convert_columnrow2column_a_row( EXPORTING
                                                                i_columnrow = ls_cell-r
                                                              IMPORTING
                                                                e_column    = lv_cell_column
                                                                e_row       = lv_cell_row ).

            TRY.
                CLEAR ls_ref_formula.
                ls_ref_formula-sheet     = io_worksheet.
                ls_ref_formula-row       = lv_cell_row.
                ls_ref_formula-column    = Lcl_excel_common=>convert_column2int( lv_cell_column ).
                ls_ref_formula-si        = ls_formula_attributes-si.
                ls_ref_formula-ref       = ls_formula_attributes-ref.
                ls_ref_formula-formula   = lv_cell_formula.
                INSERT ls_ref_formula INTO TABLE me->mt_ref_formulae.
              CATCH cx_root INTO ex.
                RAISE EXCEPTION TYPE Lcx_excel
                  EXPORTING
                    previous = ex.
            ENDTRY.
          ENDIF.
*--------------------------------------------------------------------*
* End of insertion issue#284 - Copied formulae not
*--------------------------------------------------------------------*
        ENDIF.

        IF   lv_cell_value    IS NOT INITIAL
          OR lv_cell_formula  IS NOT INITIAL
          OR lv_style_guid    IS NOT INITIAL.
          Lcl_excel_common=>convert_columnrow2column_a_row( EXPORTING
                                                              i_columnrow = ls_cell-r
                                                            IMPORTING
                                                              e_column    = lv_cell_column
                                                              e_row       = lv_cell_row ).
          io_worksheet->set_cell( ip_column     = lv_cell_column  " cell_elem Column
                                  ip_row        = lv_cell_row     " cell_elem row_elem
                                  ip_value      = lv_cell_value   " cell_elem Value
                                  ip_formula    = lv_cell_formula
                                  ip_data_type  = ls_cell-t
                                  ip_style      = lv_style_guid
                                  it_rtf        = lt_rtf ).
        ENDIF.
        lo_ixml_cell_elem ?= lo_ixml_iterator2->get_next( ).
      ENDWHILE.
      lo_ixml_row_elem ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.

*--------------------------------------------------------------------*
*#234 - column width not read correctly - begin of coding
*       reason - libre office doesn't use SPAN in row - definitions
*--------------------------------------------------------------------*
    IF lv_max_col = 0.
      lo_ixml_imension_elem = lo_ixml_worksheet->find_from_name_ns( name = 'dimension' uri = namespace-main ).
      IF lo_ixml_imension_elem IS BOUND.
        lv_dimension_range = lo_ixml_imension_elem->get_attribute( 'ref' ).
        IF lv_dimension_range CS ':'.
          REPLACE REGEX '\D+\d+:(\D+)\d+' IN lv_dimension_range WITH '$1'.  " Get max column
        ELSE.
          REPLACE REGEX '(\D+)\d+' IN lv_dimension_range WITH '$1'.  " Get max column
        ENDIF.
        lv_max_col = Lcl_excel_common=>convert_column2int( lv_dimension_range ).
      ENDIF.
    ENDIF.
*--------------------------------------------------------------------*
*#234 - column width not read correctly - end of coding
*--------------------------------------------------------------------*

    "Get the customized column width
    lo_ixml_columns = lo_ixml_worksheet->get_elements_by_tag_name_ns( name = 'col' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_columns->create_iterator( ).
    lo_ixml_column_elem ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml_column_elem IS BOUND.
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_column_elem
                                   CHANGING
                                     cp_structure = ls_column ).
      lo_ixml_column_elem ?= lo_ixml_iterator->get_next( ).
      IF   ls_column-customwidth   = lc_xml_attr_true
        OR ls_column-customwidth   = lc_xml_attr_true_int
        OR ls_column-bestfit       = lc_xml_attr_true
        OR ls_column-bestfit       = lc_xml_attr_true_int
        OR ls_column-collapsed     = lc_xml_attr_true
        OR ls_column-collapsed     = lc_xml_attr_true_int
        OR ls_column-hidden        = lc_xml_attr_true
        OR ls_column-hidden        = lc_xml_attr_true_int
        OR ls_column-outlinelevel  > ''
        OR ls_column-style         > ''.
        lv_index = ls_column-min.
        WHILE lv_index <= ls_column-max AND lv_index <= lv_max_col.

          lv_column_alpha = Lcl_excel_common=>convert_column2alpha( lv_index ).
          lo_column =  io_worksheet->get_column( lv_column_alpha ).

          IF   ls_column-customwidth = lc_xml_attr_true
            OR ls_column-customwidth = lc_xml_attr_true_int
            OR ls_column-width       IS NOT INITIAL.          "+#234
            lo_column->set_width( ls_column-width ).
          ENDIF.

          IF   ls_column-bestfit = lc_xml_attr_true
            OR ls_column-bestfit = lc_xml_attr_true_int.
            lo_column->set_auto_size( abap_true ).
          ENDIF.

          IF   ls_column-collapsed = lc_xml_attr_true
            OR ls_column-collapsed = lc_xml_attr_true_int.
            lo_column->set_collapsed( abap_true ).
          ENDIF.

          IF   ls_column-hidden = lc_xml_attr_true
            OR ls_column-hidden = lc_xml_attr_true_int.
            lo_column->set_visible( abap_false ).
          ENDIF.

          IF ls_column-outlinelevel > ''.
            CONDENSE ls_column-outlinelevel.
            lv_outline_level = ls_column-outlinelevel.
            IF lv_outline_level > 0.
              lo_column->set_outline_level( lv_outline_level ).
            ENDIF.
          ENDIF.

          IF ls_column-style > ''.
            lv_index_temp = ls_column-style + 1.
            READ TABLE styles INTO lo_excel_style INDEX lv_index_temp.
            DATA: dummy_zexcel_cell_style TYPE zexcel_cell_style.
            dummy_zexcel_cell_style = lo_excel_style->get_guid( ).
            lo_column->set_column_style_by_guid( dummy_zexcel_cell_style ).
          ENDIF.

          ADD 1 TO lv_index.
        ENDWHILE.
      ENDIF.

* issue #367 - hide columns from
      IF ls_column-max = Lcl_excel_common=>c_excel_sheet_max_col.     " Max = very right column
        IF ls_column-hidden = 1     " all hidden
          AND ls_column-min > 0.
          io_worksheet->Lif_excel_sheet_properties~hide_columns_from = Lcl_excel_common=>convert_column2alpha( ls_column-min ).
        ELSEIF ls_column-style > ''.
          lv_index_temp = ls_column-style + 1.
          READ TABLE styles INTO lo_excel_style INDEX lv_index_temp.
          dummy_zexcel_cell_style = lo_excel_style->get_guid( ).
* Set style for remaining columns
          io_worksheet->Lif_excel_sheet_properties~set_style( dummy_zexcel_cell_style ).
        ENDIF.
      ENDIF.


    ENDWHILE.

    "Now we need to get information from the sheetView node
    lo_ixml_sheetview_elem = lo_ixml_worksheet->find_from_name_ns( name = 'sheetView' uri = namespace-main ).
    fill_struct_from_attributes( EXPORTING ip_element = lo_ixml_sheetview_elem CHANGING cp_structure = ls_sheetview ).
    IF ls_sheetview-showgridlines IS INITIAL OR
       ls_sheetview-showgridlines = lc_xml_attr_true OR
       ls_sheetview-showgridlines = lc_xml_attr_true_int.
      "If the attribute is not specified or set to true, we will show grid lines
      ls_sheetview-showgridlines = abap_true.
    ELSE.
      ls_sheetview-showgridlines = abap_false.
    ENDIF.
    io_worksheet->set_show_gridlines( ls_sheetview-showgridlines ).
    IF ls_sheetview-righttoleft = lc_xml_attr_true
        OR ls_sheetview-righttoleft = lc_xml_attr_true_int.
      io_worksheet->Lif_excel_sheet_properties~set_right_to_left( abap_true ).
    ENDIF.


    "Add merge cell information
    lo_ixml_mergecells = lo_ixml_worksheet->get_elements_by_tag_name_ns( name = 'mergeCell' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_mergecells->create_iterator( ).
    lo_ixml_mergecell_elem ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml_mergecell_elem IS BOUND.
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_mergecell_elem
                                   CHANGING
                                     cp_structure = ls_mergecell ).
      Lcl_excel_common=>convert_range2column_a_row( EXPORTING
                                                      i_range = ls_mergecell-ref
                                                    IMPORTING
                                                      e_column_start = lv_merge_column_start
                                                      e_column_end   = lv_merge_column_end
                                                      e_row_start    = lv_merge_row_start
                                                      e_row_end      = lv_merge_row_end ).
      lo_ixml_mergecell_elem ?= lo_ixml_iterator->get_next( ).
      io_worksheet->set_merge( EXPORTING
                                 ip_column_start = lv_merge_column_start
                                 ip_column_end   = lv_merge_column_end
                                 ip_row          = lv_merge_row_start
                                 ip_row_to       = lv_merge_row_end ).
    ENDWHILE.

    " read sheet format properties
    lo_ixml_sheetformatpr_elem = lo_ixml_worksheet->find_from_name_ns( name = 'sheetFormatPr' uri = namespace-main ).
    IF lo_ixml_sheetformatpr_elem IS NOT INITIAL.
      fill_struct_from_attributes( EXPORTING ip_element = lo_ixml_sheetformatpr_elem CHANGING cp_structure = ls_sheetformatpr ).
      IF ls_sheetformatpr-customheight = '1'.
        lv_height = ls_sheetformatpr-defaultrowheight.
        lo_row = io_worksheet->get_default_row( ).
        lo_row->set_row_height( lv_height ).
      ENDIF.

      " TODO...  column
    ENDIF.

    " Read in page margins
    me->load_worksheet_pagemargins( EXPORTING
                                      io_ixml_worksheet = lo_ixml_worksheet
                                      io_worksheet      = io_worksheet ).

* FitToPage
    lo_ixml_sheetpr ?=  lo_ixml_worksheet->find_from_name_ns( name = 'pageSetUpPr' uri = namespace-main ).
    IF lo_ixml_sheetpr IS BOUND.

      lv_fit_to_page = lo_ixml_sheetpr->get_attribute_ns( 'fitToPage' ).
      IF lv_fit_to_page IS NOT INITIAL.
        io_worksheet->sheet_setup->fit_to_page = 'X'.
      ENDIF.
    ENDIF.
    " Read in page setup
    lo_ixml_pagesetup_elem = lo_ixml_worksheet->find_from_name_ns( name = 'pageSetup' uri = namespace-main ).
    IF lo_ixml_pagesetup_elem IS NOT INITIAL.
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_pagesetup_elem
                                   CHANGING
                                     cp_structure = ls_pagesetup ).
      io_worksheet->sheet_setup->orientation = ls_pagesetup-orientation.
      io_worksheet->sheet_setup->scale = ls_pagesetup-scale.
      io_worksheet->sheet_setup->paper_size = ls_pagesetup-papersize.
      io_worksheet->sheet_setup->paper_height = ls_pagesetup-paperheight.
      io_worksheet->sheet_setup->paper_width = ls_pagesetup-paperwidth.
      IF io_worksheet->sheet_setup->fit_to_page = 'X'.
        IF ls_pagesetup-fittowidth IS NOT INITIAL.
          io_worksheet->sheet_setup->fit_to_width = ls_pagesetup-fittowidth.
        ELSE.
          io_worksheet->sheet_setup->fit_to_width = 1.  " Default if not given - Excel doesn't write this to xml
        ENDIF.
        IF ls_pagesetup-fittoheight IS NOT INITIAL.
          io_worksheet->sheet_setup->fit_to_height = ls_pagesetup-fittoheight.
        ELSE.
          io_worksheet->sheet_setup->fit_to_height = 1. " Default if not given - Excel doesn't write this to xml
        ENDIF.
      ENDIF.
    ENDIF.



    " Read header footer
    lo_ixml_headerfooter_elem = lo_ixml_worksheet->find_from_name_ns( name = 'headerFooter' uri = namespace-main ).
    IF lo_ixml_headerfooter_elem IS NOT INITIAL.
      fill_struct_from_attributes( EXPORTING ip_element = lo_ixml_headerfooter_elem CHANGING cp_structure = ls_headerfooter ).
      io_worksheet->sheet_setup->diff_oddeven_headerfooter = ls_headerfooter-differentoddeven.

      lo_ixml_hf_value_elem = lo_ixml_headerfooter_elem->find_from_name_ns( name = 'oddFooter' uri = namespace-main ).
      IF lo_ixml_hf_value_elem IS NOT INITIAL.
        ls_odd_footer-left_value = lo_ixml_hf_value_elem->get_value( ).
      ENDIF.

      lo_ixml_hf_value_elem = lo_ixml_headerfooter_elem->find_from_name_ns( name = 'oddHeader' uri = namespace-main ).
      IF lo_ixml_hf_value_elem IS NOT INITIAL.
        ls_odd_header-left_value = lo_ixml_hf_value_elem->get_value( ).
      ENDIF.

      lo_ixml_hf_value_elem = lo_ixml_headerfooter_elem->find_from_name_ns( name = 'evenFooter' uri = namespace-main ).
      IF lo_ixml_hf_value_elem IS NOT INITIAL.
        ls_even_footer-left_value = lo_ixml_hf_value_elem->get_value( ).
      ENDIF.

      lo_ixml_hf_value_elem = lo_ixml_headerfooter_elem->find_from_name_ns( name = 'evenHeader' uri = namespace-main ).
      IF lo_ixml_hf_value_elem IS NOT INITIAL.
        ls_even_header-left_value = lo_ixml_hf_value_elem->get_value( ).
      ENDIF.

*        2do§1   Header/footer
      " TODO.. get the rest.

      io_worksheet->sheet_setup->set_header_footer( ip_odd_header   = ls_odd_header
                                                    ip_odd_footer   = ls_odd_footer
                                                    ip_even_header  = ls_even_header
                                                    ip_even_footer  = ls_even_footer ).

    ENDIF.

    " Start fix 194 Read attributes HIDDEN, OUTLINELEVEL, COLLAPSED in LCL_EXCEL_READER_2007
    " Read pane
    lo_ixml_pane_elem = lo_ixml_sheetview_elem->find_from_name_ns( name = 'pane' uri = namespace-main ).
    IF lo_ixml_pane_elem IS BOUND.
      fill_struct_from_attributes( EXPORTING ip_element = lo_ixml_pane_elem CHANGING cp_structure = ls_excel_pane ).
      " Issue #194
      " Replace REGEX with method from the common class
      Lcl_excel_common=>convert_columnrow2column_a_row( EXPORTING
                                                          i_columnrow = ls_excel_pane-topleftcell
                                                        IMPORTING
                                                          e_column    = lv_pane_cell_col_a    " Cell Column
                                                          e_row       = lv_pane_cell_row ).   " Natural number
      lv_pane_cell_col = Lcl_excel_common=>convert_column2int( lv_pane_cell_col_a ).
      SUBTRACT 1 FROM: lv_pane_cell_col,
                       lv_pane_cell_row.
      IF    lv_pane_cell_col > 0
        AND lv_pane_cell_row > 0.
        io_worksheet->freeze_panes( ip_num_rows    = lv_pane_cell_row
                                    ip_num_columns = lv_pane_cell_col ).
      ELSEIF lv_pane_cell_row > 0.
        io_worksheet->freeze_panes( ip_num_rows    = lv_pane_cell_row ).
      ELSE.
        io_worksheet->freeze_panes( ip_num_columns = lv_pane_cell_col ).
      ENDIF.
    ENDIF.
    " End fix 194 Read attributes HIDDEN, OUTLINELEVEL, COLLAPSED in LCL_EXCEL_READER_2007

    " Start fix 276 Read data validations
    lo_ixml_datavalidations = lo_ixml_worksheet->get_elements_by_tag_name_ns( name = 'dataValidation' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_datavalidations->create_iterator( ).
    lo_ixml_datavalidation_elem  ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml_datavalidation_elem  IS BOUND.
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_datavalidation_elem
                                   CHANGING
                                     cp_structure = ls_datavalidation ).
      CLEAR lo_ixml_formula_elem.
      lo_ixml_formula_elem = lo_ixml_datavalidation_elem->find_from_name_ns( name = 'formula1' uri = namespace-main ).
      IF lo_ixml_formula_elem IS BOUND.
        ls_datavalidation-formula1 = lo_ixml_formula_elem->get_value( ).
      ENDIF.
      CLEAR lo_ixml_formula_elem.
      lo_ixml_formula_elem = lo_ixml_datavalidation_elem->find_from_name_ns( name = 'formula2' uri = namespace-main ).
      IF lo_ixml_formula_elem IS BOUND.
        ls_datavalidation-formula2 = lo_ixml_formula_elem->get_value( ).
      ENDIF.
      SPLIT ls_datavalidation-sqref AT space INTO TABLE lt_datavalidation_range.
      LOOP AT lt_datavalidation_range INTO lv_datavalidation_range.
        Lcl_excel_common=>convert_range2column_a_row( EXPORTING
                                                        i_range = lv_datavalidation_range
                                                      IMPORTING
                                                        e_column_start = ls_datavalidation-cell_column
                                                        e_column_end   = ls_datavalidation-cell_column_to
                                                        e_row_start    = ls_datavalidation-cell_row
                                                        e_row_end      = ls_datavalidation-cell_row_to ).
        lo_data_validation                   = io_worksheet->add_new_data_validation( ).
        lo_data_validation->type             = ls_datavalidation-type.
        lo_data_validation->allowblank       = ls_datavalidation-allowblank.
        IF ls_datavalidation-showinputmessage IS INITIAL.
          lo_data_validation->showinputmessage = abap_false.
        ELSE.
          lo_data_validation->showinputmessage = abap_true.
        ENDIF.
        IF ls_datavalidation-showerrormessage IS INITIAL.
          lo_data_validation->showerrormessage = abap_false.
        ELSE.
          lo_data_validation->showerrormessage = abap_true.
        ENDIF.
        IF ls_datavalidation-showdropdown IS INITIAL.
          lo_data_validation->showdropdown = abap_false.
        ELSE.
          lo_data_validation->showdropdown = abap_true.
        ENDIF.
        lo_data_validation->operator         = ls_datavalidation-operator.
        lo_data_validation->formula1         = ls_datavalidation-formula1.
        lo_data_validation->formula2         = ls_datavalidation-formula2.
        lo_data_validation->prompttitle      = ls_datavalidation-prompttitle.
        lo_data_validation->prompt           = ls_datavalidation-prompt.
        lo_data_validation->errortitle       = ls_datavalidation-errortitle.
        lo_data_validation->error            = ls_datavalidation-error.
        lo_data_validation->errorstyle       = ls_datavalidation-errorstyle.
        lo_data_validation->cell_row         = ls_datavalidation-cell_row.
        lo_data_validation->cell_row_to      = ls_datavalidation-cell_row_to.
        lo_data_validation->cell_column      = ls_datavalidation-cell_column.
        lo_data_validation->cell_column_to   = ls_datavalidation-cell_column_to.
      ENDLOOP.
      lo_ixml_datavalidation_elem ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.
    " End fix 276 Read data validations

    " Read hyperlinks
    TRY.
        me->load_worksheet_hyperlinks( io_ixml_worksheet      = lo_ixml_worksheet
                                       io_worksheet           = io_worksheet
                                       it_external_hyperlinks = lt_external_hyperlinks ).
      CATCH Lcx_excel. " Ignore Hyperlink reading errors - pass everything we were able to identify
    ENDTRY.

    TRY.
        me->fill_row_outlines( io_worksheet           = io_worksheet ).
      CATCH Lcx_excel. " Ignore Hyperlink reading errors - pass everything we were able to identify
    ENDTRY.

    " Issue #366 - conditional formatting
    TRY.
        me->load_worksheet_cond_format( io_ixml_worksheet      = lo_ixml_worksheet
                                        io_worksheet           = io_worksheet ).
      CATCH Lcx_excel. " Ignore Hyperlink reading errors - pass everything we were able to identify
    ENDTRY.

    " Issue #377 - pagebreaks
    TRY.
        me->load_worksheet_pagebreaks( io_ixml_worksheet      = lo_ixml_worksheet
                                       io_worksheet           = io_worksheet ).
      CATCH Lcx_excel. " Ignore pagebreak reading errors - pass everything we were able to identify
    ENDTRY.

    TRY.
        me->load_worksheet_autofilter( io_ixml_worksheet      = lo_ixml_worksheet
                                       io_worksheet           = io_worksheet ).
      CATCH Lcx_excel. " Ignore autofilter reading errors - pass everything we were able to identify
    ENDTRY.

    TRY.
        me->load_worksheet_ignored_errors( io_ixml_worksheet      = lo_ixml_worksheet
                                           io_worksheet           = io_worksheet ).
      CATCH Lcx_excel. " Ignore "ignoredErrors" reading errors - pass everything we were able to identify
    ENDTRY.

  ENDMETHOD.
  METHOD load_worksheet_autofilter.

    TYPES: BEGIN OF lty_autofilter,
             ref TYPE string,
           END OF lty_autofilter.

    DATA: lo_ixml_autofilter_elem    TYPE REF TO if_ixml_element,
          lv_ref                     TYPE string,
          lo_ixml_filter_column_coll TYPE REF TO if_ixml_node_collection,
          lo_ixml_filter_column_iter TYPE REF TO if_ixml_node_iterator,
          lo_ixml_filter_column      TYPE REF TO if_ixml_element,
          lv_col_id                  TYPE i,
          lv_column                  TYPE zexcel_cell_column,
          lo_ixml_filters_coll       TYPE REF TO if_ixml_node_collection,
          lo_ixml_filters_iter       TYPE REF TO if_ixml_node_iterator,
          lo_ixml_filters            TYPE REF TO if_ixml_element,
          lo_ixml_filter_coll        TYPE REF TO if_ixml_node_collection,
          lo_ixml_filter_iter        TYPE REF TO if_ixml_node_iterator,
          lo_ixml_filter             TYPE REF TO if_ixml_element,
          lv_val                     TYPE string,
          lo_autofilters             TYPE REF TO Lcl_excel_autofilters,
          lo_autofilter              TYPE REF TO Lcl_excel_autofilter.

    lo_autofilters = io_worksheet->excel->get_autofilters_reference( ).

    lo_ixml_autofilter_elem = io_ixml_worksheet->find_from_name_ns( name = 'autoFilter' uri = namespace-main ).
    IF lo_ixml_autofilter_elem IS BOUND.
      lv_ref = lo_ixml_autofilter_elem->get_attribute_ns( 'ref' ).

      lo_ixml_filter_column_coll = lo_ixml_autofilter_elem->get_elements_by_tag_name_ns( name = 'filterColumn' uri = namespace-main ).
      lo_ixml_filter_column_iter = lo_ixml_filter_column_coll->create_iterator( ).
      lo_ixml_filter_column ?= lo_ixml_filter_column_iter->get_next( ).
      WHILE lo_ixml_filter_column IS BOUND.
        lv_col_id = lo_ixml_filter_column->get_attribute_ns( 'colId' ).
        lv_column = lv_col_id + 1.

        lo_ixml_filters_coll = lo_ixml_filter_column->get_elements_by_tag_name_ns( name = 'filters' uri = namespace-main ).
        lo_ixml_filters_iter = lo_ixml_filters_coll->create_iterator( ).
        lo_ixml_filters ?= lo_ixml_filters_iter->get_next( ).
        WHILE lo_ixml_filters IS BOUND.

          lo_ixml_filter_coll = lo_ixml_filter_column->get_elements_by_tag_name_ns( name = 'filter' uri = namespace-main ).
          lo_ixml_filter_iter = lo_ixml_filter_coll->create_iterator( ).
          lo_ixml_filter ?= lo_ixml_filter_iter->get_next( ).
          WHILE lo_ixml_filter IS BOUND.
            lv_val = lo_ixml_filter->get_attribute_ns( 'val' ).

            lo_autofilter = lo_autofilters->get( io_worksheet = io_worksheet ).
            IF lo_autofilter IS NOT BOUND.
              lo_autofilter = lo_autofilters->add( io_sheet = io_worksheet ).
            ENDIF.
            lo_autofilter->set_value(
                    i_column = lv_column
                    i_value  = lv_val ).

            lo_ixml_filter ?= lo_ixml_filter_iter->get_next( ).
          ENDWHILE.

          lo_ixml_filters ?= lo_ixml_filters_iter->get_next( ).
        ENDWHILE.

        lo_ixml_filter_column ?= lo_ixml_filter_column_iter->get_next( ).
      ENDWHILE.
    ENDIF.

  ENDMETHOD.
  METHOD load_worksheet_cond_format.

    DATA: lo_ixml_cond_formats TYPE REF TO if_ixml_node_collection,
          lo_ixml_cond_format  TYPE REF TO if_ixml_element,
          lo_ixml_iterator     TYPE REF TO if_ixml_node_iterator,
          lo_ixml_rules        TYPE REF TO if_ixml_node_collection,
          lo_ixml_rule         TYPE REF TO if_ixml_element,
          lo_ixml_iterator2    TYPE REF TO if_ixml_node_iterator,
          lo_style_cond        TYPE REF TO Lcl_excel_style_cond,
          lo_style_cond2       TYPE REF TO Lcl_excel_style_cond.


    DATA: lv_area           TYPE string,
          lt_areas          TYPE STANDARD TABLE OF string WITH NON-UNIQUE DEFAULT KEY,
          lv_area_start_row TYPE zexcel_cell_row,
          lv_area_end_row   TYPE zexcel_cell_row,
          lv_area_start_col TYPE zexcel_cell_column_alpha,
          lv_area_end_col   TYPE zexcel_cell_column_alpha,
          lv_rule           TYPE zexcel_condition_rule.


    lo_ixml_cond_formats =  io_ixml_worksheet->get_elements_by_tag_name_ns( name = 'conditionalFormatting' uri = namespace-main ).
    lo_ixml_iterator     =  lo_ixml_cond_formats->create_iterator( ).
    lo_ixml_cond_format  ?= lo_ixml_iterator->get_next( ).

    WHILE lo_ixml_cond_format IS BOUND.

      CLEAR: lv_area,
             lo_ixml_rule,
             lo_style_cond.

*--------------------------------------------------------------------*
* Get type of rule
*--------------------------------------------------------------------*
      lo_ixml_rules       =  lo_ixml_cond_format->get_elements_by_tag_name_ns( name = 'cfRule' uri = namespace-main ).
      lo_ixml_iterator2   =  lo_ixml_rules->create_iterator( ).
      lo_ixml_rule        ?= lo_ixml_iterator2->get_next( ).

      WHILE lo_ixml_rule IS BOUND.
        lv_rule = lo_ixml_rule->get_attribute_ns( 'type' ).
        CLEAR lo_style_cond.

*--------------------------------------------------------------------*
* Depending on ruletype get additional information
*--------------------------------------------------------------------*
        CASE lv_rule.

          WHEN Lcl_excel_style_cond=>c_rule_cellis.
            lo_style_cond = io_worksheet->add_new_style_cond( '' ).
            load_worksheet_cond_format_ci( io_ixml_rule  = lo_ixml_rule
                                           io_style_cond = lo_style_cond ).

          WHEN Lcl_excel_style_cond=>c_rule_databar.
            lo_style_cond = io_worksheet->add_new_style_cond( '' ).
            load_worksheet_cond_format_db( io_ixml_rule  = lo_ixml_rule
                                           io_style_cond = lo_style_cond ).

          WHEN Lcl_excel_style_cond=>c_rule_expression.
            lo_style_cond = io_worksheet->add_new_style_cond( '' ).
            load_worksheet_cond_format_ex( io_ixml_rule  = lo_ixml_rule
                                           io_style_cond = lo_style_cond ).

          WHEN Lcl_excel_style_cond=>c_rule_iconset.
            lo_style_cond = io_worksheet->add_new_style_cond( '' ).
            load_worksheet_cond_format_is( io_ixml_rule  = lo_ixml_rule
                                           io_style_cond = lo_style_cond ).

          WHEN Lcl_excel_style_cond=>c_rule_colorscale.
            lo_style_cond = io_worksheet->add_new_style_cond( '' ).
            load_worksheet_cond_format_cs( io_ixml_rule  = lo_ixml_rule
                                           io_style_cond = lo_style_cond ).

          WHEN Lcl_excel_style_cond=>c_rule_top10.
            lo_style_cond = io_worksheet->add_new_style_cond( '' ).
            load_worksheet_cond_format_t10( io_ixml_rule  = lo_ixml_rule
                                           io_style_cond = lo_style_cond ).

          WHEN Lcl_excel_style_cond=>c_rule_above_average.
            lo_style_cond = io_worksheet->add_new_style_cond( '' ).
            load_worksheet_cond_format_aa(  io_ixml_rule  = lo_ixml_rule
                                           io_style_cond = lo_style_cond ).
          WHEN OTHERS.
        ENDCASE.

        IF lo_style_cond IS BOUND.
          lo_style_cond->rule      = lv_rule.
          lo_style_cond->priority  = lo_ixml_rule->get_attribute_ns( 'priority' ).
*--------------------------------------------------------------------*
* Set area to which conditional formatting belongs
*--------------------------------------------------------------------*
          lv_area =  lo_ixml_cond_format->get_attribute_ns( 'sqref' ).
          SPLIT lv_area AT space INTO TABLE lt_areas.
          DELETE lt_areas WHERE table_line IS INITIAL.
          LOOP AT lt_areas INTO lv_area.

            Lcl_excel_common=>convert_range2column_a_row( EXPORTING i_range        = lv_area
                                                          IMPORTING e_column_start = lv_area_start_col
                                                                    e_column_end   = lv_area_end_col
                                                                    e_row_start    = lv_area_start_row
                                                                    e_row_end      = lv_area_end_row   ).
            lo_style_cond->add_range( ip_start_column = lv_area_start_col
                                      ip_stop_column  = lv_area_end_col
                                      ip_start_row    = lv_area_start_row
                                      ip_stop_row     = lv_area_end_row   ).
          ENDLOOP.

        ENDIF.
        lo_ixml_rule        ?= lo_ixml_iterator2->get_next( ).
      ENDWHILE.


      lo_ixml_cond_format ?= lo_ixml_iterator->get_next( ).

    ENDWHILE.

  ENDMETHOD.
  METHOD load_worksheet_cond_format_aa.
    DATA: lv_dxf_style_index TYPE i,
          val                TYPE string.

    FIELD-SYMBOLS: <ls_dxf_style> LIKE LINE OF me->mt_dxf_styles.

*--------------------------------------------------------------------*
* above or below average
*--------------------------------------------------------------------*
    val  = io_ixml_rule->get_attribute_ns( 'aboveAverage' ).
    IF val = '0'.  " 0 = below average
      io_style_cond->mode_above_average-above_average = space.
    ELSE.
      io_style_cond->mode_above_average-above_average = 'X'. " Not present or <> 0 --> we use above average
    ENDIF.

*--------------------------------------------------------------------*
* Equal average also?
*--------------------------------------------------------------------*
    CLEAR val.
    val  = io_ixml_rule->get_attribute_ns( 'equalAverage' ).
    IF val = '1'.  " 0 = below average
      io_style_cond->mode_above_average-equal_average = 'X'.
    ELSE.
      io_style_cond->mode_above_average-equal_average = ' '. " Not present or <> 1 --> we use not equal average
    ENDIF.

*--------------------------------------------------------------------*
* Standard deviation instead of value ( 2nd stddev, 3rd stdev )
*--------------------------------------------------------------------*
    CLEAR val.
    val  = io_ixml_rule->get_attribute_ns( 'stdDev' ).
    CASE val.
      WHEN 1
        OR 2
        OR 3.  " These seem to be supported by excel - don't try anything more
        io_style_cond->mode_above_average-standard_deviation = val.
    ENDCASE.

*--------------------------------------------------------------------*
* Cell formatting for top10
*--------------------------------------------------------------------*
    lv_dxf_style_index  = io_ixml_rule->get_attribute_ns( 'dxfId' ).
    READ TABLE me->mt_dxf_styles ASSIGNING <ls_dxf_style> WITH KEY dxf = lv_dxf_style_index.
    IF sy-subrc = 0.
      io_style_cond->mode_above_average-cell_style = <ls_dxf_style>-guid.
    ENDIF.

  ENDMETHOD.
  METHOD load_worksheet_cond_format_ci.
    DATA: lo_ixml_nodes      TYPE REF TO if_ixml_node_collection,
          lo_ixml_iterator   TYPE REF TO if_ixml_node_iterator,
          lo_ixml            TYPE REF TO if_ixml_element,
          lv_dxf_style_index TYPE i,
          lo_excel_style     LIKE LINE OF me->styles.

    FIELD-SYMBOLS: <ls_dxf_style> LIKE LINE OF me->mt_dxf_styles.

    io_style_cond->mode_cellis-operator  = io_ixml_rule->get_attribute_ns( 'operator' ).
    lv_dxf_style_index  = io_ixml_rule->get_attribute_ns( 'dxfId' ).
    READ TABLE me->mt_dxf_styles ASSIGNING <ls_dxf_style> WITH KEY dxf = lv_dxf_style_index.
    IF sy-subrc = 0.
      io_style_cond->mode_cellis-cell_style = <ls_dxf_style>-guid.
    ENDIF.

    lo_ixml_nodes ?= io_ixml_rule->get_elements_by_tag_name_ns( name = 'formula' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_nodes->create_iterator( ).
    lo_ixml ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml IS BOUND.

      CASE sy-index.
        WHEN 1.
          io_style_cond->mode_cellis-formula  = lo_ixml->get_value( ).

        WHEN 2.
          io_style_cond->mode_cellis-formula2 = lo_ixml->get_value( ).

        WHEN OTHERS.
          EXIT.
      ENDCASE.

      lo_ixml ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.


  ENDMETHOD.
  METHOD load_worksheet_cond_format_cs.
    DATA: lo_ixml_nodes    TYPE REF TO if_ixml_node_collection,
          lo_ixml_iterator TYPE REF TO if_ixml_node_iterator,
          lo_ixml          TYPE REF TO if_ixml_element.


    lo_ixml_nodes ?= io_ixml_rule->get_elements_by_tag_name_ns( name = 'cfvo' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_nodes->create_iterator( ).
    lo_ixml ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml IS BOUND.

      CASE sy-index.
        WHEN 1.
          io_style_cond->mode_colorscale-cfvo1_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_colorscale-cfvo1_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN 2.
          io_style_cond->mode_colorscale-cfvo2_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_colorscale-cfvo2_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN 3.
          io_style_cond->mode_colorscale-cfvo3_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_colorscale-cfvo2_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN OTHERS.
          EXIT.
      ENDCASE.

      lo_ixml ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.

    lo_ixml_nodes ?= io_ixml_rule->get_elements_by_tag_name_ns( name = 'color' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_nodes->create_iterator( ).
    lo_ixml ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml IS BOUND.

      CASE sy-index.
        WHEN 1.
          io_style_cond->mode_colorscale-colorrgb1  = lo_ixml->get_attribute_ns( 'rgb' ).

        WHEN 2.
          io_style_cond->mode_colorscale-colorrgb2  = lo_ixml->get_attribute_ns( 'rgb' ).

        WHEN 3.
          io_style_cond->mode_colorscale-colorrgb3  = lo_ixml->get_attribute_ns( 'rgb' ).

        WHEN OTHERS.
          EXIT.
      ENDCASE.

      lo_ixml ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.

  ENDMETHOD.
  METHOD load_worksheet_cond_format_db.
    DATA: lo_ixml_nodes    TYPE REF TO if_ixml_node_collection,
          lo_ixml_iterator TYPE REF TO if_ixml_node_iterator,
          lo_ixml          TYPE REF TO if_ixml_element.

    lo_ixml ?= io_ixml_rule->find_from_name_ns( name = 'color' uri = namespace-main ).
    IF lo_ixml IS BOUND.
      io_style_cond->mode_databar-colorrgb = lo_ixml->get_attribute_ns( 'rgb' ).
    ENDIF.

    lo_ixml_nodes ?= io_ixml_rule->get_elements_by_tag_name_ns( name = 'cfvo' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_nodes->create_iterator( ).
    lo_ixml ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml IS BOUND.

      CASE sy-index.
        WHEN 1.
          io_style_cond->mode_databar-cfvo1_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_databar-cfvo1_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN 2.
          io_style_cond->mode_databar-cfvo2_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_databar-cfvo2_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN OTHERS.
          EXIT.
      ENDCASE.

      lo_ixml ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.


  ENDMETHOD.
  METHOD load_worksheet_cond_format_ex.
    DATA: lo_ixml_nodes      TYPE REF TO if_ixml_node_collection,
          lo_ixml_iterator   TYPE REF TO if_ixml_node_iterator,
          lo_ixml            TYPE REF TO if_ixml_element,
          lv_dxf_style_index TYPE i,
          lo_excel_style     LIKE LINE OF me->styles.

    FIELD-SYMBOLS: <ls_dxf_style> LIKE LINE OF me->mt_dxf_styles.

    lv_dxf_style_index  = io_ixml_rule->get_attribute_ns( 'dxfId' ).
    READ TABLE me->mt_dxf_styles ASSIGNING <ls_dxf_style> WITH KEY dxf = lv_dxf_style_index.
    IF sy-subrc = 0.
      io_style_cond->mode_expression-cell_style = <ls_dxf_style>-guid.
    ENDIF.

    lo_ixml_nodes ?= io_ixml_rule->get_elements_by_tag_name_ns( name = 'formula' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_nodes->create_iterator( ).
    lo_ixml ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml IS BOUND.

      CASE sy-index.
        WHEN 1.
          io_style_cond->mode_expression-formula  = lo_ixml->get_value( ).


        WHEN OTHERS.
          EXIT.
      ENDCASE.

      lo_ixml ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.


  ENDMETHOD.
  METHOD load_worksheet_cond_format_is.
    DATA: lo_ixml_nodes        TYPE REF TO if_ixml_node_collection,
          lo_ixml_iterator     TYPE REF TO if_ixml_node_iterator,
          lo_ixml              TYPE REF TO if_ixml_element,
          lo_ixml_rule_iconset TYPE REF TO if_ixml_element.

    lo_ixml_rule_iconset ?= io_ixml_rule->get_first_child( ).
    io_style_cond->mode_iconset-iconset   = lo_ixml_rule_iconset->get_attribute_ns( 'iconSet' ).
    io_style_cond->mode_iconset-showvalue = lo_ixml_rule_iconset->get_attribute_ns( 'showValue' ).
    lo_ixml_nodes ?= lo_ixml_rule_iconset->get_elements_by_tag_name_ns( name = 'cfvo' uri = namespace-main ).
    lo_ixml_iterator = lo_ixml_nodes->create_iterator( ).
    lo_ixml ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml IS BOUND.

      CASE sy-index.
        WHEN 1.
          io_style_cond->mode_iconset-cfvo1_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_iconset-cfvo1_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN 2.
          io_style_cond->mode_iconset-cfvo2_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_iconset-cfvo2_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN 3.
          io_style_cond->mode_iconset-cfvo3_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_iconset-cfvo3_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN 4.
          io_style_cond->mode_iconset-cfvo4_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_iconset-cfvo4_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN 5.
          io_style_cond->mode_iconset-cfvo5_type  = lo_ixml->get_attribute_ns( 'type' ).
          io_style_cond->mode_iconset-cfvo5_value = lo_ixml->get_attribute_ns( 'val' ).

        WHEN OTHERS.
          EXIT.
      ENDCASE.

      lo_ixml ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.

  ENDMETHOD.
  METHOD load_worksheet_cond_format_t10.
    DATA: lv_dxf_style_index TYPE i.

    FIELD-SYMBOLS: <ls_dxf_style> LIKE LINE OF me->mt_dxf_styles.

    io_style_cond->mode_top10-topxx_count  = io_ixml_rule->get_attribute_ns( 'rank' ).        " Top10, Top20, Top 50...

    io_style_cond->mode_top10-percent      = io_ixml_rule->get_attribute_ns( 'percent' ).     " Top10 percent instead of Top10 values
    IF io_style_cond->mode_top10-percent = '1'.
      io_style_cond->mode_top10-percent = 'X'.
    ELSE.
      io_style_cond->mode_top10-percent = ' '.
    ENDIF.

    io_style_cond->mode_top10-bottom       = io_ixml_rule->get_attribute_ns( 'bottom' ).      " Bottom10 instead of Top10
    IF io_style_cond->mode_top10-bottom = '1'.
      io_style_cond->mode_top10-bottom = 'X'.
    ELSE.
      io_style_cond->mode_top10-bottom = ' '.
    ENDIF.
*--------------------------------------------------------------------*
* Cell formatting for top10
*--------------------------------------------------------------------*
    lv_dxf_style_index  = io_ixml_rule->get_attribute_ns( 'dxfId' ).
    READ TABLE me->mt_dxf_styles ASSIGNING <ls_dxf_style> WITH KEY dxf = lv_dxf_style_index.
    IF sy-subrc = 0.
      io_style_cond->mode_top10-cell_style = <ls_dxf_style>-guid.
    ENDIF.

  ENDMETHOD.
  METHOD load_worksheet_drawing.

    TYPES: BEGIN OF t_c_nv_pr,
             name TYPE string,
             id   TYPE string,
           END OF t_c_nv_pr.

    TYPES: BEGIN OF t_blip,
             cstate TYPE string,
             embed  TYPE string,
           END OF t_blip.

    TYPES: BEGIN OF t_chart,
             id TYPE string,
           END OF t_chart.

    CONSTANTS: lc_xml_attr_true     TYPE string VALUE 'true',
               lc_xml_attr_true_int TYPE string VALUE '1'.
    CONSTANTS: lc_rel_chart TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart',
               lc_rel_image TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image'.

    DATA: drawing           TYPE REF TO if_ixml_document,
          anchors           TYPE REF TO if_ixml_node_collection,
          node              TYPE REF TO if_ixml_element,
          coll_length       TYPE i,
          iterator          TYPE REF TO if_ixml_node_iterator,
          anchor_elem       TYPE REF TO if_ixml_element,

          relationship      TYPE t_relationship,
          rel_drawings      TYPE t_rel_drawings,
          rel_drawing       TYPE t_rel_drawing,
          rels_drawing      TYPE REF TO if_ixml_document,
          rels_drawing_path TYPE string,
          stripped_name     TYPE chkfile,
          dirname           TYPE string,

          path              TYPE string,
          path2             TYPE text255,
          file_ext2         TYPE char10.

    " Read Workbook Relationships
    CALL FUNCTION 'TRINT_SPLIT_FILE_AND_PATH'
      EXPORTING
        full_name     = ip_path
      IMPORTING
        stripped_name = stripped_name
        file_path     = dirname.
    CONCATENATE dirname '_rels/' stripped_name '.rels'
      INTO rels_drawing_path.
    rels_drawing_path = resolve_path( rels_drawing_path ).
    rels_drawing = me->get_ixml_from_zip_archive( rels_drawing_path ).
    node ?= rels_drawing->find_from_name_ns( name = 'Relationship' uri = namespace-relationships ).
    WHILE node IS BOUND.
      fill_struct_from_attributes( EXPORTING ip_element = node CHANGING cp_structure = relationship ).

      rel_drawing-id = relationship-id.

      CONCATENATE dirname relationship-target INTO path.
      path = resolve_path( path ).
      rel_drawing-content = me->get_from_zip_archive( path ). "------------> This is for template usage

      path2 = path.
      Lcl_excel_common=>split_file( EXPORTING ip_file = path2
                                    IMPORTING ep_extension = file_ext2 ).
      rel_drawing-file_ext = file_ext2.

      "-------------Added by Alessandro Iannacci - Should load graph xml
      CASE relationship-type.
        WHEN lc_rel_chart.
          "Read chart xml
          rel_drawing-content_xml = me->get_ixml_from_zip_archive( path ).
        WHEN OTHERS.
      ENDCASE.
      "----------------------------


      APPEND rel_drawing TO rel_drawings.

      node ?= node->get_next( ).
    ENDWHILE.

    drawing = me->get_ixml_from_zip_archive( ip_path ).

* one-cell anchor **************
    anchors = drawing->get_elements_by_tag_name_ns( name = 'oneCellAnchor' uri = namespace-xdr ).
    coll_length = anchors->get_length( ).
    iterator = anchors->create_iterator( ).
    DO coll_length TIMES.
      anchor_elem ?= iterator->get_next( ).

      CALL METHOD me->load_drawing_anchor
        EXPORTING
          io_anchor_element   = anchor_elem
          io_worksheet        = io_worksheet
          it_related_drawings = rel_drawings.

    ENDDO.

* two-cell anchor ******************
    anchors = drawing->get_elements_by_tag_name_ns( name = 'twoCellAnchor' uri = namespace-xdr ).
    coll_length = anchors->get_length( ).
    iterator = anchors->create_iterator( ).
    DO coll_length TIMES.
      anchor_elem ?= iterator->get_next( ).

      CALL METHOD me->load_drawing_anchor
        EXPORTING
          io_anchor_element   = anchor_elem
          io_worksheet        = io_worksheet
          it_related_drawings = rel_drawings.

    ENDDO.

  ENDMETHOD.
  METHOD load_worksheet_hyperlinks.

    DATA: lo_ixml_hyperlinks TYPE REF TO if_ixml_node_collection,
          lo_ixml_hyperlink  TYPE REF TO if_ixml_element,
          lo_ixml_iterator   TYPE REF TO if_ixml_node_iterator,
          lv_row_start       TYPE zexcel_cell_row,
          lv_row_end         TYPE zexcel_cell_row,
          lv_column_start    TYPE zexcel_cell_column_alpha,
          lv_column_end      TYPE zexcel_cell_column_alpha,
          lv_is_internal     TYPE abap_bool,
          lv_url             TYPE string,
          lv_value           TYPE zexcel_cell_value.

    DATA: BEGIN OF ls_hyperlink,
            ref      TYPE string,
            display  TYPE string,
            location TYPE string,
            tooltip  TYPE string,
            r_id     TYPE string,
          END OF ls_hyperlink.

    FIELD-SYMBOLS: <ls_external_hyperlink> LIKE LINE OF it_external_hyperlinks.

    lo_ixml_hyperlinks =  io_ixml_worksheet->get_elements_by_tag_name_ns( name = 'hyperlink' uri = namespace-main ).
    lo_ixml_iterator   =  lo_ixml_hyperlinks->create_iterator( ).
    lo_ixml_hyperlink  ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml_hyperlink IS BOUND.

      CLEAR ls_hyperlink.
      CLEAR lv_url.

      ls_hyperlink-ref      = lo_ixml_hyperlink->get_attribute_ns( 'ref' ).
      ls_hyperlink-display  = lo_ixml_hyperlink->get_attribute_ns( 'display' ).
      ls_hyperlink-location = lo_ixml_hyperlink->get_attribute_ns( 'location' ).
      ls_hyperlink-tooltip  = lo_ixml_hyperlink->get_attribute_ns( 'tooltip' ).
      ls_hyperlink-r_id     = lo_ixml_hyperlink->get_attribute_ns( name = 'id' uri = namespace-r ).
      IF ls_hyperlink-r_id IS INITIAL.  " Internal link
        lv_is_internal = abap_true.
        lv_url = ls_hyperlink-location.
      ELSE.                             " External link
        READ TABLE it_external_hyperlinks ASSIGNING <ls_external_hyperlink> WITH TABLE KEY id = ls_hyperlink-r_id.
        IF sy-subrc = 0.
          lv_is_internal = abap_false.
          lv_url = <ls_external_hyperlink>-target.
        ENDIF.
      ENDIF.

      IF lv_url IS NOT INITIAL.  " because of unsupported external links

        Lcl_excel_common=>convert_range2column_a_row(
          EXPORTING
            i_range        = ls_hyperlink-ref
          IMPORTING
            e_column_start = lv_column_start
            e_column_end   = lv_column_end
            e_row_start    = lv_row_start
            e_row_end      = lv_row_end ).

        io_worksheet->set_area_hyperlink(
          EXPORTING
            ip_column_start = lv_column_start
            ip_column_end   = lv_column_end
            ip_row          = lv_row_start
            ip_row_to       = lv_row_end
            ip_url          = lv_url
            ip_is_internal  = lv_is_internal ).

      ENDIF.

      lo_ixml_hyperlink ?= lo_ixml_iterator->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD load_worksheet_ignored_errors.

    DATA: lo_ixml_ignored_errors TYPE REF TO if_ixml_node_collection,
          lo_ixml_ignored_error  TYPE REF TO if_ixml_element,
          lo_ixml_iterator       TYPE REF TO if_ixml_node_iterator,
          ls_ignored_error       TYPE Lcl_excel_worksheet=>mty_s_ignored_errors,
          lt_ignored_errors      TYPE Lcl_excel_worksheet=>mty_th_ignored_errors.

    DATA: BEGIN OF ls_raw_ignored_error,
            sqref              TYPE string,
            evalerror          TYPE string,
            twodigittextyear   TYPE string,
            numberstoredastext TYPE string,
            formula            TYPE string,
            formularange       TYPE string,
            unlockedformula    TYPE string,
            emptycellreference TYPE string,
            listdatavalidation TYPE string,
            calculatedcolumn   TYPE string,
          END OF ls_raw_ignored_error.

    CLEAR lt_ignored_errors.

    lo_ixml_ignored_errors =  io_ixml_worksheet->get_elements_by_tag_name_ns( name = 'ignoredError' uri = namespace-main ).
    lo_ixml_iterator   =  lo_ixml_ignored_errors->create_iterator( ).
    lo_ixml_ignored_error  ?= lo_ixml_iterator->get_next( ).

    WHILE lo_ixml_ignored_error IS BOUND.

      fill_struct_from_attributes( EXPORTING
                                     ip_element   = lo_ixml_ignored_error
                                   CHANGING
                                     cp_structure = ls_raw_ignored_error ).

      CLEAR ls_ignored_error.
      ls_ignored_error-cell_coords = ls_raw_ignored_error-sqref.
      ls_ignored_error-eval_error = boolc( ls_raw_ignored_error-evalerror = '1' ).
      ls_ignored_error-two_digit_text_year = boolc( ls_raw_ignored_error-twodigittextyear = '1' ).
      ls_ignored_error-number_stored_as_text = boolc( ls_raw_ignored_error-numberstoredastext = '1' ).
      ls_ignored_error-formula = boolc( ls_raw_ignored_error-formula = '1' ).
      ls_ignored_error-formula_range = boolc( ls_raw_ignored_error-formularange = '1' ).
      ls_ignored_error-unlocked_formula = boolc( ls_raw_ignored_error-unlockedformula = '1' ).
      ls_ignored_error-empty_cell_reference = boolc( ls_raw_ignored_error-emptycellreference = '1' ).
      ls_ignored_error-list_data_validation = boolc( ls_raw_ignored_error-listdatavalidation = '1' ).
      ls_ignored_error-calculated_column  = boolc( ls_raw_ignored_error-calculatedcolumn = '1' ).

      INSERT ls_ignored_error INTO TABLE lt_ignored_errors.

      lo_ixml_ignored_error ?= lo_ixml_iterator->get_next( ).

    ENDWHILE.

    io_worksheet->set_ignored_errors( lt_ignored_errors ).

  ENDMETHOD.
  METHOD load_worksheet_pagebreaks.

    DATA: lo_node           TYPE REF TO if_ixml_element,
          lo_ixml_rowbreaks TYPE REF TO if_ixml_node_collection,
          lo_ixml_colbreaks TYPE REF TO if_ixml_node_collection,
          lo_ixml_iterator  TYPE REF TO if_ixml_node_iterator,
          lo_ixml_rowbreak  TYPE REF TO if_ixml_element,
          lo_ixml_colbreak  TYPE REF TO if_ixml_element,
          lo_style_cond     TYPE REF TO Lcl_excel_style_cond,
          lv_count          TYPE i.


    DATA: lt_pagebreaks TYPE STANDARD TABLE OF Lcl_excel_worksheet_pagebreaks=>ts_pagebreak_at,
          lo_pagebreaks TYPE REF TO Lcl_excel_worksheet_pagebreaks.

    FIELD-SYMBOLS: <ls_pagebreak_row> LIKE LINE OF lt_pagebreaks.
    FIELD-SYMBOLS: <ls_pagebreak_col> LIKE LINE OF lt_pagebreaks.

*--------------------------------------------------------------------*
* Get minimal number of cells where to add pagebreaks
* Since rows and columns are handled in separate nodes
* Build table to identify these cells
*--------------------------------------------------------------------*
    lo_node ?= io_ixml_worksheet->find_from_name_ns( name = 'rowBreaks' uri = namespace-main ).
    CHECK lo_node IS BOUND.
    lo_ixml_rowbreaks =  lo_node->get_elements_by_tag_name_ns( name = 'brk' uri = namespace-main ).
    lo_ixml_iterator  =  lo_ixml_rowbreaks->create_iterator( ).
    lo_ixml_rowbreak  ?= lo_ixml_iterator->get_next( ).
    WHILE lo_ixml_rowbreak IS BOUND.
      APPEND INITIAL LINE TO lt_pagebreaks ASSIGNING <ls_pagebreak_row>.
      <ls_pagebreak_row>-cell_row = lo_ixml_rowbreak->get_attribute_ns( 'id' ).

      lo_ixml_rowbreak  ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.
    CHECK <ls_pagebreak_row> IS ASSIGNED.

    lo_node ?= io_ixml_worksheet->find_from_name_ns( name = 'colBreaks' uri = namespace-main ).
    CHECK lo_node IS BOUND.
    lo_ixml_colbreaks =  lo_node->get_elements_by_tag_name_ns( name = 'brk' uri = namespace-main ).
    lo_ixml_iterator  =  lo_ixml_colbreaks->create_iterator( ).
    lo_ixml_colbreak  ?= lo_ixml_iterator->get_next( ).
    CLEAR lv_count.
    WHILE lo_ixml_colbreak IS BOUND.
      ADD 1 TO lv_count.
      READ TABLE lt_pagebreaks INDEX lv_count ASSIGNING <ls_pagebreak_col>.
      IF sy-subrc <> 0.
        APPEND INITIAL LINE TO lt_pagebreaks ASSIGNING <ls_pagebreak_col>.
        <ls_pagebreak_col>-cell_row = <ls_pagebreak_row>-cell_row.
      ENDIF.
      <ls_pagebreak_col>-cell_column = lo_ixml_colbreak->get_attribute_ns( 'id' ).

      lo_ixml_colbreak  ?= lo_ixml_iterator->get_next( ).
    ENDWHILE.
*--------------------------------------------------------------------*
* Finally add each pagebreak
*--------------------------------------------------------------------*
    lo_pagebreaks = io_worksheet->get_pagebreaks( ).
    LOOP AT lt_pagebreaks ASSIGNING <ls_pagebreak_row>.
      lo_pagebreaks->add_pagebreak( ip_column = <ls_pagebreak_row>-cell_column
                                    ip_row    = <ls_pagebreak_row>-cell_row ).
    ENDLOOP.


  ENDMETHOD.
  METHOD load_worksheet_pagemargins.

    TYPES: BEGIN OF lty_page_margins,
             footer TYPE string,
             header TYPE string,
             bottom TYPE string,
             top    TYPE string,
             right  TYPE string,
             left   TYPE string,
           END OF lty_page_margins.

    DATA:lo_ixml_pagemargins_elem TYPE REF TO if_ixml_element,
         ls_pagemargins           TYPE lty_page_margins.


    lo_ixml_pagemargins_elem = io_ixml_worksheet->find_from_name_ns( name = 'pageMargins' uri = namespace-main ).
    IF lo_ixml_pagemargins_elem IS NOT INITIAL.
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_pagemargins_elem
                                   CHANGING
                                     cp_structure = ls_pagemargins ).
      io_worksheet->sheet_setup->margin_bottom = Lcl_excel_common=>excel_string_to_number( ls_pagemargins-bottom ).
      io_worksheet->sheet_setup->margin_footer = Lcl_excel_common=>excel_string_to_number( ls_pagemargins-footer ).
      io_worksheet->sheet_setup->margin_header = Lcl_excel_common=>excel_string_to_number( ls_pagemargins-header ).
      io_worksheet->sheet_setup->margin_left   = Lcl_excel_common=>excel_string_to_number( ls_pagemargins-left   ).
      io_worksheet->sheet_setup->margin_right  = Lcl_excel_common=>excel_string_to_number( ls_pagemargins-right  ).
      io_worksheet->sheet_setup->margin_top    = Lcl_excel_common=>excel_string_to_number( ls_pagemargins-top    ).
    ENDIF.

  ENDMETHOD.
  METHOD read_from_applserver.

    DATA: lv_filelength         TYPE i,
          lt_binary_data        TYPE STANDARD TABLE OF x255 WITH NON-UNIQUE DEFAULT KEY,
          ls_binary_data        LIKE LINE OF lt_binary_data,
          lv_filename           TYPE string,
          lv_max_length_line    TYPE i,
          lv_actual_length_line TYPE i,
          lv_errormessage       TYPE string.

    lv_filename = i_filename.

    DESCRIBE FIELD ls_binary_data LENGTH lv_max_length_line IN BYTE MODE.
    OPEN DATASET lv_filename FOR INPUT IN BINARY MODE.
    IF sy-subrc <> 0.
      lv_errormessage = 'A problem occured when reading the file'(001).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.
    WHILE sy-subrc = 0.

      READ DATASET lv_filename INTO ls_binary_data MAXIMUM LENGTH lv_max_length_line ACTUAL LENGTH lv_actual_length_line.
      APPEND ls_binary_data TO lt_binary_data.
      lv_filelength = lv_filelength + lv_actual_length_line.

    ENDWHILE.
    CLOSE DATASET lv_filename.

*--------------------------------------------------------------------*
* Binary data needs to be provided as XSTRING for further processing
*--------------------------------------------------------------------*
    CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
      EXPORTING
        input_length = lv_filelength
      IMPORTING
        buffer       = r_excel_data
      TABLES
        binary_tab   = lt_binary_data.
  ENDMETHOD.
  METHOD read_from_local_file.
    DATA: lv_filelength   TYPE i,
          lt_binary_data  TYPE STANDARD TABLE OF x255 WITH NON-UNIQUE DEFAULT KEY,
          ls_binary_data  LIKE LINE OF lt_binary_data,
          lv_filename     TYPE string,
          lv_errormessage TYPE string.

    lv_filename = i_filename.

    cl_gui_frontend_services=>gui_upload( EXPORTING
                                            filename                = lv_filename
                                            filetype                = 'BIN'         " We are basically working with zipped directories --> force binary read
                                          IMPORTING
                                            filelength              = lv_filelength
                                          CHANGING
                                            data_tab                = lt_binary_data
                                          EXCEPTIONS
                                            file_open_error         = 1
                                            file_read_error         = 2
                                            no_batch                = 3
                                            gui_refuse_filetransfer = 4
                                            invalid_type            = 5
                                            no_authority            = 6
                                            unknown_error           = 7
                                            bad_data_format         = 8
                                            header_not_allowed      = 9
                                            separator_not_allowed   = 10
                                            header_too_long         = 11
                                            unknown_dp_error        = 12
                                            access_denied           = 13
                                            dp_out_of_memory        = 14
                                            disk_full               = 15
                                            dp_timeout              = 16
                                            not_supported_by_gui    = 17
                                            error_no_gui            = 18
                                            OTHERS                  = 19 ).
    IF sy-subrc <> 0.
      lv_errormessage = 'A problem occured when reading the file'(001).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

*--------------------------------------------------------------------*
* Binary data needs to be provided as XSTRING for further processing
*--------------------------------------------------------------------*
    CALL FUNCTION 'SCMS_BINARY_TO_XSTRING'
      EXPORTING
        input_length = lv_filelength
      IMPORTING
        buffer       = r_excel_data
      TABLES
        binary_tab   = lt_binary_data.

  ENDMETHOD.
  METHOD resolve_path.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   Determine whether the replacement should be done
*                iterative to allow /../../..   or something alike
*        2do§2   Determine whether /./ has to be supported as well
*        2do§3   Create unit-test for this method
*
*                Please don't just delete these ToDos if they are not
*                needed but leave a comment that states this
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-11-11
*              - ...
* changes: replaced previous coding by regular expression
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* §1  This routine will receive a path, that may have a relative pathname (/../) included somewhere
*     The output should be a resolved path without relative references
*     Example:  Input     xl/worksheets/../drawings/drawing1.xml
*               Output    xl/drawings/drawing1.xml
*--------------------------------------------------------------------*

    rp_result = ip_path.
*--------------------------------------------------------------------*
* §1  Remove relative pathnames
*--------------------------------------------------------------------*
*  Regular expression   [^/]*/\.\./
*                       [^/]*            --> any number of characters other than /
*   followed by              /\.\./      --> the sequence /../
*   ==> worksheets/../ will be found in the example
*--------------------------------------------------------------------*
    REPLACE REGEX '[^/]*/\.\./' IN rp_result WITH ``.


  ENDMETHOD.
  METHOD resolve_referenced_formulae.
    TYPES: BEGIN OF ty_referenced_cells,
             sheet    TYPE REF TO Lcl_excel_worksheet,
             si       TYPE i,
             row_from TYPE i,
             row_to   TYPE i,
             col_from TYPE i,
             col_to   TYPE i,
             formula  TYPE string,
             ref_cell TYPE char10,
           END OF ty_referenced_cells.

    DATA: ls_ref_formula       LIKE LINE OF me->mt_ref_formulae,
          lts_referenced_cells TYPE SORTED TABLE OF ty_referenced_cells WITH NON-UNIQUE KEY sheet si row_from row_to col_from col_to,
          ls_referenced_cell   LIKE LINE OF lts_referenced_cells,
          lv_col_from          TYPE zexcel_cell_column_alpha,
          lv_col_to            TYPE zexcel_cell_column_alpha,
          lv_resulting_formula TYPE string,
          lv_current_cell      TYPE char10.


    me->mt_ref_formulae = me->mt_ref_formulae.

*--------------------------------------------------------------------*
* Get referenced Cells,  Build ranges for easy lookup
*--------------------------------------------------------------------*
    LOOP AT me->mt_ref_formulae INTO ls_ref_formula WHERE ref <> space.

      CLEAR ls_referenced_cell.
      ls_referenced_cell-sheet      = ls_ref_formula-sheet.
      ls_referenced_cell-si         = ls_ref_formula-si.
      ls_referenced_cell-formula    = ls_ref_formula-formula.

      TRY.
          Lcl_excel_common=>convert_range2column_a_row( EXPORTING i_range        = ls_ref_formula-ref
                                                        IMPORTING e_column_start = lv_col_from
                                                                  e_column_end   = lv_col_to
                                                                  e_row_start    = ls_referenced_cell-row_from
                                                                  e_row_end      = ls_referenced_cell-row_to  ).
          ls_referenced_cell-col_from = Lcl_excel_common=>convert_column2int( lv_col_from ).
          ls_referenced_cell-col_to   = Lcl_excel_common=>convert_column2int( lv_col_to ).


          CLEAR ls_referenced_cell-ref_cell.
          TRY.
              ls_referenced_cell-ref_cell(3) = Lcl_excel_common=>convert_column2alpha( ls_ref_formula-column ).
              ls_referenced_cell-ref_cell+3  = ls_ref_formula-row.
              CONDENSE ls_referenced_cell-ref_cell NO-GAPS.
            CATCH Lcx_excel.
          ENDTRY.

          INSERT ls_referenced_cell INTO TABLE lts_referenced_cells.
        CATCH Lcx_excel.
      ENDTRY.

    ENDLOOP.

*  break x0009004.
*--------------------------------------------------------------------*
* For each referencing cell determine the referenced cell
* and resolve the formula
*--------------------------------------------------------------------*
    LOOP AT me->mt_ref_formulae INTO ls_ref_formula WHERE ref = space.


      CLEAR lv_current_cell.
      TRY.
          lv_current_cell(3) = Lcl_excel_common=>convert_column2alpha( ls_ref_formula-column ).
          lv_current_cell+3  = ls_ref_formula-row.
          CONDENSE lv_current_cell NO-GAPS.
        CATCH Lcx_excel.
      ENDTRY.

      LOOP AT lts_referenced_cells INTO ls_referenced_cell WHERE sheet     = ls_ref_formula-sheet
                                                             AND si        = ls_ref_formula-si
                                                             AND row_from <= ls_ref_formula-row
                                                             AND row_to   >= ls_ref_formula-row
                                                             AND col_from <= ls_ref_formula-column
                                                             AND col_to   >= ls_ref_formula-column.

        TRY.

            lv_resulting_formula = Lcl_excel_common=>determine_resulting_formula( iv_reference_cell     = ls_referenced_cell-ref_cell
                                                                                  iv_reference_formula  = ls_referenced_cell-formula
                                                                                  iv_current_cell       = lv_current_cell ).

            ls_referenced_cell-sheet->set_cell_formula( ip_column   = ls_ref_formula-column
                                                        ip_row      = ls_ref_formula-row
                                                        ip_formula  = lv_resulting_formula ).
          CATCH Lcx_excel.
        ENDTRY.
        EXIT.

      ENDLOOP.

    ENDLOOP.
  ENDMETHOD.
  METHOD Lif_excel_reader~load.
*--------------------------------------------------------------------*
* ToDos:
*        2do§1   Map Document Properties to LCL_EXCEL
*--------------------------------------------------------------------*

    CONSTANTS: lcv_core_properties TYPE string VALUE 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties',
               lcv_office_document TYPE string VALUE 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument'.

    DATA: lo_rels         TYPE REF TO if_ixml_document,
          lo_node         TYPE REF TO if_ixml_element,
          ls_relationship TYPE t_relationship.

*--------------------------------------------------------------------*
* §1  Create EXCEL-Object we want to return to caller

* §2  We need to read the the file "\\_rels\.rels" because it tells
*     us where in this folder structure the data for the workbook
*     is located in the xlsx zip-archive
*
*     The xlsx Zip-archive has generally the following folder structure:
*       <root> |
*              |-->  _rels
*              |-->  doc_Props
*              |-->  xl |
*                       |-->  _rels
*                       |-->  theme
*                       |-->  worksheets

* §3  Extracting from this the path&file where the workbook is located
*     Following is an example how this file could be set up
*        <?xml version="1.0" encoding="UTF-8" standalone="true"?>
*        <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
*            <Relationship Target="docProps/app.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Id="rId3"/>
*            <Relationship Target="docProps/core.xml" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Id="rId2"/>
*            <Relationship Target="xl/workbook.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Id="rId1"/>
*        </Relationships>
*--------------------------------------------------------------------*

    CLEAR mt_dxf_styles.
    CLEAR mt_ref_formulae.
    CLEAR shared_strings.
    CLEAR styles.

*--------------------------------------------------------------------*
* §1  Create EXCEL-Object we want to return to caller
*--------------------------------------------------------------------*
    IF iv_zcl_excel_classname IS INITIAL.
      CREATE OBJECT r_excel.
    ELSE.
      CREATE OBJECT r_excel TYPE (iv_zcl_excel_classname).
    ENDIF.

    zip = create_zip_archive( i_xlsx_binary = i_excel2007
                              i_use_alternate_zip = i_use_alternate_zip ).

*--------------------------------------------------------------------*
* §2  Get file in folderstructure
*--------------------------------------------------------------------*
    lo_rels = get_ixml_from_zip_archive( '_rels/.rels' ).

*--------------------------------------------------------------------*
* §3  Cycle through the Relationship Tags and use the ones we need
*--------------------------------------------------------------------*
    lo_node ?= lo_rels->find_from_name_ns( name = 'Relationship' uri = namespace-relationships ). "#EC NOTEXT
    WHILE lo_node IS BOUND.

      fill_struct_from_attributes( EXPORTING
                                     ip_element   = lo_node
                                   CHANGING
                                     cp_structure = ls_relationship ).
      CASE ls_relationship-type.

        WHEN lcv_office_document.
*--------------------------------------------------------------------*
* Parse workbook - main part here
*--------------------------------------------------------------------*
          load_workbook( iv_workbook_full_filename  = ls_relationship-target
                         io_excel                   = r_excel ).

        WHEN lcv_core_properties.
          " 2do§1   Map Document Properties to LCL_EXCEL

        WHEN OTHERS.

      ENDCASE.
      lo_node ?= lo_node->get_next( ).

    ENDWHILE.


  ENDMETHOD.
  METHOD Lif_excel_reader~load_file.

    DATA: lv_excel_data TYPE xstring.

*--------------------------------------------------------------------*
* Read file into binary string
*--------------------------------------------------------------------*
    IF i_from_applserver = abap_true.
      lv_excel_data = read_from_applserver( i_filename ).
    ELSE.
      lv_excel_data = read_from_local_file( i_filename ).
    ENDIF.

*--------------------------------------------------------------------*
* Parse Excel data into LCL_EXCEL object from binary string
*--------------------------------------------------------------------*
    r_excel = Lif_excel_reader~load( i_excel2007            = lv_excel_data
                                     i_use_alternate_zip    = i_use_alternate_zip
                                     iv_zcl_excel_classname = iv_zcl_excel_classname ).

  ENDMETHOD.
  METHOD load_worksheet_tables.

    DATA lo_ixml_table_columns TYPE REF TO if_ixml_node_collection.
    DATA lo_ixml_table_column  TYPE REF TO if_ixml_element.
    DATA lo_ixml_table TYPE REF TO if_ixml_element.
    DATA lo_ixml_table_style TYPE REF TO if_ixml_element.
    DATA lt_field_catalog TYPE zexcel_t_fieldcatalog.
    DATA ls_field_catalog TYPE zexcel_s_fieldcatalog.
    DATA lo_ixml_iterator TYPE REF TO if_ixml_node_iterator.
    DATA ls_table_settings TYPE zexcel_s_table_settings.
    DATA lv_path TYPE string.
    DATA lt_components TYPE abap_component_tab.
    DATA ls_component TYPE abap_componentdescr.
    DATA lo_rtti_table TYPE REF TO cl_abap_tabledescr.
    DATA lv_dref_table TYPE REF TO data.
    DATA lv_num_lines TYPE i.
    DATA lo_line_type TYPE REF TO cl_abap_structdescr.

    DATA: BEGIN OF ls_table,
            id             TYPE string,
            name           TYPE string,
            displayname    TYPE string,
            ref            TYPE string,
            totalsrowshown TYPE string,
          END OF ls_table.

    DATA: BEGIN OF ls_table_style,
            name              TYPE string,
            showrowstripes    TYPE string,
            showcolumnstripes TYPE string,
          END OF ls_table_style.

    DATA: BEGIN OF ls_table_column,
            id   TYPE string,
            name TYPE string,
          END OF ls_table_column.

    FIELD-SYMBOLS <ls_table> LIKE LINE OF it_tables.
    FIELD-SYMBOLS <lt_table> TYPE STANDARD TABLE.
    FIELD-SYMBOLS <ls_field> TYPE zexcel_s_fieldcatalog.

    LOOP AT it_tables ASSIGNING <ls_table>.

      CONCATENATE iv_dirname <ls_table>-target INTO lv_path.
      lv_path = resolve_path( lv_path ).

      lo_ixml_table = me->get_ixml_from_zip_archive( lv_path )->get_root_element( ).
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_table
                                   CHANGING
                                     cp_structure = ls_table ).

      lo_ixml_table_style ?= lo_ixml_table->find_from_name( 'tableStyleInfo' ).
      fill_struct_from_attributes( EXPORTING
                                     ip_element = lo_ixml_table_style
                                   CHANGING
                                     cp_structure = ls_table_style ).

      ls_table_settings-table_name = ls_table-name.
      ls_table_settings-show_column_stripes = ls_table_style-showcolumnstripes.
      ls_table_settings-show_row_stripes = ls_table_style-showrowstripes.

      Lcl_excel_common=>convert_range2column_a_row(
        EXPORTING
          i_range        = ls_table-ref
        IMPORTING
          e_column_start = ls_table_settings-top_left_column
          e_column_end   = ls_table_settings-bottom_right_column
          e_row_start    = ls_table_settings-top_left_row
          e_row_end      = ls_table_settings-bottom_right_row ).

      lo_ixml_table_columns =  lo_ixml_table->get_elements_by_tag_name( name = 'tableColumn' ).
      lo_ixml_iterator     =  lo_ixml_table_columns->create_iterator( ).
      lo_ixml_table_column  ?= lo_ixml_iterator->get_next( ).
      CLEAR lt_field_catalog.
      WHILE lo_ixml_table_column IS BOUND.

        CLEAR ls_table_column.
        fill_struct_from_attributes( EXPORTING
                                       ip_element = lo_ixml_table_column
                                     CHANGING
                                       cp_structure = ls_table_column ).

        ls_field_catalog-position = lines( lt_field_catalog ) + 1.
        ls_field_catalog-fieldname = |COMP_{ ls_field_catalog-position PAD = '0' ALIGN = RIGHT WIDTH = 4 }|.
        ls_field_catalog-scrtext_l = ls_table_column-name.
        ls_field_catalog-dynpfld = abap_true.
        ls_field_catalog-abap_type = cl_abap_typedescr=>typekind_string.
        APPEND ls_field_catalog TO lt_field_catalog.

        lo_ixml_table_column ?= lo_ixml_iterator->get_next( ).

      ENDWHILE.

      CLEAR lt_components.
      LOOP AT lt_field_catalog ASSIGNING <ls_field>.
        CLEAR ls_component.
        ls_component-name = <ls_field>-fieldname.
        ls_component-type = cl_abap_elemdescr=>get_string( ).
        APPEND ls_component TO lt_components.
      ENDLOOP.

      lo_line_type = cl_abap_structdescr=>get( lt_components ).
      lo_rtti_table = cl_abap_tabledescr=>get( lo_line_type ).
      CREATE DATA lv_dref_table TYPE HANDLE lo_rtti_table.
      ASSIGN lv_dref_table->* TO <lt_table>.

      lv_num_lines = ls_table_settings-bottom_right_row - ls_table_settings-top_left_row.
      DO lv_num_lines TIMES.
        APPEND INITIAL LINE TO <lt_table>.
      ENDDO.

      io_worksheet->bind_table(
        EXPORTING
          ip_table            = <lt_table>
          it_field_catalog    = lt_field_catalog
          is_table_settings   = ls_table_settings ).

    ENDLOOP.

  ENDMETHOD.
endclass. "LCL_EXCEL_READER_2007 implementation

*>>>>>>> LCL_EXCEL_THEME_COLOR_SCHEME <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme_color_scheme==ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme_color_scheme==ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_THEME_COLOR_SCHEME implementation.
*"* method's implementations
*include methods.
  METHOD build_xml.
    DATA: lo_scheme_element TYPE REF TO if_ixml_element.
    DATA: lo_color TYPE REF TO if_ixml_element.
    DATA: lo_syscolor TYPE REF TO if_ixml_element.
    DATA: lo_srgb TYPE REF TO if_ixml_element.
    DATA: lo_elements TYPE REF TO if_ixml_element.

    CHECK io_document IS BOUND.
    lo_elements ?= io_document->find_from_name_ns( name   = Lcl_excel_theme=>c_theme_elements ).
    IF lo_elements IS BOUND.
      lo_scheme_element ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix
                                                                  name   = Lcl_excel_theme_elements=>c_color_scheme
                                                               parent = lo_elements ).
      lo_scheme_element->set_attribute( name = c_name value = name ).

      " Adding colors to scheme
      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix
                                                                  name   = c_dark1
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF dark1-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = dark1-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = dark1-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = dark1-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.

      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_light1
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF light1-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = light1-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = light1-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = light1-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.


      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_dark2
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF dark2-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = dark2-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = dark2-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = dark2-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.

      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_light2
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF light2-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = light2-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = light2-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = light2-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.


      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_accent1
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF accent1-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = accent1-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = accent1-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = accent1-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.


      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_accent2
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF accent2-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = accent2-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = accent2-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = accent2-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.


      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_accent3
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF accent3-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = accent3-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = accent3-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = accent3-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.


      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_accent4
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF accent4-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = accent4-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = accent4-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = accent4-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.


      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_accent5
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF accent5-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = accent5-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = accent5-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = accent5-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.


      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_accent6
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF accent6-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = accent6-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = accent6-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = accent6-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.

      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_hlink
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF hlink-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = hlink-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = hlink-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = hlink-syscolor-lastclr ).
        ENDIF.
        CLEAR: lo_color, lo_srgb, lo_syscolor.
      ENDIF.

      lo_color ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_folhlink
                                                      parent = lo_scheme_element ).
      IF lo_color IS BOUND.
        IF folhlink-srgb IS NOT INITIAL.
          lo_srgb ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_srgbcolor
                                                         parent = lo_color ).
          lo_srgb->set_attribute( name = c_val value = folhlink-srgb ).
        ELSE.
          lo_syscolor ?= io_document->create_simple_element_ns( prefix = Lcl_excel_theme=>c_theme_prefix  name   = c_syscolor
                                                          parent = lo_color ).
          lo_syscolor->set_attribute( name = c_val value = folhlink-syscolor-val ).
          lo_syscolor->set_attribute( name = c_lastclr value = folhlink-syscolor-lastclr ).
        ENDIF.
      ENDIF.


    ENDIF.
  ENDMETHOD.                    "build_xml
  METHOD constructor.
    set_defaults( ).
  ENDMETHOD.                    "constructor
  METHOD get_color.
    DATA: lo_color_children TYPE REF TO if_ixml_node_list.
    DATA: lo_color_iterator TYPE REF TO if_ixml_node_iterator.
    DATA: lo_color_element TYPE REF TO if_ixml_element.
    CHECK io_object  IS NOT INITIAL.

    lo_color_children = io_object->get_children( ).
    lo_color_iterator = lo_color_children->create_iterator( ).
    lo_color_element ?= lo_color_iterator->get_next( ).
    IF lo_color_element IS BOUND.
      CASE lo_color_element->get_name( ).
        WHEN c_srgbcolor.
          rv_color-srgb = lo_color_element->get_attribute( name = c_val ).
        WHEN c_syscolor.
          rv_color-syscolor-val = lo_color_element->get_attribute( name = c_val ).
          rv_color-syscolor-lastclr = lo_color_element->get_attribute( name = c_lastclr ).
      ENDCASE.
    ENDIF.
  ENDMETHOD.                    "get_color
  METHOD load.
    DATA: lo_scheme_children TYPE REF TO if_ixml_node_list.
    DATA: lo_scheme_iterator TYPE REF TO if_ixml_node_iterator.
    DATA: lo_scheme_element TYPE REF TO if_ixml_element.
    CHECK io_color_scheme  IS NOT INITIAL.

    name = io_color_scheme->get_attribute( name = c_name ).
    lo_scheme_children = io_color_scheme->get_children( ).
    lo_scheme_iterator = lo_scheme_children->create_iterator( ).
    lo_scheme_element ?= lo_scheme_iterator->get_next( ).
    WHILE lo_scheme_element IS BOUND.
      CASE lo_scheme_element->get_name( ).
        WHEN c_dark1.
          dark1 = me->get_color( lo_scheme_element ).
        WHEN c_dark2.
          dark2 = me->get_color( lo_scheme_element ).
        WHEN c_light1.
          light1 = me->get_color( lo_scheme_element ).
        WHEN c_light2.
          light2 = me->get_color( lo_scheme_element ).
        WHEN c_accent1.
          accent1 = me->get_color( lo_scheme_element ).
        WHEN c_accent2.
          accent2 = me->get_color( lo_scheme_element ).
        WHEN c_accent3.
          accent3 = me->get_color( lo_scheme_element ).
        WHEN c_accent4.
          accent4 = me->get_color( lo_scheme_element ).
        WHEN c_accent5.
          accent5 = me->get_color( lo_scheme_element ).
        WHEN c_accent6.
          accent6 = me->get_color( lo_scheme_element ).
        WHEN c_hlink.
          hlink = me->get_color( lo_scheme_element ).
        WHEN c_folhlink.
          folhlink = me->get_color( lo_scheme_element ).
      ENDCASE.
      lo_scheme_element ?= lo_scheme_iterator->get_next( ).
    ENDWHILE.
  ENDMETHOD.                    "load
  METHOD set_color.
    FIELD-SYMBOLS: <color> TYPE t_color.
    CHECK iv_type IS NOT INITIAL.
    CHECK iv_srgb IS NOT INITIAL OR  iv_syscolorname IS NOT INITIAL.
    CASE iv_type.
      WHEN c_dark1.
        ASSIGN dark1 TO <color>.
      WHEN c_dark2.
        ASSIGN dark2 TO <color>.
      WHEN c_light1.
        ASSIGN light1 TO <color>.
      WHEN c_light2.
        ASSIGN light2 TO <color>.
      WHEN c_accent1.
        ASSIGN accent1 TO <color>.
      WHEN c_accent2.
        ASSIGN accent2 TO <color>.
      WHEN c_accent3.
        ASSIGN accent3 TO <color>.
      WHEN c_accent4.
        ASSIGN accent4 TO <color>.
      WHEN c_accent5.
        ASSIGN accent5 TO <color>.
      WHEN c_accent6.
        ASSIGN accent6 TO <color>.
      WHEN c_hlink.
        ASSIGN hlink TO <color>.
      WHEN c_folhlink.
        ASSIGN folhlink TO <color>.
    ENDCASE.
    CHECK <color> IS ASSIGNED.
    CLEAR <color>.
    IF iv_srgb IS NOT INITIAL.
      <color>-srgb = iv_srgb.
    ELSE.
      <color>-syscolor-val = iv_syscolorname.
      IF iv_syscolorlast IS NOT INITIAL.
        <color>-syscolor-lastclr = iv_syscolorlast.
      ELSE.
        <color>-syscolor-lastclr = '000000'.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "set_color
  METHOD set_defaults.
    name = 'Office'.
    dark1-syscolor-val = 'windowText'.
    dark1-syscolor-lastclr = '000000'.
    light1-syscolor-val = 'window'.
    light1-syscolor-lastclr = 'FFFFFF'.
    dark2-srgb = '44546A'.
    light2-srgb = 'E7E6E6'.
    accent1-srgb = '5B9BD5'.
    accent2-srgb = 'ED7D31'.
    accent3-srgb = 'A5A5A5'.
    accent4-srgb = 'FFC000'.
    accent5-srgb = '4472C4'.
    accent6-srgb = '70AD47'.
    hlink-srgb   = '0563C1'.
    folhlink-srgb = '954F72'.
  ENDMETHOD.                    "set_defaults
  METHOD set_name.
    IF strlen( iv_name ) > 50.
      name = iv_name(50).
    ELSE.
      name = iv_name.
    ENDIF.
  ENDMETHOD.                    "set_name
endclass. "LCL_EXCEL_THEME_COLOR_SCHEME implementation

*>>>>>>> LCL_EXCEL_THEME_FMT_SCHEME <<<<<<<*

*"* macro definitions
*include Lcl_excel_theme_fmt_scheme====ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_theme_fmt_scheme====ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


*"* test class
*include Lcl_excel_theme_fmt_scheme====ccau.



class LCL_EXCEL_THEME_FMT_SCHEME implementation.
*"* method's implementations
*include methods.
  METHOD build_xml.
    DATA: lo_node TYPE REF TO if_ixml_node.
    DATA: lo_elements TYPE REF TO if_ixml_element.
    CHECK io_document IS BOUND.
    lo_elements ?= io_document->find_from_name_ns( name = Lcl_excel_theme=>c_theme_elements ).
    IF lo_elements IS BOUND.

      IF fmt_scheme IS INITIAL.
        lo_node = parse_string( get_default_fmt( ) ).
        lo_elements->append_child( new_child = lo_node ).
      ELSE.
        lo_elements->append_child( new_child = fmt_scheme ).
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "build_xml
  METHOD get_default_fmt.
    CONCATENATE    '<a:fmtScheme name="Office">'
    '      <a:fillStyleLst>'
    '        <a:solidFill>'
    '          <a:schemeClr val="phClr"/>'
    '        </a:solidFill>'
    '        <a:gradFill rotWithShape="1">'
    '          <a:gsLst>'
    '            <a:gs pos="0">'
    '              <a:schemeClr val="phClr">'
    '                <a:lumMod val="110000"/>'
    '                <a:satMod val="105000"/>'
    '                <a:tint val="67000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '            <a:gs pos="50000">'
    '              <a:schemeClr val="phClr">'
    '                <a:lumMod val="105000"/>'
    '                <a:satMod val="103000"/>'
    '                <a:tint val="73000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '            <a:gs pos="100000">'
    '              <a:schemeClr val="phClr">'
    '                <a:lumMod val="105000"/>'
    '                <a:satMod val="109000"/>'
    '                <a:tint val="81000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '          </a:gsLst>'
    '          <a:lin ang="5400000" scaled="0"/>'
    '        </a:gradFill>'
    '        <a:gradFill rotWithShape="1">'
    '          <a:gsLst>'
    '            <a:gs pos="0">'
    '              <a:schemeClr val="phClr">'
    '                <a:satMod val="103000"/>'
    '                <a:lumMod val="102000"/>'
    '                <a:tint val="94000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '            <a:gs pos="50000">'
    '              <a:schemeClr val="phClr">'
    '                <a:satMod val="110000"/>'
    '                <a:lumMod val="100000"/>'
    '                <a:shade val="100000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '            <a:gs pos="100000">'
    '              <a:schemeClr val="phClr">'
    '                <a:lumMod val="99000"/>'
    '                <a:satMod val="120000"/>'
    '                <a:shade val="78000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '          </a:gsLst>'
    '          <a:lin ang="5400000" scaled="0"/>'
    '        </a:gradFill>'
    '      </a:fillStyleLst>'
    '      <a:lnStyleLst>'
    '        <a:ln w="6350" cap="flat" cmpd="sng" algn="ctr">'
    '          <a:solidFill>'
    '            <a:schemeClr val="phClr"/>'
    '          </a:solidFill>'
    '          <a:prstDash val="solid"/>'
    '          <a:miter lim="800000"/>'
    '        </a:ln>'
    '        <a:ln w="12700" cap="flat" cmpd="sng" algn="ctr">'
    '          <a:solidFill>'
    '            <a:schemeClr val="phClr"/>'
    '          </a:solidFill>'
    '          <a:prstDash val="solid"/>'
    '          <a:miter lim="800000"/>'
    '        </a:ln>'
    '        <a:ln w="19050" cap="flat" cmpd="sng" algn="ctr">'
    '          <a:solidFill>'
    '            <a:schemeClr val="phClr"/>'
    '          </a:solidFill>'
    '          <a:prstDash val="solid"/>'
    '          <a:miter lim="800000"/>'
    '        </a:ln>'
    '      </a:lnStyleLst>'
    '      <a:effectStyleLst>'
    '        <a:effectStyle>'
    '          <a:effectLst/>'
    '        </a:effectStyle>'
    '        <a:effectStyle>'
    '          <a:effectLst/>'
    '        </a:effectStyle>'
    '        <a:effectStyle>'
    '          <a:effectLst>'
    '            <a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0">'
    '              <a:srgbClr val="000000">'
    '                <a:alpha val="63000"/>'
    '              </a:srgbClr>'
    '            </a:outerShdw>'
    '          </a:effectLst>'
    '        </a:effectStyle>'
    '      </a:effectStyleLst>'
    '      <a:bgFillStyleLst>'
    '        <a:solidFill>'
    '          <a:schemeClr val="phClr"/>'
    '        </a:solidFill>'
    '        <a:solidFill>'
    '          <a:schemeClr val="phClr">'
    '            <a:tint val="95000"/>'
    '            <a:satMod val="170000"/>'
    '          </a:schemeClr>'
    '        </a:solidFill>'
    '        <a:gradFill rotWithShape="1">'
    '          <a:gsLst>'
    '            <a:gs pos="0">'
    '              <a:schemeClr val="phClr">'
    '                <a:tint val="93000"/>'
    '                <a:satMod val="150000"/>'
    '                <a:shade val="98000"/>'
    '                <a:lumMod val="102000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '            <a:gs pos="50000">'
    '              <a:schemeClr val="phClr">'
    '                <a:tint val="98000"/>'
    '                <a:satMod val="130000"/>'
    '                <a:shade val="90000"/>'
    '                <a:lumMod val="103000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '            <a:gs pos="100000">'
    '              <a:schemeClr val="phClr">'
    '                <a:shade val="63000"/>'
    '                <a:satMod val="120000"/>'
    '              </a:schemeClr>'
    '            </a:gs>'
    '          </a:gsLst>'
    '          <a:lin ang="5400000" scaled="0"/>'
    '        </a:gradFill>'
    '      </a:bgFillStyleLst>'
    '    </a:fmtScheme>'
    INTO rv_string .
  ENDMETHOD.                    "get_default_fmt
  METHOD load.
    fmt_scheme = Lcl_excel_common=>clone_ixml_with_namespaces( io_fmt_scheme ).
  ENDMETHOD.                    "load
  METHOD parse_string.
    DATA li_stream   TYPE REF TO if_ixml_istream.
    DATA li_ixml     TYPE REF TO if_ixml.
    DATA li_document TYPE REF TO if_ixml_document.
    DATA li_factory  TYPE REF TO if_ixml_stream_factory.
    DATA li_parser   TYPE REF TO if_ixml_parser.
    DATA li_istream  TYPE REF TO if_ixml_istream.

    li_ixml = cl_ixml=>create( ).
    li_document = li_ixml->create_document( ).
    li_factory = li_ixml->create_stream_factory( ).
    li_istream = li_factory->create_istream_string( iv_string ).
    li_parser = li_ixml->create_parser(
      stream_factory = li_factory
      istream        = li_istream
      document       = li_document ).
    li_parser->add_strip_space_element( ).
    li_parser->parse( ).
    li_istream->close( ).
    ri_node = li_document->get_first_child( ).

  ENDMETHOD.
endclass. "LCL_EXCEL_THEME_FMT_SCHEME implementation

*>>>>>>> LCL_EXCEL_CONVERTER_SALV_MODEL <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter_salv_modelccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter_salv_modelccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER_SALV_MODEL implementation.
*"* method's implementations
*include methods.
  METHOD is_get_metadata_callable.
    DATA: lo_object TYPE REF TO object,
          lo_model  TYPE REF TO cl_salv_model.

    " In 7.52 and older versions, we have a short dump with CL_SALV_TABLE->GET_METADATA if the ALV is not displayed
    "   (due to io_salv->r_controller->r_adapter not instantiated yet). That's later fixed by SAP (no short dump in 7.57).
    "   NB: r_controller is always instantiated.
    lo_object = io_salv.
    TRY.
        lo_model ?= lo_object.
      CATCH cx_sy_move_cast_error.
        " In 7.57, CL_SALV_TABLE is no more a subclass of CL_SALV_MODEL, but CL_SALV_TABLE->GET_METADATA can be called.
        result = abap_true.
        RETURN.
    ENDTRY.
    result = boolc( lo_model->r_controller->r_adapter IS BOUND ).
  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER_SALV_MODEL implementation

*>>>>>>> LCL_EXCEL_CONVERTER_SALV_TABLE <<<<<<<*

*"* macro definitions
*include Lcl_excel_converter_salv_tableccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_converter_salv_tableccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_CONVERTER_SALV_TABLE implementation.
*"* method's implementations
*include methods.
  METHOD is_intercept_data_active.

    DATA: lr_s_type_runtime_info TYPE REF TO data.
    FIELD-SYMBOLS: <ls_type_runtime_info> TYPE any,
                   <lv_display>           TYPE any,
                   <lv_data>              TYPE any.

    rv_result = abap_false.
    TRY.
        CREATE DATA lr_s_type_runtime_info TYPE ('CL_SALV_BS_RUNTIME_INFO=>S_TYPE_RUNTIME_INFO').
        ASSIGN lr_s_type_runtime_info->* TO <ls_type_runtime_info>.
        CALL METHOD ('CL_SALV_BS_RUNTIME_INFO')=>('GET')
          RECEIVING
            value = <ls_type_runtime_info>.
        ASSIGN ('<LS_TYPE_RUNTIME_INFO>-DISPLAY') TO <lv_display>.
        CHECK sy-subrc = 0.
        ASSIGN ('<LS_TYPE_RUNTIME_INFO>-DATA') TO <lv_data>.
        CHECK sy-subrc = 0.
        IF <lv_display> = abap_false AND <lv_data> = abap_true.
          rv_result = abap_true.
        ENDIF.
      CATCH cx_sy_create_data_error cx_sy_dyn_call_error cx_salv_bs_sc_runtime_info.
        rv_result = abap_false.
    ENDTRY.

  ENDMETHOD.
  METHOD load_data.
    DATA: lo_columns      TYPE REF TO cl_salv_columns_table,
          lo_aggregations TYPE REF TO cl_salv_aggregations,
          lo_sorts        TYPE REF TO cl_salv_sorts,
          lo_filters      TYPE REF TO cl_salv_filters,
          lo_functional   TYPE REF TO cl_salv_functional_settings,
          lo_display      TYPE REF TO cl_salv_display_settings.

    DATA: ls_vari   TYPE disvariant,
          lo_layout TYPE REF TO cl_salv_layout.

    DATA lt_kkblo_fieldcat TYPE kkblo_t_fieldcat.
    DATA ls_kkblo_layout   TYPE kkblo_layout.
    DATA lt_kkblo_filter   TYPE kkblo_t_filter.
    DATA lt_kkblo_sort     TYPE kkblo_t_sortinfo.
    DATA: lv_intercept_data_active TYPE abap_bool,
          ls_layout_key            TYPE salv_s_layout_key.

    lo_layout               = io_salv->get_layout( ) .
    lo_columns              = io_salv->get_columns( ).
    lo_aggregations         = io_salv->get_aggregations( ) .
    lo_sorts                = io_salv->get_sorts( ) .
    lo_filters              = io_salv->get_filters( ) .
    lo_display              = io_salv->get_display_settings( ) .
    lo_functional           = io_salv->get_functional_settings( ) .

    CLEAR: wt_fcat, wt_sort, wt_filt.

    lv_intercept_data_active = is_intercept_data_active( ).

* First update metadata if we can.
    IF io_salv->is_offline( ) = abap_false.
      IF lv_intercept_data_active = abap_true.
        ls_layout_key = lo_layout->get_key( ).
        ls_vari-report    = ls_layout_key-report.
        ls_vari-handle    = ls_layout_key-handle.
        ls_vari-log_group = ls_layout_key-logical_group.
        ls_vari-variant   = lo_layout->get_initial_layout( ).
      ELSE.
        IF Lcl_excel_converter_salv_model=>is_get_metadata_callable( io_salv ) = abap_true.
          io_salv->get_metadata( ) .
        ELSE.
          " (do same as offline below)
          cl_salv_controller_metadata=>get_variant(
            EXPORTING
              r_layout  = lo_layout
            CHANGING
              s_variant = ls_vari ).
        ENDIF.
      ENDIF.
    ELSE.
* If we are offline we need to build this.
      cl_salv_controller_metadata=>get_variant(
        EXPORTING
          r_layout  = lo_layout
        CHANGING
          s_variant = ls_vari ).
    ENDIF.

*... get the column information
    wt_fcat = cl_salv_controller_metadata=>get_lvc_fieldcatalog(
                           r_columns      = lo_columns
                           r_aggregations = lo_aggregations ).

*... get the layout information
    cl_salv_controller_metadata=>get_lvc_layout(
      EXPORTING
        r_functional_settings = lo_functional
        r_display_settings    = lo_display
        r_columns             = lo_columns
        r_aggregations        = lo_aggregations
      CHANGING
        s_layout              = ws_layo ).

* the fieldcatalog is not complete yet!
    CALL FUNCTION 'LVC_FIELDCAT_COMPLETE'
      EXPORTING
        i_complete       = 'X'
        i_refresh_buffer = space
        i_buffer_active  = space
        is_layout        = ws_layo
        i_test           = '1'
        i_fcat_complete  = 'X'
      IMPORTING
        es_layout        = ws_layo
      CHANGING
        ct_fieldcat      = wt_fcat.

    IF ls_vari IS NOT INITIAL AND
        ( io_salv->is_offline( ) = abap_true
          OR lv_intercept_data_active = abap_true ).
      CALL FUNCTION 'LVC_TRANSFER_TO_KKBLO'
        EXPORTING
          it_fieldcat_lvc         = wt_fcat
          is_layout_lvc           = ws_layo
        IMPORTING
          et_fieldcat_kkblo       = lt_kkblo_fieldcat
          es_layout_kkblo         = ls_kkblo_layout
        TABLES
          it_data                 = it_table
        EXCEPTIONS
          it_data_missing         = 1
          it_fieldcat_lvc_missing = 2
          OTHERS                  = 3.
      IF sy-subrc <> 0.
      ENDIF.

      CALL FUNCTION 'LT_VARIANT_LOAD'
        EXPORTING
          i_tabname           = '1'
          i_dialog            = ' '
          i_user_specific     = 'X'
          i_fcat_complete     = 'X'
        IMPORTING
          et_fieldcat         = lt_kkblo_fieldcat
          et_sort             = lt_kkblo_sort
          et_filter           = lt_kkblo_filter
        CHANGING
          cs_layout           = ls_kkblo_layout
          ct_default_fieldcat = lt_kkblo_fieldcat
          cs_variant          = ls_vari
        EXCEPTIONS
          wrong_input         = 1
          fc_not_complete     = 2
          not_found           = 3
          OTHERS              = 4.
      IF sy-subrc <> 0.
      ENDIF.

      CALL FUNCTION 'LVC_TRANSFER_FROM_KKBLO'
        EXPORTING
          it_fieldcat_kkblo = lt_kkblo_fieldcat
          it_sort_kkblo     = lt_kkblo_sort
          it_filter_kkblo   = lt_kkblo_filter
          is_layout_kkblo   = ls_kkblo_layout
        IMPORTING
          et_fieldcat_lvc   = wt_fcat
          et_sort_lvc       = wt_sort
          et_filter_lvc     = wt_filt
          es_layout_lvc     = ws_layo
        TABLES
          it_data           = it_table
        EXCEPTIONS
          it_data_missing   = 1
          OTHERS            = 2.
      IF sy-subrc <> 0.
      ENDIF.

    ELSE.
*  ... get the sort information
      wt_sort = cl_salv_controller_metadata=>get_lvc_sort( lo_sorts ).

*  ... get the filter information
      wt_filt = cl_salv_controller_metadata=>get_lvc_filter( lo_filters ).
    ENDIF.

  ENDMETHOD.
  METHOD Lif_excel_converter~can_convert_object.

    DATA: lo_salv TYPE REF TO cl_salv_table.

    TRY.
        lo_salv ?= io_object.
      CATCH cx_sy_move_cast_error .
        RAISE EXCEPTION TYPE Lcx_excel.
    ENDTRY.

  ENDMETHOD.
  METHOD Lif_excel_converter~create_fieldcatalog.
    DATA: lo_salv TYPE REF TO cl_salv_table.

    Lif_excel_converter~can_convert_object( io_object = io_object ).

    ws_option = is_option.

    lo_salv ?= io_object.

    CLEAR: es_layout,
           et_fieldcatalog,
           et_colors .

    IF lo_salv IS BOUND.
      load_data( EXPORTING io_salv   = lo_salv
                           it_table  = it_table ).
      apply_sort( EXPORTING it_table = it_table
                  IMPORTING eo_table = eo_table ) .

      get_color( EXPORTING io_table    = eo_table
                 IMPORTING et_colors   = et_colors ) .

      get_filter( IMPORTING et_filter  = et_filter
                  CHANGING  xo_table   = eo_table ) .

      update_catalog( CHANGING  cs_layout       = es_layout
                                ct_fieldcatalog = et_fieldcatalog ).
    ENDIF.
  ENDMETHOD.
  METHOD Lif_excel_converter~get_supported_class.
    rv_supported_class = 'CL_SALV_TABLE'.
  ENDMETHOD.
endclass. "LCL_EXCEL_CONVERTER_SALV_TABLE implementation

*>>>>>>> LCL_EXCEL_OLE <<<<<<<*

*--------------------------------------------------------------------*
* CLASS SHRITEFUH64VYIPN5I4UIDBJAA5SE4
*--------------------------------------------------------------------*
* to get protected attribute and method of cl_gui_alv_grid
* use for method bind_ALV
*--------------------------------------------------------------------*
CLASS SHRITEFUH64VYIPN5I4UIDBJAA5SE4 DEFINITION INHERITING FROM cl_gui_alv_grid.

  PUBLIC SECTION.
* get ALV grid data
    METHODS: get_alv_attributes
      IMPORTING
        io_grid   TYPE REF TO cl_gui_alv_grid " ALV grid
      EXPORTING
        et_table  TYPE REF TO data.           " dta table

ENDCLASS.                    "SHRITEFUH64VYIPN5I4UIDBJAA5SE4 DEFINITION

*"* class LCL_EXCEL_OLE definition
*"* public declarations
*include Lcl_excel_ole=================cu.
CLASS Lcl_excel_ole DEFINITION
*public
  FINAL
  CREATE PUBLIC .

  PUBLIC SECTION.
    TYPES ty_doc_url TYPE c LENGTH 255.

    CLASS-METHODS bind_alv_ole2
      IMPORTING
        !i_document_url      TYPE ty_doc_url DEFAULT space
        !i_xls               TYPE c DEFAULT space
        !i_save_path         TYPE string
        !io_alv              TYPE REF TO cl_gui_alv_grid
        !it_listheader       TYPE slis_t_listheader OPTIONAL
        !i_top               TYPE i DEFAULT 1
        !i_left              TYPE i DEFAULT 1
        !i_columns_header    TYPE c DEFAULT 'X'
        !i_columns_autofit   TYPE c DEFAULT 'X'
        !i_format_col_header TYPE soi_format_item OPTIONAL
        !i_format_subtotal   TYPE soi_format_item OPTIONAL
        !i_format_total      TYPE soi_format_item OPTIONAL
      EXCEPTIONS
        miss_guide
        ex_transfer_kkblo_error
        fatal_error
        inv_data_range
        dim_mismatch_vkey
        dim_mismatch_sema
        error_in_sema .

*"* protected declarations
*include Lcl_excel_ole=================co.
  PROTECTED SECTION.
*"* private declarations
*include Lcl_excel_ole=================ci.
  PRIVATE SECTION.

    CLASS-METHODS close_document.
    CLASS-METHODS error_doi.

    CLASS-DATA: lo_spreadsheet TYPE REF TO i_oi_spreadsheet,
                lo_control     TYPE REF TO i_oi_container_control,
                lo_proxy       TYPE REF TO i_oi_document_proxy,
                lo_error       TYPE REF TO i_oi_error,
                lc_retcode     TYPE        soi_ret_string.

endclass. "LCL_EXCEL_OLE definition

*"* macro definitions
*include Lcl_excel_ole=================ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_ole=================ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations

*&---------------------------------------------------------------------*
*&       Class (Implementation)  SHRITEFUH64VYIPN5I4UIDBJAA4SE4
*&---------------------------------------------------------------------*
CLASS SHRITEFUH64VYIPN5I4UIDBJAA4SE4 IMPLEMENTATION.
  METHOD constructor.
*                IMPORTING object_name TYPE c
*                          method_name TYPE c.
    error_nr = ret_call_not_flushed.
    me->i_oi_error~error_code = c_oi_errors=>ret_call_not_flushed.
    me->i_oi_error~is_flushed = ' '.
    me->i_oi_error~has_failed = 'X'.
    me->i_oi_error~has_succeeded = ' '.
    me->message_id = 'SOFFICEINTEGRATION'.
    me->message_nr = '899'.
    me->param1 = object_name.
    me->param2 = method_name.
  ENDMETHOD.                    "constructor

  METHOD i_oi_error~flush_error.
    IF error_nr EQ 0.
      me->i_oi_error~error_code = c_oi_errors=>ret_ok.
      me->i_oi_error~is_flushed = 'X'.
      me->i_oi_error~has_failed = ' '.
      me->i_oi_error~has_succeeded = 'X'.
      me->message_id = ''.
      me->message_nr = '000'.
      CALL METHOD c_oi_errors=>translate_proxy_error_code
        EXPORTING
          errorcode = error_nr
        IMPORTING
          retcode   = me->i_oi_error~error_code.
    ELSEIF error_nr EQ ret_call_not_flushed.
      "call still not flushed
      CALL METHOD c_oi_errors=>translate_proxy_error_code
        EXPORTING
          errorcode   = error_nr
          errorstring = me->param2  "method name
          objectname  = me->param1
        IMPORTING
          retcode     = me->i_oi_error~error_code.
    ELSE.
      me->i_oi_error~is_flushed = 'X'.
      me->i_oi_error~has_succeeded = ' '.
      me->i_oi_error~has_failed = 'X'.
      CALL METHOD c_oi_errors=>translate_proxy_error_code
        EXPORTING
          errorcode   = error_nr
          errorstring = error_string
        IMPORTING
          retcode     = me->i_oi_error~error_code.
      CALL METHOD c_oi_errors=>get_message
        IMPORTING
          message_id     = me->message_id
          message_number = me->message_nr
          param1         = me->param1
          param2         = me->param2
          param3         = me->param3
          param4         = me->param4.
    ENDIF.
  ENDMETHOD.                    "i_oi_error~flush_error

  METHOD i_oi_error~raise_message.
*                         IMPORTING type TYPE c.
*                         EXCEPTIONS message_raised flush_failed.
    IF me->i_oi_error~has_succeeded IS INITIAL.
      IF NOT me->i_oi_error~is_flushed IS INITIAL.
        MESSAGE ID message_id TYPE type
            NUMBER message_nr WITH param1 param2 param3 param4
            RAISING message_raised.
      ELSE.
        RAISE flush_failed.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "i_oi_error~raise_message

  METHOD i_oi_error~get_message.
*                    EXPORTING message_id TYPE c
*                              message_number TYPE c
*                              param1 TYPE c
*                              param2 TYPE c
*                              param3 TYPE c
*                              param4 TYPE c.
    param1 = me->param1. param2 = me->param2.
    param3 = me->param3. param4 = me->param4.

    message_id = me->message_id.
    message_number = me->message_nr.
  ENDMETHOD.                    "i_oi_error~get_message
ENDCLASS.               "SHRITEFUH64VYIPN5I4UIDBJAA4SE4

*&---------------------------------------------------------------------*
*&       Class (Implementation)  CL_GRID_ACCESSION
*&---------------------------------------------------------------------*
CLASS SHRITEFUH64VYIPN5I4UIDBJAA5SE4 IMPLEMENTATION.

  METHOD get_alv_attributes.
    CREATE DATA et_table LIKE io_grid->mt_outtab.
    et_table = io_grid->mt_outtab.
  ENDMETHOD.                    "get_data

ENDCLASS.               "CL_GRID_ACCESSION

class LCL_EXCEL_OLE implementation.
*"* method's implementations
*include methods.
  METHOD bind_alv_ole2.
*--------------------------------------------------------------------*
* Method description:
*   Method use to export a CL_GUI_ALV_GRID object to xlsx/xls file
*   with list header and  characteristics of ALV field catalog such as:
*     + Total, group's subtotal
*     + Quantity fields, amount fields (dependent fields)
*     + No_out, no_zero, ...
* Technique use in method:
*   SAP Desktop Office Integration (DOI)
*--------------------------------------------------------------------*

* Data for session 0: DOI constructor
* ------------------------------------------

    DATA: li_has      TYPE i. "Proxy has spreadsheet interface?

* Data for session 1: Get LVC data from ALV object
* ------------------------------------------

    DATA: l_has_activex,
          l_doctype_excel_sheet(11) TYPE c.

* LVC
    DATA: lt_fieldcat_lvc       TYPE lvc_t_fcat.
    DATA: wa_fieldcat_lvc       TYPE lvc_s_fcat.
    DATA: lt_sort_lvc           TYPE lvc_t_sort.
    DATA: lt_filter_idx_lvc     TYPE lvc_t_fidx.
    DATA: lt_grouplevels_lvc    TYPE lvc_t_grpl.

* KKBLO
    DATA: lt_fieldcat_kkblo     TYPE  kkblo_t_fieldcat.
    DATA: lt_sort_kkblo         TYPE  kkblo_t_sortinfo.
    DATA: lt_grouplevels_kkblo  TYPE  kkblo_t_grouplevels.
    DATA: lt_filter_idx_kkblo   TYPE  kkblo_t_sfinfo.
    DATA: wa_listheader         LIKE LINE OF it_listheader.

* Subtotal
    DATA: lt_collect00          TYPE REF TO data.
    DATA: lt_collect01          TYPE REF TO data.
    DATA: lt_collect02          TYPE REF TO data.
    DATA: lt_collect03          TYPE REF TO data.
    DATA: lt_collect04          TYPE REF TO data.
    DATA: lt_collect05          TYPE REF TO data.
    DATA: lt_collect06          TYPE REF TO data.
    DATA: lt_collect07          TYPE REF TO data.
    DATA: lt_collect08          TYPE REF TO data.
    DATA: lt_collect09          TYPE REF TO data.

* data table name
    DATA: l_tabname             TYPE  kkblo_tabname.

* local object
    DATA: lo_grid               TYPE REF TO SHRITEFUH64VYIPN5I4UIDBJAA5SE4.

* data table get from ALV
    DATA: lt_alv                  TYPE REF TO data.

* total / subtotal data
    FIELD-SYMBOLS: <f_collect00>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect01>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect02>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect03>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect04>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect05>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect06>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect07>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect08>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect09>  TYPE STANDARD TABLE.

* table before append subtotal lines
    FIELD-SYMBOLS: <f_alv_tab>    TYPE STANDARD TABLE.

* data for session 2: sort, filter and calculate total/subtotal
* ------------------------------------------

* table to save index of subotal / total line in excel tanle
* this ideal to control index of subtotal / total line later
* for ex, when get subtotal / total line to format
    TYPES: BEGIN OF st_subtot_indexs,
             index TYPE i,
           END OF st_subtot_indexs.
    DATA: lt_subtot_indexs TYPE TABLE OF st_subtot_indexs.
    DATA: wa_subtot_indexs LIKE LINE OF lt_subtot_indexs.

* data table after append subtotal
    DATA: lt_excel                TYPE REF TO data.

    DATA: l_tabix                 TYPE i.
    DATA: l_save_index            TYPE i.

* dyn subtotal table name
    DATA: l_collect               TYPE string.

* subtotal range, to format subtotal (and total)
    DATA: subranges               TYPE soi_range_list.
    DATA: subrangeitem            TYPE soi_range_item.
    DATA: l_sub_index             TYPE i.


* table after append subtotal lines
    FIELD-SYMBOLS: <f_excel_tab>  TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_excel_line> TYPE any.

* dyn subtotal tables
    FIELD-SYMBOLS: <f_collect_tab>      TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <f_collect_line>     TYPE any.

    FIELD-SYMBOLS: <f_filter_idx_line>  LIKE LINE OF lt_filter_idx_kkblo.
    FIELD-SYMBOLS: <f_fieldcat_line>    LIKE LINE OF lt_fieldcat_kkblo.
    FIELD-SYMBOLS: <f_grouplevels_line> LIKE LINE OF lt_grouplevels_kkblo.
    FIELD-SYMBOLS: <f_line>             TYPE any.

* Data for session 3: map data to semantic table
* ------------------------------------------

    TYPES: BEGIN OF st_column_index,
             fieldname TYPE kkblo_fieldname,
             tabname   TYPE kkblo_tabname,
             col       LIKE sy-index,
           END OF st_column_index.

* columns index
    DATA: lt_column_index   TYPE TABLE OF st_column_index.
    DATA: wa_column_index   LIKE LINE OF lt_column_index.

* table of dependent field ( currency and quantity unit field)
    DATA: lt_fieldcat_depf  TYPE kkblo_t_fieldcat.
    DATA: wa_fieldcat_depf  TYPE kkblo_fieldcat.

* XXL interface:
* -XXL: contain exporting columns characteristic
    DATA: lt_sema TYPE TABLE OF gxxlt_s INITIAL SIZE 0.
    DATA: wa_sema LIKE LINE OF lt_sema.

* -XXL interface: header
    DATA: lt_hkey TYPE TABLE OF gxxlt_h INITIAL SIZE 0.
    DATA: wa_hkey LIKE LINE OF lt_hkey.

* -XXL interface: header keys
    DATA: lt_vkey TYPE TABLE OF gxxlt_v INITIAL SIZE 0.
    DATA: wa_vkey LIKE LINE OF lt_vkey.

* Number of H Keys: number of key columns
    DATA: l_n_hrz_keys      TYPE  i.
* Number of data columns in the list object: non-key columns no
    DATA: l_n_att_cols      TYPE  i.
* Number of V Keys: number of header row
    DATA: l_n_vrt_keys      TYPE  i.

* curency to format amount
    DATA: lt_tcurx          TYPE TABLE OF tcurx.
    DATA: wa_tcurx          LIKE LINE OF lt_tcurx.
    DATA: l_def             TYPE flag. " currency / quantity flag
    DATA: wa_t006           TYPE t006. " decimal place of unit

    DATA: l_num             TYPE i. " table columns number
    DATA: l_typ             TYPE c. " table type
    DATA: wa                TYPE REF TO data.
    DATA: l_int             TYPE i.
    DATA: l_counter         TYPE i.

    FIELD-SYMBOLS: <f_excel_column>     TYPE any.
    FIELD-SYMBOLS: <f_fcat_column>      TYPE any.

* Data for session 4: write to excel
* ------------------------------------------

    DATA: sema_type         TYPE  c.

    DATA l_error           TYPE REF TO SHRITEFUH64VYIPN5I4UIDBJAA4SE4.
    DATA count              TYPE i.
    DATA datac              TYPE i.
    DATA datareal TYPE i. " exporting column number
    DATA vkeycount          TYPE i.
    DATA all TYPE i.
    DATA mit TYPE i         VALUE 1.  " index of recent row?
    DATA li_col_pos TYPE i  VALUE 1.  " column position
    DATA li_col_num TYPE i.           " table columns number
    FIELD-SYMBOLS: <line>   TYPE any.
    FIELD-SYMBOLS: <item>   TYPE any.

    DATA td                 TYPE sydes_desc.

    DATA: typ.
    DATA: ranges             TYPE soi_range_list.
    DATA: rangeitem          TYPE soi_range_item.
    DATA: contents           TYPE soi_generic_table.
    DATA: contentsitem       TYPE soi_generic_item.
    DATA: semaitem           TYPE gxxlt_s.
    DATA: hkeyitem           TYPE gxxlt_h.
    DATA: vkeyitem           TYPE gxxlt_v.
    DATA: li_commentary_rows TYPE i.  "row number of title lines + 1
    DATA: lo_error_w         TYPE REF TO  i_oi_error.
    DATA: l_retcode          TYPE soi_ret_string.
    DATA: no_flush           TYPE c VALUE 'X'.
    DATA: li_head_top        TYPE i. "header rows position

* Data for session 5: Save and clode document
* ------------------------------------------

    DATA: li_document_size   TYPE i.
    DATA: ls_path            TYPE rlgrap-filename.

*--------------------------------------------------------------------*
* SESSION 0: DOI CONSTRUCTOR
*--------------------------------------------------------------------*

* check active windown

    CALL FUNCTION 'GUI_HAS_ACTIVEX'
      IMPORTING
        return = l_has_activex.

    IF l_has_activex IS INITIAL.
      RAISE miss_guide.
    ENDIF.

*   Get Container Object of Screen

    CALL METHOD c_oi_container_control_creator=>get_container_control
      IMPORTING
        control = lo_control
        retcode = lc_retcode.

    error_doi( ).

* Initialize Container control

    CALL METHOD lo_control->init_control
      EXPORTING
        parent                   = cl_gui_container=>default_screen
        r3_application_name      = ''
        inplace_enabled          = 'X'
        no_flush                 = 'X'
        register_on_close_event  = 'X'
        register_on_custom_event = 'X'
      IMPORTING
        error                    = lo_error
        retcode                  = lc_retcode.

    error_doi( ).

* Get Proxy Document:
* check exist of document proxy, if exist -> close first

    IF NOT lo_proxy IS INITIAL.
      close_document( ).
    ENDIF.

    IF i_xls IS NOT INITIAL.
* xls format, doctype = soi_doctype_excel97_sheet
      l_doctype_excel_sheet = 'Excel.Sheet.8'.
    ELSE.
* xlsx format, doctype = soi_doctype_excel_sheet
      l_doctype_excel_sheet = 'Excel.Sheet'.
    ENDIF.

    CALL METHOD lo_control->get_document_proxy
      EXPORTING
        document_type      = l_doctype_excel_sheet
        register_container = 'X'
      IMPORTING
        document_proxy     = lo_proxy
        error              = lo_error
        retcode            = lc_retcode.

    error_doi( ).

    IF i_document_url IS INITIAL.

* create new excel document

      CALL METHOD lo_proxy->create_document
        EXPORTING
          create_view_data = 'X'
          open_inplace     = 'X'
          no_flush         = 'X'
        IMPORTING
          error            = lo_error
          retcode          = lc_retcode.

      error_doi( ).

    ELSE.

* Read excel template for i_DOCUMENT_URL
* this excel template can be store in local or server

      CALL METHOD lo_proxy->open_document
        EXPORTING
          document_url = i_document_url
          open_inplace = 'X'
          no_flush     = 'X'
        IMPORTING
          error        = lo_error
          retcode      = lc_retcode.

      error_doi( ).

    ENDIF.

* Check Spreadsheet Interface of Document Proxy

    CALL METHOD lo_proxy->has_spreadsheet_interface
      IMPORTING
        is_available = li_has
        error        = lo_error
        retcode      = lc_retcode.

    error_doi( ).

* create Spreadsheet object

    CHECK li_has IS NOT INITIAL.

    CALL METHOD lo_proxy->get_spreadsheet_interface
      IMPORTING
        sheet_interface = lo_spreadsheet
        error           = lo_error
        retcode         = lc_retcode.

    error_doi( ).

*--------------------------------------------------------------------*
* SESSION 1: GET LVC DATA FROM ALV OBJECT
*--------------------------------------------------------------------*

* data table

    CREATE OBJECT lo_grid
      EXPORTING
        i_parent = cl_gui_container=>screen0.

    CALL METHOD lo_grid->get_alv_attributes
      EXPORTING
        io_grid  = io_alv
      IMPORTING
        et_table = lt_alv.

    ASSIGN lt_alv->* TO <f_alv_tab>.

* fieldcat

    CALL METHOD io_alv->get_frontend_fieldcatalog
      IMPORTING
        et_fieldcatalog = lt_fieldcat_lvc.

* table name

    LOOP AT lt_fieldcat_lvc INTO wa_fieldcat_lvc
    WHERE NOT tabname IS INITIAL.
      l_tabname = wa_fieldcat_lvc-tabname.
      EXIT.
    ENDLOOP.

    IF sy-subrc NE 0.
      l_tabname = '1'.
    ENDIF.
    CLEAR: wa_fieldcat_lvc.

* sort table

    CALL METHOD io_alv->get_sort_criteria
      IMPORTING
        et_sort = lt_sort_lvc.


* filter index

    CALL METHOD io_alv->get_filtered_entries
      IMPORTING
        et_filtered_entries = lt_filter_idx_lvc.

* group level + subtotal

    CALL METHOD io_alv->get_subtotals
      IMPORTING
        ep_collect00   = lt_collect00
        ep_collect01   = lt_collect01
        ep_collect02   = lt_collect02
        ep_collect03   = lt_collect03
        ep_collect04   = lt_collect04
        ep_collect05   = lt_collect05
        ep_collect06   = lt_collect06
        ep_collect07   = lt_collect07
        ep_collect08   = lt_collect08
        ep_collect09   = lt_collect09
        et_grouplevels = lt_grouplevels_lvc.

    ASSIGN lt_collect00->* TO <f_collect00>.
    ASSIGN lt_collect01->* TO <f_collect01>.
    ASSIGN lt_collect02->* TO <f_collect02>.
    ASSIGN lt_collect03->* TO <f_collect03>.
    ASSIGN lt_collect04->* TO <f_collect04>.
    ASSIGN lt_collect05->* TO <f_collect05>.
    ASSIGN lt_collect06->* TO <f_collect06>.
    ASSIGN lt_collect07->* TO <f_collect07>.
    ASSIGN lt_collect08->* TO <f_collect08>.
    ASSIGN lt_collect09->* TO <f_collect09>.

* transfer to KKBLO struct

    CALL FUNCTION 'LVC_TRANSFER_TO_KKBLO'
      EXPORTING
        it_fieldcat_lvc           = lt_fieldcat_lvc
        it_sort_lvc               = lt_sort_lvc
        it_filter_index_lvc       = lt_filter_idx_lvc
        it_grouplevels_lvc        = lt_grouplevels_lvc
      IMPORTING
        et_fieldcat_kkblo         = lt_fieldcat_kkblo
        et_sort_kkblo             = lt_sort_kkblo
        et_filtered_entries_kkblo = lt_filter_idx_kkblo
        et_grouplevels_kkblo      = lt_grouplevels_kkblo
      TABLES
        it_data                   = <f_alv_tab>
      EXCEPTIONS
        it_data_missing           = 1
        it_fieldcat_lvc_missing   = 2
        OTHERS                    = 3.
    IF sy-subrc <> 0.
      RAISE ex_transfer_kkblo_error.
    ENDIF.

    CLEAR:
      wa_fieldcat_lvc,
      lt_fieldcat_lvc,
      lt_sort_lvc,
      lt_filter_idx_lvc,
      lt_grouplevels_lvc.

    CLEAR:
      lo_grid.


*--------------------------------------------------------------------*
* SESSION 2: SORT, FILTER AND CALCULATE TOTAL / SUBTOTAL
*--------------------------------------------------------------------*

* append subtotal & total line

    CREATE DATA lt_excel LIKE <f_alv_tab>.
    ASSIGN lt_excel->* TO <f_excel_tab>.

    LOOP AT <f_alv_tab> ASSIGNING <f_line>.
      l_save_index = sy-tabix.

* filter base on filter index table

      READ TABLE lt_filter_idx_kkblo ASSIGNING <f_filter_idx_line>
      WITH KEY index = l_save_index
      BINARY SEARCH.
      IF sy-subrc NE 0.
        APPEND <f_line> TO <f_excel_tab>.
      ENDIF.

* append subtotal lines

      READ TABLE lt_grouplevels_kkblo ASSIGNING <f_grouplevels_line>
      WITH KEY index_to = l_save_index
      BINARY SEARCH.
      IF sy-subrc = 0.
        l_tabix = sy-tabix.
        DO.
          IF <f_grouplevels_line>-subtot EQ 'X' AND
             <f_grouplevels_line>-hide_level IS INITIAL AND
             <f_grouplevels_line>-cindex_from NE 0.

* dynamic append subtotal line to excel table base on grouplevel table
* ex <f_GROUPLEVELS_line>-level = 1
* then <f_collect_tab> = '<F_COLLECT01>'

            l_collect = <f_grouplevels_line>-level.
            CONDENSE l_collect.
            CONCATENATE '<F_COLLECT0'
                        l_collect '>'
*                      '->*'
                        INTO l_collect.

            ASSIGN (l_collect) TO <f_collect_tab>.

* incase there're more than 1 total line of group, at the same level
* for example: subtotal of multi currency

            LOOP AT <f_collect_tab> ASSIGNING <f_collect_line>.
              IF  sy-tabix BETWEEN <f_grouplevels_line>-cindex_from
                              AND  <f_grouplevels_line>-cindex_to.


                APPEND <f_collect_line> TO <f_excel_tab>.

* save subtotal lines index

                wa_subtot_indexs-index = sy-tabix.
                APPEND wa_subtot_indexs TO lt_subtot_indexs.

* append sub total ranges table for format later

                ADD 1 TO l_sub_index.
                subrangeitem-name     =  l_sub_index.
                CONDENSE subrangeitem-name.
                CONCATENATE 'SUBTOT'
                            subrangeitem-name
                            INTO subrangeitem-name.

                subrangeitem-rows     = wa_subtot_indexs-index.
                subrangeitem-columns  = 1.            " start col
                APPEND subrangeitem TO subranges.
                CLEAR: subrangeitem.

              ENDIF.
            ENDLOOP.
            UNASSIGN: <f_collect_tab>.
            UNASSIGN: <f_collect_line>.
            CLEAR: l_collect.
          ENDIF.

* check next subtotal level of group

          UNASSIGN: <f_grouplevels_line>.
          ADD 1 TO l_tabix.

          READ TABLE lt_grouplevels_kkblo ASSIGNING <f_grouplevels_line>
          INDEX l_tabix.
          IF sy-subrc NE 0
          OR <f_grouplevels_line>-index_to NE l_save_index.
            EXIT.
          ENDIF.

          UNASSIGN:
            <f_collect_tab>,
            <f_collect_line>.

        ENDDO.
      ENDIF.

      CLEAR:
        l_tabix,
        l_save_index.

      UNASSIGN:
        <f_filter_idx_line>,
        <f_grouplevels_line>.

    ENDLOOP.

* free local data

    UNASSIGN:
      <f_line>,
      <f_collect_tab>,
      <f_collect_line>,
      <f_fieldcat_line>.

* append grand total line

    IF <f_collect00> IS ASSIGNED.
      ASSIGN <f_collect00> TO <f_collect_tab>.
      IF <f_collect_tab> IS NOT INITIAL.
        LOOP AT <f_collect_tab> ASSIGNING <f_collect_line>.

          APPEND <f_collect_line> TO <f_excel_tab>.

* save total line index

          wa_subtot_indexs-index = sy-tabix.
          APPEND wa_subtot_indexs TO lt_subtot_indexs.

* append grand total range (to format)

          ADD 1 TO l_sub_index.
          subrangeitem-name     =  l_sub_index.
          CONDENSE subrangeitem-name.
          CONCATENATE 'TOTAL'
                      subrangeitem-name
                      INTO subrangeitem-name.

          subrangeitem-rows     = wa_subtot_indexs-index.
          subrangeitem-columns  = 1.            " start col
          APPEND subrangeitem TO subranges.
        ENDLOOP.
      ENDIF.
    ENDIF.

    CLEAR:
      subrangeitem,
      lt_sort_kkblo,
      <f_collect00>,
      <f_collect01>,
      <f_collect02>,
      <f_collect03>,
      <f_collect04>,
      <f_collect05>,
      <f_collect06>,
      <f_collect07>,
      <f_collect08>,
      <f_collect09>.

    UNASSIGN:
      <f_collect00>,
      <f_collect01>,
      <f_collect02>,
      <f_collect03>,
      <f_collect04>,
      <f_collect05>,
      <f_collect06>,
      <f_collect07>,
      <f_collect08>,
      <f_collect09>,
      <f_collect_tab>,
      <f_collect_line>.

*--------------------------------------------------------------------*
* SESSION 3: MAP DATA TO SEMANTIC TABLE
*--------------------------------------------------------------------*

* get dependent field field: currency and quantity

    CREATE DATA wa LIKE LINE OF <f_excel_tab>.
    ASSIGN wa->* TO <f_excel_line>.

    DESCRIBE FIELD <f_excel_line> TYPE l_typ COMPONENTS l_num.

    DO l_num TIMES.
      l_save_index = sy-index.
      ASSIGN COMPONENT l_save_index OF STRUCTURE <f_excel_line>
      TO <f_excel_column>.
      IF sy-subrc NE 0.
        MESSAGE e801(zabap2xlsx) WITH 'FATAL ERROR' RAISING fatal_error.
      ENDIF.

      LOOP AT lt_fieldcat_kkblo ASSIGNING <f_fieldcat_line>
      WHERE tabname = l_tabname.
        ASSIGN COMPONENT <f_fieldcat_line>-fieldname
        OF STRUCTURE <f_excel_line> TO <f_fcat_column>.

        DESCRIBE DISTANCE BETWEEN <f_excel_column> AND <f_fcat_column>
        INTO l_int IN BYTE MODE.

* append column index
* this columns index is of table, not fieldcat

        IF l_int = 0.
          wa_column_index-fieldname = <f_fieldcat_line>-fieldname.
          wa_column_index-tabname   = <f_fieldcat_line>-tabname.
          wa_column_index-col       = l_save_index.
          APPEND wa_column_index TO lt_column_index.
        ENDIF.

* append dependent fields (currency and quantity unit)

        IF <f_fieldcat_line>-cfieldname IS NOT INITIAL.
          CLEAR wa_fieldcat_depf.
          wa_fieldcat_depf-fieldname = <f_fieldcat_line>-cfieldname.
          wa_fieldcat_depf-tabname   = <f_fieldcat_line>-ctabname.
          COLLECT wa_fieldcat_depf INTO lt_fieldcat_depf.
        ENDIF.

        IF <f_fieldcat_line>-qfieldname IS NOT INITIAL.
          CLEAR wa_fieldcat_depf.
          wa_fieldcat_depf-fieldname = <f_fieldcat_line>-qfieldname.
          wa_fieldcat_depf-tabname   = <f_fieldcat_line>-qtabname.
          COLLECT wa_fieldcat_depf INTO lt_fieldcat_depf.
        ENDIF.

* rewrite field data type

        IF <f_fieldcat_line>-inttype = 'X'
        AND <f_fieldcat_line>-datatype(3) = 'INT'.
          <f_fieldcat_line>-inttype = 'I'.
        ENDIF.

      ENDLOOP.

      CLEAR: l_save_index.
      UNASSIGN: <f_fieldcat_line>.

    ENDDO.

* build semantic tables

    l_n_hrz_keys = 1.

*   Get keyfigures

    LOOP AT lt_fieldcat_kkblo ASSIGNING <f_fieldcat_line>
    WHERE tabname = l_tabname
    AND tech NE 'X'
    AND no_out NE 'X'.

      CLEAR wa_sema.
      CLEAR wa_hkey.

*   Units belong to keyfigures -> display as str

      READ TABLE lt_fieldcat_depf INTO wa_fieldcat_depf WITH KEY
      fieldname = <f_fieldcat_line>-fieldname
      tabname   = <f_fieldcat_line>-tabname.

      IF sy-subrc = 0.
        wa_sema-col_typ = 'STR'.
        wa_sema-col_ops = 'DFT'.

*   Keyfigures

      ELSE.
        CASE <f_fieldcat_line>-datatype.
          WHEN 'QUAN'.
            wa_sema-col_typ = 'N03'.

            IF <f_fieldcat_line>-no_sum NE 'X'.
              wa_sema-col_ops = 'ADD'.
            ELSE.
              wa_sema-col_ops = 'NOP'. " no dependent field
            ENDIF.

          WHEN 'DATS'.
            wa_sema-col_typ = 'DAT'.
            wa_sema-col_ops = 'NOP'.

          WHEN 'CHAR' OR 'UNIT' OR 'CUKY'. " Added fieldformats UNIT and CUKY - dd. 26-10-2012 Wouter Heuvelmans
            wa_sema-col_typ = 'STR'.
            wa_sema-col_ops = 'DFT'.   " dependent field

*   incase numeric, ex '00120' -> display as '12'

          WHEN 'NUMC'.
            wa_sema-col_typ = 'STR'.
            wa_sema-col_ops = 'DFT'.

          WHEN OTHERS.
            wa_sema-col_typ = 'NUM'.

            IF <f_fieldcat_line>-no_sum NE 'X'.
              wa_sema-col_ops = 'ADD'.
            ELSE.
              wa_sema-col_ops = 'NOP'.
            ENDIF.
        ENDCASE.
      ENDIF.

      l_counter = l_counter + 1.
      l_n_att_cols = l_n_att_cols + 1.

      wa_sema-col_no = l_counter.

      READ TABLE lt_column_index INTO wa_column_index WITH KEY
      fieldname = <f_fieldcat_line>-fieldname
      tabname   = <f_fieldcat_line>-tabname.

      IF sy-subrc = 0.
        wa_sema-col_src = wa_column_index-col.
      ELSE.
        RAISE fatal_error.
      ENDIF.

* columns index of ref currency field in table

      IF NOT <f_fieldcat_line>-cfieldname IS INITIAL.
        READ TABLE lt_column_index INTO wa_column_index WITH KEY
        fieldname = <f_fieldcat_line>-cfieldname
        tabname   = <f_fieldcat_line>-ctabname.

        IF sy-subrc = 0.
          wa_sema-col_cur = wa_column_index-col.
        ENDIF.

* quantities fields
* treat as currency when display on excel

      ELSEIF NOT <f_fieldcat_line>-qfieldname IS INITIAL.
        READ TABLE lt_column_index INTO wa_column_index WITH KEY
        fieldname = <f_fieldcat_line>-qfieldname
        tabname   = <f_fieldcat_line>-qtabname.
        IF sy-subrc = 0.
          wa_sema-col_cur = wa_column_index-col.
        ENDIF.

      ENDIF.

*   Treat of fixed currency in the fieldcatalog for column

      DATA: l_num_help(2) TYPE n.

      IF NOT <f_fieldcat_line>-currency IS INITIAL.

        SELECT * FROM tcurx INTO TABLE lt_tcurx.
        SORT lt_tcurx.
        READ TABLE lt_tcurx INTO wa_tcurx
                   WITH KEY currkey = <f_fieldcat_line>-currency.
        IF sy-subrc = 0.
          l_num_help = wa_tcurx-currdec.
          CONCATENATE 'N' l_num_help INTO wa_sema-col_typ.
          wa_sema-col_cur = sy-tabix * ( -1 ).
        ENDIF.

      ENDIF.

      wa_hkey-col_no    = l_n_att_cols.
      wa_hkey-row_no    = l_n_hrz_keys.
      wa_hkey-col_name  = <f_fieldcat_line>-reptext.
      APPEND wa_hkey TO lt_hkey.
      APPEND wa_sema TO lt_sema.

    ENDLOOP.

* free local data

    CLEAR:
      lt_column_index,
      wa_column_index,
      lt_fieldcat_depf,
      wa_fieldcat_depf,
      lt_tcurx,
      wa_tcurx,
      l_num,
      l_typ,
      wa,
      l_int,
      l_counter.

    UNASSIGN:
      <f_fieldcat_line>,
      <f_excel_line>,
      <f_excel_column>,
      <f_fcat_column>.

*--------------------------------------------------------------------*
* SESSION 4: WRITE TO EXCEL
*--------------------------------------------------------------------*

    CLEAR wa_tcurx.
    CLEAR lt_tcurx.

*   if spreadsheet dun have proxy yet

    IF li_has IS INITIAL.
      l_retcode = c_oi_errors=>ret_interface_not_supported.
      CALL METHOD c_oi_errors=>create_error_for_retcode
        EXPORTING
          retcode  = l_retcode
          no_flush = no_flush
        IMPORTING
          error    = lo_error_w.
      RETURN.
    ENDIF.

    CREATE OBJECT l_error
      EXPORTING
        object_name = 'OLE_DOCUMENT_PROXY'
        method_name = 'get_ranges_names'.

    CALL METHOD c_oi_errors=>add_error
      EXPORTING
        error = l_error.


    DESCRIBE TABLE lt_sema LINES datareal.
    DESCRIBE TABLE <f_excel_tab> LINES datac.
    DESCRIBE TABLE lt_vkey LINES vkeycount.

    IF datac = 0.
      RAISE inv_data_range.
    ENDIF.


    IF vkeycount NE l_n_vrt_keys.
      RAISE dim_mismatch_vkey.
    ENDIF.

    all = l_n_vrt_keys + l_n_att_cols.

    IF datareal NE all.
      RAISE dim_mismatch_sema.
    ENDIF.

    DATA: decimal TYPE c.

* get decimal separator format ('.', ',', ...) in Office config

    CALL METHOD lo_proxy->get_application_property
      EXPORTING
        property_name    = 'INTERNATIONAL'
        subproperty_name = 'DECIMAL_SEPARATOR'
      CHANGING
        retvalue         = decimal.

    DATA date_format TYPE usr01-datfm.
    SELECT SINGLE datfm FROM usr01 INTO date_format WHERE bname = sy-uname.

    DATA: comma_elim(4) TYPE c.
    FIELD-SYMBOLS <g> TYPE any.
    DATA search_item(4) VALUE '   #'.

    CONCATENATE ',' decimal '.' decimal INTO comma_elim.

    DATA help TYPE i. " table (with subtotal) line number

    help = datac.

    DATA: rowmax TYPE i VALUE 1.    " header row number
    DATA: columnmax TYPE i VALUE 0. " header columns number

    LOOP AT lt_hkey INTO hkeyitem.
      IF hkeyitem-col_no > columnmax.
        columnmax = hkeyitem-col_no.
      ENDIF.

      IF hkeyitem-row_no > rowmax.
        rowmax = hkeyitem-row_no.
      ENDIF.
    ENDLOOP.

    DATA: hkeycolumns TYPE i. " header columns no

    hkeycolumns = columnmax.

    IF hkeycolumns <   l_n_att_cols.
      hkeycolumns = l_n_att_cols.
    ENDIF.

    columnmax = 0.

    LOOP AT lt_vkey INTO vkeyitem.
      IF vkeyitem-col_no > columnmax.
        columnmax = vkeyitem-col_no.
      ENDIF.
    ENDLOOP.

    DATA overflow TYPE i VALUE 1.
    DATA testname(10) TYPE c.
    DATA temp2 TYPE i.                " 1st item row position in excel
    DATA realmit TYPE i VALUE 1.
    DATA realoverflow TYPE i VALUE 1. " row index in content

    CALL METHOD lo_spreadsheet->screen_update
      EXPORTING
        updating = ''.

    CALL METHOD lo_spreadsheet->load_lib.

    DATA: str(40) TYPE c. " range names of columns range (w/o col header)
    DATA: rows TYPE i.    " row postion of 1st item line in ecxel

* calculate row position of data table

    DESCRIBE TABLE it_listheader LINES li_commentary_rows.

* if grid had title, add 1 empy line between title and table

    IF li_commentary_rows NE 0.
      ADD 1 TO li_commentary_rows.
    ENDIF.

* add top position of block data

    li_commentary_rows = li_commentary_rows + i_top - 1.

* write header (commentary rows)

    DATA: li_commentary_row_index TYPE i VALUE 1.
    DATA: li_content_index TYPE i VALUE 1.
    DATA: ls_index(10) TYPE c.
    DATA  ls_commentary_range(40) TYPE c VALUE 'TITLE'.
    DATA: li_font_bold    TYPE i.
    DATA: li_font_italic  TYPE i.
    DATA: li_font_size    TYPE i.

    LOOP AT it_listheader INTO wa_listheader.
      li_commentary_row_index = i_top + li_content_index - 1.
      ls_index = li_content_index.
      CONDENSE ls_index.
      CONCATENATE ls_commentary_range(5) ls_index
                  INTO ls_commentary_range.
      CONDENSE ls_commentary_range.

* insert title range

      CALL METHOD lo_spreadsheet->insert_range_dim
        EXPORTING
          name     = ls_commentary_range
          top      = li_commentary_row_index
          left     = i_left
          rows     = 1
          columns  = 1
          no_flush = no_flush.

* format range

      CASE wa_listheader-typ.
        WHEN 'H'. "title
          li_font_size    = 16.
          li_font_bold    = 1.
          li_font_italic  = -1.
        WHEN 'S'. "subtile
          li_font_size = -1.
          li_font_bold    = 1.
          li_font_italic  = -1.
        WHEN OTHERS. "'A' comment
          li_font_size = -1.
          li_font_bold    = -1.
          li_font_italic  = 1.
      ENDCASE.

      CALL METHOD lo_spreadsheet->set_font
        EXPORTING
          rangename = ls_commentary_range
          family    = ''
          size      = li_font_size
          bold      = li_font_bold
          italic    = li_font_italic
          align     = 0
          no_flush  = no_flush.

* title: range content

      rangeitem-name = ls_commentary_range.
      rangeitem-columns = 1.
      rangeitem-rows = 1.
      APPEND rangeitem TO ranges.

      contentsitem-row    = li_content_index.
      contentsitem-column = 1.
      CONCATENATE wa_listheader-key
                  wa_listheader-info
                  INTO contentsitem-value
                  SEPARATED BY space.
      CONDENSE contentsitem-value.
      APPEND contentsitem TO contents.

      ADD 1 TO li_content_index.

      CLEAR:
        rangeitem,
        contentsitem,
        ls_index.

    ENDLOOP.

* set range data title

    CALL METHOD lo_spreadsheet->set_ranges_data
      EXPORTING
        ranges   = ranges
        contents = contents
        no_flush = no_flush.

    CLEAR: ranges, contents.

    rows = rowmax + li_commentary_rows + 1.

    all = date_format.
    all = all + 3.

    LOOP AT lt_sema INTO semaitem.
      IF semaitem-col_typ = 'DAT' OR semaitem-col_typ = 'MON' OR
         semaitem-col_typ = 'N00' OR semaitem-col_typ = 'N01' OR
         semaitem-col_typ = 'N02' OR
         semaitem-col_typ = 'N03' OR semaitem-col_typ = 'PCT' OR
         semaitem-col_typ = 'STR' OR semaitem-col_typ = 'NUM'.
        CLEAR str.
        str = semaitem-col_no.
        CONDENSE str.
        CONCATENATE 'DATA' str INTO str.
        mit = semaitem-col_no.
        li_col_pos = semaitem-col_no + i_left - 1.

* range from data1 to data(n), for each columns of table

        CALL METHOD lo_spreadsheet->insert_range_dim
          EXPORTING
            name     = str
            top      = rows
            left     = li_col_pos
            rows     = help
            columns  = 1
            no_flush = no_flush.

        DATA dec TYPE i VALUE -1.
        DATA typeinfo TYPE sydes_typeinfo.
        LOOP AT <f_excel_tab> ASSIGNING <line>.
          ASSIGN COMPONENT semaitem-col_no OF STRUCTURE <line> TO <item>.
          DESCRIBE FIELD <item> INTO td.
          READ TABLE td-types INDEX 1 INTO typeinfo.
          IF typeinfo-type = 'P'.
            dec = typeinfo-decimals.
          ELSEIF typeinfo-type = 'I'.
            dec = 0.
          ENDIF.

          DESCRIBE FIELD <line> TYPE typ COMPONENTS count.
          mit = 1.
          DO count TIMES.
            IF mit = semaitem-col_src.
              ASSIGN COMPONENT sy-index OF STRUCTURE <line> TO <item>.
              DESCRIBE FIELD <item> INTO td.
              READ TABLE td-types INDEX 1 INTO typeinfo.
              IF typeinfo-type = 'P'.
                dec = typeinfo-decimals.
              ENDIF.
              EXIT.
            ENDIF.
            mit = mit + 1.
          ENDDO.
          EXIT.
        ENDLOOP.

* format for each columns of table (w/o columns headers)

        IF semaitem-col_typ = 'DAT'.
          IF semaitem-col_no > vkeycount.
            CALL METHOD lo_spreadsheet->set_format
              EXPORTING
                rangename = str
                currency  = ''
                typ       = all
                no_flush  = no_flush.
          ELSE.
            CALL METHOD lo_spreadsheet->set_format
              EXPORTING
                rangename = str
                currency  = ''
                typ       = 0
                no_flush  = no_flush.
          ENDIF.
        ELSEIF semaitem-col_typ = 'STR'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 0
              no_flush  = no_flush.
        ELSEIF semaitem-col_typ = 'MON'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 10
              no_flush  = no_flush.
        ELSEIF semaitem-col_typ = 'N00'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 1
              decimals  = 0
              no_flush  = no_flush.
        ELSEIF semaitem-col_typ = 'N01'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 1
              decimals  = 1
              no_flush  = no_flush.
        ELSEIF semaitem-col_typ = 'N02'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 1
              decimals  = 2
              no_flush  = no_flush.
        ELSEIF semaitem-col_typ = 'N03'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 1
              decimals  = 3
              no_flush  = no_flush.
        ELSEIF semaitem-col_typ = 'N04'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 1
              decimals  = 4
              no_flush  = no_flush.
        ELSEIF semaitem-col_typ = 'NUM'.
          IF dec EQ -1.
            CALL METHOD lo_spreadsheet->set_format
              EXPORTING
                rangename = str
                currency  = ''
                typ       = 1
                decimals  = 2
                no_flush  = no_flush.
          ELSE.
            CALL METHOD lo_spreadsheet->set_format
              EXPORTING
                rangename = str
                currency  = ''
                typ       = 1
                decimals  = dec
                no_flush  = no_flush.
          ENDIF.
        ELSEIF semaitem-col_typ = 'PCT'.
          CALL METHOD lo_spreadsheet->set_format
            EXPORTING
              rangename = str
              currency  = ''
              typ       = 3
              decimals  = 0
              no_flush  = no_flush.
        ENDIF.

      ENDIF.
    ENDLOOP.

* get item contents for set_range_data method
* get currency cell also

    mit = 1.

    DATA: currcells TYPE soi_cell_table.
    DATA: curritem  TYPE soi_cell_item.

    curritem-rows = 1.
    curritem-columns = 1.
    curritem-front = -1.
    curritem-back = -1.
    curritem-font = ''.
    curritem-size = -1.
    curritem-bold = -1.
    curritem-italic = -1.
    curritem-align = -1.
    curritem-frametyp = -1.
    curritem-framecolor = -1.
    curritem-currency = ''.
    curritem-number = 1.
    curritem-input = -1.

    DATA: const TYPE i.

*   Change for Correction request
*    Initial 10000 lines are missing in Excel Export
*    if there are only 2 columns in exported List object.

    IF datareal GT 2.
      const = 20000 / datareal.
    ELSE.
      const = 20000 / ( datareal + 2 ).
    ENDIF.

    DATA: lines TYPE i.
    DATA: innerlines TYPE i.
    DATA: counter TYPE i.
    DATA: curritem2 LIKE curritem.
    DATA: curritem3 LIKE curritem.
    DATA: length TYPE i.
    DATA: found.

* append content table (for method set_range_content)

    LOOP AT <f_excel_tab> ASSIGNING <line>.

* save line index to compare with lt_subtot_indexs,
* to discover line is a subtotal / totale line or not
* ex use to set 'dun display zero in subtotal / total line'

      l_save_index = sy-tabix.

      DO datareal TIMES.
        READ TABLE lt_sema INTO semaitem WITH KEY col_no = sy-index.
        IF semaitem-col_src NE 0.
          ASSIGN COMPONENT semaitem-col_src
                 OF STRUCTURE <line> TO <item>.
        ELSE.
          ASSIGN COMPONENT sy-index
                 OF STRUCTURE <line> TO <item>.
        ENDIF.

        contentsitem-row = realoverflow.

        IF sy-subrc = 0.
          search_item(3) = semaitem-col_ops.
          SEARCH 'ADD#CNT#MIN#MAX#AVG#NOP#DFT#'
                            FOR search_item.
          IF sy-subrc NE 0.
            RAISE error_in_sema.
          ENDIF.
          search_item(3) = semaitem-col_typ.
          SEARCH 'NUM#N00#N01#N02#N03#N04#PCT#DAT#MON#STR#'
                            FOR search_item.
          IF sy-subrc NE 0.
            RAISE error_in_sema.
          ENDIF.
          contentsitem-column = sy-index.
          IF semaitem-col_typ EQ 'DAT' OR semaitem-col_typ EQ 'MON'.
            IF semaitem-col_no > vkeycount.

              " Hinweis 512418
              " EXCEL bezieht Datumsangaben
              " auf den 31.12.1899, behandelt
              " aber 1900 als ein Schaltjahr
              " d.h. ab 1.3.1900 korrekt
              " 1.3.1900 als Zahl = 61

              DATA: genesis TYPE d VALUE '18991230'.
              DATA: number_of_days TYPE p.
* change for date in char format & sema_type = X
              DATA: temp_date TYPE d.

              IF NOT <item> IS INITIAL AND NOT <item> CO ' ' AND NOT
              <item> CO '0'.
* change for date in char format & sema_type = X starts
                IF sema_type = 'X'.
                  DESCRIBE FIELD <item> TYPE typ.
                  IF typ = 'C'.
                    temp_date = <item>.
                    number_of_days = temp_date - genesis.
                  ELSE.
                    number_of_days = <item> - genesis.
                  ENDIF.
                ELSE.
                  number_of_days = <item> - genesis.
                ENDIF.
* change for date in char format & sema_type = X ends
                IF number_of_days < 61.
                  number_of_days = number_of_days - 1.
                ENDIF.

                SET COUNTRY 'DE'.
                WRITE number_of_days TO contentsitem-value
                NO-GROUPING
                                          LEFT-JUSTIFIED.
                SET COUNTRY space.
                TRANSLATE contentsitem-value USING comma_elim.
              ELSE.
                CLEAR contentsitem-value.
              ENDIF.
            ELSE.
              contentsitem-value = <item>.
            ENDIF.
          ELSEIF semaitem-col_typ EQ 'NUM' OR
                 semaitem-col_typ EQ 'N00' OR
                 semaitem-col_typ EQ 'N01' OR
                 semaitem-col_typ EQ 'N02' OR
                 semaitem-col_typ EQ 'N03' OR
                 semaitem-col_typ EQ 'N04' OR
                 semaitem-col_typ EQ 'PCT'.
            SET COUNTRY 'DE'.
            DESCRIBE FIELD <item> TYPE typ.

            IF semaitem-col_cur IS INITIAL.
              IF typ NE 'F'.
                WRITE <item> TO contentsitem-value NO-GROUPING
                                                   NO-SIGN DECIMALS 14.
              ELSE.
                WRITE <item> TO contentsitem-value NO-GROUPING
                                                   NO-SIGN.
              ENDIF.
            ELSE.
* Treat of fixed curreny for column >>Y9CK007319
              IF semaitem-col_cur < 0.
                semaitem-col_cur = semaitem-col_cur * ( -1 ).
                SELECT * FROM tcurx INTO TABLE lt_tcurx.
                SORT lt_tcurx.
                READ TABLE lt_tcurx INTO
                                    wa_tcurx INDEX semaitem-col_cur.
                IF sy-subrc = 0.
                  IF typ NE 'F'.
                    WRITE <item> TO contentsitem-value NO-GROUPING
                     CURRENCY wa_tcurx-currkey NO-SIGN DECIMALS 14.
                  ELSE.
                    WRITE <item> TO contentsitem-value NO-GROUPING
                     CURRENCY wa_tcurx-currkey NO-SIGN.
                  ENDIF.
                ENDIF.
              ELSE.
                ASSIGN COMPONENT semaitem-col_cur
                     OF STRUCTURE <line> TO <g>.
* mit = index of recent row
                curritem-top  = rowmax + mit + li_commentary_rows.

                li_col_pos =  sy-index + i_left - 1.
                curritem-left = li_col_pos.

* if filed is quantity field (qfieldname ne space)
* or amount field (cfieldname ne space), then format decimal place
* corresponding with config

                CLEAR: l_def.
                READ TABLE lt_fieldcat_kkblo ASSIGNING <f_fieldcat_line>
                WITH KEY  tabname = l_tabname
                          tech    = space
                          no_out  = space
                          col_pos = semaitem-col_no.
                IF sy-subrc = 0.
                  IF <f_fieldcat_line>-cfieldname IS NOT INITIAL.
                    l_def = 'C'.
                  ELSE."if <f_fieldcat_line>-qfieldname is not initial.
                    l_def = 'Q'.
                  ENDIF.
                ENDIF.

* if field is amount field
* exporting of amount field base on currency decimal table: TCURX
                IF l_def = 'C'. "field is amount field
                  SELECT SINGLE * FROM tcurx INTO wa_tcurx
                    WHERE currkey = <g>.
* if amount ref to un-know currency -> default decimal  = 2
                  IF sy-subrc EQ 0.
                    curritem-decimals = wa_tcurx-currdec.
                  ELSE.
                    curritem-decimals = 2.
                  ENDIF.

                  APPEND curritem TO currcells.
                  IF typ NE 'F'.
                    WRITE <item> TO contentsitem-value
                                        CURRENCY <g>
                       NO-SIGN NO-GROUPING.
                  ELSE.
                    WRITE <item> TO contentsitem-value
                       DECIMALS 14      CURRENCY <g>
                       NO-SIGN NO-GROUPING.
                  ENDIF.

* if field is quantity field
* exporting of quantity field base on quantity decimal table: T006

                ELSE."if l_def = 'Q'. " field is quantity field
                  CLEAR: wa_t006.
                  SELECT SINGLE * FROM t006 INTO wa_t006
                    WHERE msehi = <g>.
* if quantity ref to un-know unit-> default decimal  = 2
                  IF sy-subrc EQ 0.
                    curritem-decimals = wa_t006-decan.
                  ELSE.
                    curritem-decimals = 2.
                  ENDIF.
                  APPEND curritem TO currcells.

                  WRITE <item> TO contentsitem-value
                                      UNIT <g>
                     NO-SIGN NO-GROUPING.
                  CONDENSE contentsitem-value.

                ENDIF.

              ENDIF.                                        "Y9CK007319
            ENDIF.
            CONDENSE contentsitem-value.

* add function fieldcat-no zero display

            LOOP AT lt_fieldcat_kkblo ASSIGNING <f_fieldcat_line>
            WHERE tabname = l_tabname
            AND   tech NE 'X'
            AND   no_out NE 'X'.
              IF <f_fieldcat_line>-col_pos = semaitem-col_no.
                IF <f_fieldcat_line>-no_zero = 'X'.
                  IF <item> = '0'.
                    CLEAR: contentsitem-value.
                  ENDIF.

* dun display zero in total/subtotal line too

                ELSE.
                  CLEAR: wa_subtot_indexs.
                  READ TABLE lt_subtot_indexs INTO wa_subtot_indexs
                  WITH KEY index = l_save_index.
                  IF sy-subrc = 0 AND <item> = '0'.
                    CLEAR: contentsitem-value.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDLOOP.
            UNASSIGN: <f_fieldcat_line>.

            IF <item> LT 0.
              SEARCH contentsitem-value FOR 'E'.
              IF sy-fdpos EQ 0.

* use prefix notation for signed numbers

                TRANSLATE contentsitem-value USING '- '.
                CONDENSE contentsitem-value NO-GAPS.
                CONCATENATE '-' contentsitem-value
                           INTO contentsitem-value.
              ELSE.
                CONCATENATE '-' contentsitem-value
                           INTO contentsitem-value.
              ENDIF.
            ENDIF.
            SET COUNTRY space.
* Hier wird nur die korrekte Kommaseparatierung gemacht, wenn die
* Zeichen einer
* Zahl enthalten sind. Das ist für Timestamps, die auch ":" enthalten.
* Für die
* darf keine Kommaseparierung stattfinden.
* Changing for correction request - Y6BK041073
            IF contentsitem-value CO '0123456789.,-+E '.
              TRANSLATE contentsitem-value USING comma_elim.
            ENDIF.
          ELSE.
            CLEAR contentsitem-value.

* if type is not numeric -> dun display with zero
            IF <item> CO '0123456789.,-+E '.
                WRITE <item> TO contentsitem-value NO-ZERO.

                SHIFT contentsitem-value LEFT DELETING LEADING space.
            ELSE.
                WRITE <item> TO contentsitem-value.
            ENDIF.

          ENDIF.
          APPEND contentsitem TO contents.
        ENDIF.
      ENDDO.

      realmit = realmit + 1.
      realoverflow = realoverflow + 1.

      mit = mit + 1.
*   overflow = current row index in content table
      overflow = overflow + 1.
    ENDLOOP.

    UNASSIGN: <f_fieldcat_line>.

* set item range for set_range_data method

    testname = mit / const.
    CONDENSE testname.

    CONCATENATE 'TEST' testname INTO testname.

    realoverflow = realoverflow - 1.
    realmit = realmit - 1.
    help = realoverflow.

    rangeitem-name = testname.
    rangeitem-columns = datareal.
    rangeitem-rows = help.
    APPEND rangeitem TO ranges.

* insert item range dim

    temp2 = rowmax + 1 + li_commentary_rows + realmit - realoverflow.

* items data

    CALL METHOD lo_spreadsheet->insert_range_dim
      EXPORTING
        name     = testname
        top      = temp2
        left     = i_left
        rows     = help
        columns  = datareal
        no_flush = no_flush.

* get columns header contents for set_range_data method
* export columns header only if no columns header option = space

    DATA: rowcount TYPE i.
    DATA: columncount TYPE i.

    IF i_columns_header = 'X'.

* append columns header to contents: hkey

      rowcount = 1.
      DO rowmax TIMES.
        columncount = 1.
        DO hkeycolumns TIMES.
          LOOP AT lt_hkey INTO hkeyitem WHERE col_no = columncount
                                           AND row_no   = rowcount.
          ENDLOOP.
          IF sy-subrc = 0.
            str = hkeyitem-col_name.
            contentsitem-value = hkeyitem-col_name.
          ELSE.
            contentsitem-value = str.
          ENDIF.
          contentsitem-column = columncount.
          contentsitem-row = rowcount.
          APPEND contentsitem TO contents.
          columncount = columncount + 1.
        ENDDO.
        rowcount = rowcount + 1.
      ENDDO.

* incase columns header in multiline

      DATA: rowmaxtemp TYPE i.
      IF rowmax > 1.
        rowmaxtemp = rowmax - 1.
        rowcount = 1.
        DO rowmaxtemp TIMES.
          columncount = 1.
          DO columnmax TIMES.
            contentsitem-column = columncount.
            contentsitem-row    = rowcount.
            contentsitem-value  = ''.
            APPEND contentsitem TO contents.
            columncount = columncount + 1.
          ENDDO.
          rowcount = rowcount + 1.
        ENDDO.
      ENDIF.

* append columns header to contents: vkey

      columncount = 1.
      DO columnmax TIMES.
        LOOP AT lt_vkey INTO vkeyitem WHERE col_no = columncount.
        ENDLOOP.
        contentsitem-value = vkeyitem-col_name.
        contentsitem-row = rowmax.
        contentsitem-column = columncount.
        APPEND contentsitem TO contents.
        columncount = columncount + 1.
      ENDDO.
*--------------------------------------------------------------------*
* set header range for method set_range_data
* insert header keys range dim

      li_head_top = li_commentary_rows + 1.
      li_col_pos = i_left.

* insert range headers

      IF hkeycolumns NE 0.
        rangeitem-name = 'TESTHKEY'.
        rangeitem-rows = rowmax.
        rangeitem-columns = hkeycolumns.
        APPEND rangeitem TO ranges.
        CLEAR: rangeitem.

        CALL METHOD lo_spreadsheet->insert_range_dim
          EXPORTING
            name     = 'TESTHKEY'
            top      = li_head_top
            left     = li_col_pos
            rows     = rowmax
            columns  = hkeycolumns
            no_flush = no_flush.
      ENDIF.
    ENDIF.

* format for columns header + total + subtotal
* ------------------------------------------

    help = rowmax + realmit. " table + header lines

    DATA: lt_format     TYPE soi_format_table.
    DATA: wa_format     LIKE LINE OF lt_format.
    DATA: wa_format_temp LIKE LINE OF lt_format.

    FIELD-SYMBOLS: <f_source> TYPE any.
    FIELD-SYMBOLS: <f_des>    TYPE any.

* columns header format

    wa_format-front       = -1.
    wa_format-back        = 15. "grey
    wa_format-font        = space.
    wa_format-size        = -1.
    wa_format-bold        = 1.
    wa_format-align       = 0.
    wa_format-frametyp    = -1.
    wa_format-framecolor  = -1.

* get column header format from input record
* -> map input format

    IF i_columns_header = 'X'.
      wa_format-name        = 'TESTHKEY'.
      IF i_format_col_header IS NOT INITIAL.
        DESCRIBE FIELD i_format_col_header TYPE l_typ COMPONENTS
        li_col_num.
        DO li_col_num TIMES.
          IF sy-index NE 1. " dun map range name
            ASSIGN COMPONENT sy-index OF STRUCTURE i_format_col_header
            TO <f_source>.
            IF <f_source> IS NOT INITIAL.
              ASSIGN COMPONENT sy-index OF STRUCTURE wa_format TO <f_des>.
              <f_des> = <f_source>.
              UNASSIGN: <f_des>.
            ENDIF.
            UNASSIGN: <f_source>.
          ENDIF.
        ENDDO.

        CLEAR: li_col_num.
      ENDIF.

      APPEND wa_format TO lt_format.
    ENDIF.

* Zusammenfassen der Spalten mit gleicher Nachkommastellenzahl
* collect vertical cells (col)  with the same number of decimal places
* to increase perfomance in currency cell format

    DESCRIBE TABLE currcells LINES lines.
    lines = lines - 1.
    DO lines TIMES.
      DESCRIBE TABLE currcells LINES innerlines.
      innerlines = innerlines - 1.
      SORT currcells BY left top.
      CLEAR found.
      DO innerlines TIMES.
        READ TABLE currcells INDEX sy-index INTO curritem.
        counter = sy-index + 1.
        READ TABLE currcells INDEX counter INTO curritem2.
        IF curritem-left EQ curritem2-left.
          length = curritem-top + curritem-rows.
          IF length EQ curritem2-top AND curritem-decimals EQ curritem2-decimals.
            curritem3 = curritem.
            curritem3-rows = curritem3-rows + curritem2-rows.
            curritem-left = -1.
            MODIFY currcells INDEX sy-index FROM curritem.
            curritem2-left = -1.
            MODIFY currcells INDEX counter FROM curritem2.
            APPEND curritem3 TO currcells.
            found = 'X'.
          ENDIF.
        ENDIF.
      ENDDO.
      IF found IS INITIAL.
        EXIT.
      ENDIF.
      DELETE currcells WHERE left = -1.
    ENDDO.

* Zusammenfassen der Zeilen mit gleicher Nachkommastellenzahl
* collect horizontal cells (row) with the same number of decimal places
* to increase perfomance in currency cell format

    DESCRIBE TABLE currcells LINES lines.
    lines = lines - 1.
    DO lines TIMES.
      DESCRIBE TABLE currcells LINES innerlines.
      innerlines = innerlines - 1.
      SORT currcells BY top left.
      CLEAR found.
      DO innerlines TIMES.
        READ TABLE currcells INDEX sy-index INTO curritem.
        counter = sy-index + 1.
        READ TABLE currcells INDEX counter INTO curritem2.
        IF curritem-top EQ curritem2-top AND curritem-rows EQ
        curritem2-rows.
          length = curritem-left + curritem-columns.
          IF length EQ curritem2-left AND curritem-decimals EQ curritem2-decimals.
            curritem3 = curritem.
            curritem3-columns = curritem3-columns + curritem2-columns.
            curritem-left = -1.
            MODIFY currcells INDEX sy-index FROM curritem.
            curritem2-left = -1.
            MODIFY currcells INDEX counter FROM curritem2.
            APPEND curritem3 TO currcells.
            found = 'X'.
          ENDIF.
        ENDIF.
      ENDDO.
      IF found IS INITIAL.
        EXIT.
      ENDIF.
      DELETE currcells WHERE left = -1.
    ENDDO.
* Ende der Zusammenfassung


* item data: format for currency cell, corresponding with currency

    CALL METHOD lo_spreadsheet->cell_format
      EXPORTING
        cells    = currcells
        no_flush = no_flush.

* item data: write item table content

    CALL METHOD lo_spreadsheet->set_ranges_data
      EXPORTING
        ranges   = ranges
        contents = contents
        no_flush = no_flush.

* whole table range to format all table

    IF i_columns_header = 'X'.
      li_head_top = li_commentary_rows + 1.
    ELSE.
      li_head_top = li_commentary_rows + 2.
      help = help - 1.
    ENDIF.

    CALL METHOD lo_spreadsheet->insert_range_dim
      EXPORTING
        name     = 'WHOLE_TABLE'
        top      = li_head_top
        left     = i_left
        rows     = help
        columns  = datareal
        no_flush = no_flush.

* columns width auto fix
* this parameter = space in case use with exist template

    IF i_columns_autofit = 'X'.
      CALL METHOD lo_spreadsheet->fit_widest
        EXPORTING
          name     = 'WHOLE_TABLE'
          no_flush = no_flush.
    ENDIF.

* frame
* The parameter has 8 bits
*0 Left margin
*1 Top marginT
*2 Bottom margin
*3 Right margin
*4 Horizontal line
*5 Vertical line
*6 Thinness
*7 Thickness
* here 127 = 1111111 6-5-4-3-2-1 mean Thin-ver-hor-right-bot-top-left

* ( final DOI method call, set no_flush = space
* equal to call method CL_GUI_CFW=>FLUSH )

    CALL METHOD lo_spreadsheet->set_frame
      EXPORTING
        rangename = 'WHOLE_TABLE'
        typ       = 127
        color     = 1
        no_flush  = space
      IMPORTING
        error     = lo_error
        retcode   = lc_retcode.

    error_doi( ).

* reformat subtotal / total line after format wholw table

    LOOP AT subranges INTO subrangeitem.
      l_sub_index = subrangeitem-rows + li_commentary_rows + rowmax.

      CALL METHOD lo_spreadsheet->insert_range_dim
        EXPORTING
          name     = subrangeitem-name
          left     = i_left
          top      = l_sub_index
          rows     = 1
          columns  = datareal
          no_flush = no_flush.

      wa_format-name    = subrangeitem-name.

*   default format:
*     - clolor: subtotal = light yellow, subtotal = yellow
*     - frame: box

      IF  subrangeitem-name(3) = 'SUB'.
        wa_format-back = 36. "subtotal line
        wa_format_temp = i_format_subtotal.
      ELSE.
        wa_format-back = 27. "total line
        wa_format_temp = i_format_total.
      ENDIF.
      wa_format-frametyp = 79.
      wa_format-framecolor = 1.
      wa_format-number  = -1.
      wa_format-align   = -1.

*   get subtoal + total format from intput parameter
*   overwrite default format

      IF wa_format_temp IS NOT INITIAL.
        DESCRIBE FIELD wa_format_temp TYPE l_typ COMPONENTS li_col_num.
        DO li_col_num TIMES.
          IF sy-index NE 1. " dun map range name
            ASSIGN COMPONENT sy-index OF STRUCTURE wa_format_temp
            TO <f_source>.
            IF <f_source> IS NOT INITIAL.
              ASSIGN COMPONENT sy-index OF STRUCTURE wa_format TO <f_des>.
              <f_des> = <f_source>.
              UNASSIGN: <f_des>.
            ENDIF.
            UNASSIGN: <f_source>.
          ENDIF.
        ENDDO.

        CLEAR: li_col_num.
      ENDIF.

      APPEND wa_format TO lt_format.
      CLEAR: wa_format-name.
      CLEAR: l_sub_index.
      CLEAR: wa_format_temp.

    ENDLOOP.

    IF lt_format[] IS NOT INITIAL.
      CALL METHOD lo_spreadsheet->set_ranges_format
        EXPORTING
          formattable = lt_format
          no_flush    = no_flush.
      CLEAR lt_format.
    ENDIF.
*--------------------------------------------------------------------*
    CALL METHOD lo_spreadsheet->screen_update
      EXPORTING
        updating = 'X'.

    CALL METHOD c_oi_errors=>flush_errors.

    lo_error_w = l_error.
    lc_retcode = lo_error_w->error_code.

    CLEAR:
      lt_sema,
      wa_sema,
      lt_hkey,
      wa_hkey,
      lt_vkey,
      wa_vkey,
      l_n_hrz_keys,
      l_n_att_cols,
      l_n_vrt_keys,
      count,
      datac,
      datareal,
      vkeycount,
      all,
      mit,
      li_col_pos,
      li_col_num,
      ranges,
      rangeitem,
      contents,
      contentsitem,
      semaitem,
      hkeyitem,
      vkeyitem,
      li_commentary_rows,
      l_retcode,
      li_head_top,
      <f_excel_tab>.

    CLEAR:
       lo_error_w.

    UNASSIGN:
    <line>,
    <item>,
    <f_excel_tab>.

*--------------------------------------------------------------------*
* SESSION 5: SAVE AND CLOSE FILE
*--------------------------------------------------------------------*

* ex of save path: 'FILE://C:\temp\test.xlsx'
    CONCATENATE 'FILE://' i_save_path
                INTO ls_path.

    CALL METHOD lo_proxy->save_document_to_url
      EXPORTING
        no_flush      = 'X'
        url           = ls_path
      IMPORTING
        error         = lo_error
        retcode       = lc_retcode
      CHANGING
        document_size = li_document_size.

    error_doi( ).

* if save successfully -> raise successful message
    MESSAGE i400(zabap2xlsx).

    CLEAR:
      ls_path,
      li_document_size.

    close_document( ).
  ENDMETHOD.                    "BIND_ALV_OLE2
  METHOD close_document.

    DATA: l_is_closed TYPE i.

    CLEAR: l_is_closed.
    IF lo_proxy IS NOT INITIAL.

* check proxy detroyed adi

      CALL METHOD lo_proxy->is_destroyed
        IMPORTING
          ret_value = l_is_closed.

* if dun detroyed yet: close -> release proxy

      IF l_is_closed IS INITIAL.
        CALL METHOD lo_proxy->close_document
          IMPORTING
            error   = lo_error
            retcode = lc_retcode.
      ENDIF.

      CALL METHOD lo_proxy->release_document
        IMPORTING
          error   = lo_error
          retcode = lc_retcode.

    ELSE.
      lc_retcode = c_oi_errors=>ret_document_not_open.
    ENDIF.

* Detroy control container

    IF lo_control IS NOT INITIAL.
      CALL METHOD lo_control->destroy_control.
    ENDIF.

    CLEAR:
      lo_spreadsheet,
      lo_proxy,
      lo_control.

  ENDMETHOD.
  METHOD error_doi.

    IF lc_retcode NE c_oi_errors=>ret_ok.
      close_document( ).
      CALL METHOD lo_error->raise_message
        EXPORTING
          type = 'E'.
      CLEAR: lo_error.
    ENDIF.

  ENDMETHOD.
endclass. "LCL_EXCEL_OLE implementation

*>>>>>>> LCX_EXCEL <<<<<<<*

*"* macro definitions
*include Lcx_excel=====================ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcx_excel=====================ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCX_EXCEL implementation.
*"* method's implementations
*include methods.
  METHOD constructor ##ADT_SUPPRESS_GENERATION.
    CALL METHOD super->constructor
      EXPORTING
        textid   = textid
        previous = previous.
    IF textid IS INITIAL.
      me->textid = Lcx_excel .
    ENDIF.
    me->error = error .
    me->syst_at_raise = syst_at_raise .
  ENDMETHOD.
  METHOD if_message~get_longtext.

    IF   me->error         IS NOT INITIAL
      OR me->syst_at_raise IS NOT INITIAL.
*--------------------------------------------------------------------*
* If message was supplied explicitly use this as longtext as well
*--------------------------------------------------------------------*
      result = me->get_text( ).
    ELSE.
*--------------------------------------------------------------------*
* otherwise use standard method to derive text
*--------------------------------------------------------------------*
      result = super->if_message~get_longtext( preserve_newlines = preserve_newlines ).
    ENDIF.
  ENDMETHOD.
  METHOD if_message~get_text.

    IF me->error IS NOT INITIAL.
*--------------------------------------------------------------------*
* If message was supplied explicitly use this
*--------------------------------------------------------------------*
      result = me->error .
    ELSEIF me->syst_at_raise IS NOT INITIAL.
*--------------------------------------------------------------------*
* If message was supplied by syst create messagetext now
*--------------------------------------------------------------------*
      MESSAGE ID syst_at_raise-msgid TYPE syst_at_raise-msgty NUMBER syst_at_raise-msgno
           WITH  syst_at_raise-msgv1 syst_at_raise-msgv2 syst_at_raise-msgv3 syst_at_raise-msgv4
           INTO  result.
    ELSE.
*--------------------------------------------------------------------*
* otherwise use standard method to derive text
*--------------------------------------------------------------------*
      CALL METHOD super->if_message~get_text
        RECEIVING
          result = result.
    ENDIF.
  ENDMETHOD.
  METHOD raise_symsg.
    RAISE EXCEPTION TYPE Lcx_excel
      EXPORTING
        syst_at_raise = syst.
  ENDMETHOD.
  METHOD raise_text.
    RAISE EXCEPTION TYPE Lcx_excel
      EXPORTING
        error = iv_text.
  ENDMETHOD.
endclass. "LCX_EXCEL implementation

*>>>>>>> LCL_EXCEL_STYLE_CHANGER <<<<<<<*

*"* macro definitions
*include Lcl_excel_style_changer=======ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_style_changer=======ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


*"* test class
*include Lcl_excel_style_changer=======ccau.



class LCL_EXCEL_STYLE_CHANGER implementation.
*"* method's implementations
*include methods.
  METHOD clear_initial_colorxfields.

    IF is_color-rgb IS INITIAL.
      CLEAR cs_xcolor-rgb.
    ENDIF.
    IF is_color-indexed IS INITIAL.
      CLEAR cs_xcolor-indexed.
    ENDIF.
    IF is_color-theme IS INITIAL.
      CLEAR cs_xcolor-theme.
    ENDIF.
    IF is_color-tint IS INITIAL.
      CLEAR cs_xcolor-tint.
    ENDIF.

  ENDMETHOD.
  METHOD create.

    DATA: style TYPE REF TO Lcl_excel_style_changer.

    CREATE OBJECT style.
    style->excel = excel.
    result = style.

  ENDMETHOD.
  METHOD move_supplied_borders.

    DATA: cs_borderx TYPE zexcel_s_cstylex_border.

    IF iv_border_supplied = abap_true.  " only act if parameter was supplied
      IF iv_xborder_supplied = abap_true. "
        cs_borderx = is_xborder.             " use supplied x-parameter
      ELSE.
        CLEAR cs_borderx WITH 'X'. " <============================== DDIC structure enh. category to set?
        " clear in a way that would be expected to work easily
        IF is_border-border_style IS  INITIAL.
          CLEAR cs_borderx-border_style.
        ENDIF.
        clear_initial_colorxfields(
          EXPORTING
            is_color  = is_border-border_color
          CHANGING
            cs_xcolor = cs_borderx-border_color ).
      ENDIF.
      cs_complete_style_border = is_border.
      cs_complete_stylex_border = cs_borderx.
    ENDIF.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~apply.

    DATA: stylemapping TYPE zexcel_s_stylemapping,
          lo_worksheet TYPE REF TO Lcl_excel_worksheet,
          l_guid       TYPE zexcel_cell_style.

    lo_worksheet = excel->get_worksheet_by_name( ip_sheet_name = ip_worksheet->get_title( ) ).
    IF lo_worksheet <> ip_worksheet.
      Lcx_excel=>raise_text( 'Worksheet doesn''t correspond to workbook of style changer'(001) ).
    ENDIF.

    TRY.
        ip_worksheet->get_cell( EXPORTING ip_column = ip_column
                                          ip_row    = ip_row
                                IMPORTING ep_guid   = l_guid ).
        stylemapping = excel->get_style_to_guid( l_guid ).
      CATCH Lcx_excel.
* Error --> use submitted style
    ENDTRY.


    IF multiple_change_requested-complete = abap_true.
      stylemapping-complete_style = complete_style.
      stylemapping-complete_stylex = complete_stylex.
    ENDIF.

    IF multiple_change_requested-font = abap_true.
      stylemapping-complete_style-font = complete_style-font.
      stylemapping-complete_stylex-font = complete_stylex-font.
    ENDIF.

    IF multiple_change_requested-fill = abap_true.
      stylemapping-complete_style-fill = complete_style-fill.
      stylemapping-complete_stylex-fill = complete_stylex-fill.
    ENDIF.

    IF multiple_change_requested-borders-complete = abap_true.
      stylemapping-complete_style-borders = complete_style-borders.
      stylemapping-complete_stylex-borders = complete_stylex-borders.
    ENDIF.

    IF multiple_change_requested-borders-allborders = abap_true.
      stylemapping-complete_style-borders-allborders = complete_style-borders-allborders.
      stylemapping-complete_stylex-borders-allborders = complete_stylex-borders-allborders.
    ENDIF.

    IF multiple_change_requested-borders-diagonal = abap_true.
      stylemapping-complete_style-borders-diagonal = complete_style-borders-diagonal.
      stylemapping-complete_stylex-borders-diagonal = complete_stylex-borders-diagonal.
    ENDIF.

    IF multiple_change_requested-borders-down = abap_true.
      stylemapping-complete_style-borders-down = complete_style-borders-down.
      stylemapping-complete_stylex-borders-down = complete_stylex-borders-down.
    ENDIF.

    IF multiple_change_requested-borders-left = abap_true.
      stylemapping-complete_style-borders-left = complete_style-borders-left.
      stylemapping-complete_stylex-borders-left = complete_stylex-borders-left.
    ENDIF.

    IF multiple_change_requested-borders-right = abap_true.
      stylemapping-complete_style-borders-right = complete_style-borders-right.
      stylemapping-complete_stylex-borders-right = complete_stylex-borders-right.
    ENDIF.

    IF multiple_change_requested-borders-top = abap_true.
      stylemapping-complete_style-borders-top = complete_style-borders-top.
      stylemapping-complete_stylex-borders-top = complete_stylex-borders-top.
    ENDIF.

    IF multiple_change_requested-alignment = abap_true.
      stylemapping-complete_style-alignment = complete_style-alignment.
      stylemapping-complete_stylex-alignment = complete_stylex-alignment.
    ENDIF.

    IF multiple_change_requested-protection = abap_true.
      stylemapping-complete_style-protection = complete_style-protection.
      stylemapping-complete_stylex-protection = complete_stylex-protection.
    ENDIF.

    IF complete_stylex-number_format = abap_true.
      stylemapping-complete_style-number_format-format_code = complete_style-number_format-format_code.
      stylemapping-complete_stylex-number_format-format_code = abap_true.
    ENDIF.
    IF complete_stylex-font-bold = abap_true.
      stylemapping-complete_style-font-bold = complete_style-font-bold.
      stylemapping-complete_stylex-font-bold = complete_stylex-font-bold.
    ENDIF.
    IF complete_stylex-font-color = abap_true.
      stylemapping-complete_style-font-color = complete_style-font-color.
      stylemapping-complete_stylex-font-color = complete_stylex-font-color.
    ENDIF.
    IF complete_stylex-font-color-rgb = abap_true.
      stylemapping-complete_style-font-color-rgb = complete_style-font-color-rgb.
      stylemapping-complete_stylex-font-color-rgb = complete_stylex-font-color-rgb.
    ENDIF.
    IF complete_stylex-font-color-indexed = abap_true.
      stylemapping-complete_style-font-color-indexed = complete_style-font-color-indexed.
      stylemapping-complete_stylex-font-color-indexed = complete_stylex-font-color-indexed.
    ENDIF.
    IF complete_stylex-font-color-theme = abap_true.
      stylemapping-complete_style-font-color-theme = complete_style-font-color-theme.
      stylemapping-complete_stylex-font-color-theme = complete_stylex-font-color-theme.
    ENDIF.
    IF complete_stylex-font-color-tint = abap_true.
      stylemapping-complete_style-font-color-tint = complete_style-font-color-tint.
      stylemapping-complete_stylex-font-color-tint = complete_stylex-font-color-tint.
    ENDIF.
    IF complete_stylex-font-family = abap_true.
      stylemapping-complete_style-font-family = complete_style-font-family.
      stylemapping-complete_stylex-font-family = complete_stylex-font-family.
    ENDIF.
    IF complete_stylex-font-italic = abap_true.
      stylemapping-complete_style-font-italic = complete_style-font-italic.
      stylemapping-complete_stylex-font-italic = complete_stylex-font-italic.
    ENDIF.
    IF complete_stylex-font-name = abap_true.
      stylemapping-complete_style-font-name = complete_style-font-name.
      stylemapping-complete_stylex-font-name = complete_stylex-font-name.
    ENDIF.
    IF complete_stylex-font-scheme = abap_true.
      stylemapping-complete_style-font-scheme = complete_style-font-scheme.
      stylemapping-complete_stylex-font-scheme = complete_stylex-font-scheme.
    ENDIF.
    IF complete_stylex-font-size = abap_true.
      stylemapping-complete_style-font-size = complete_style-font-size.
      stylemapping-complete_stylex-font-size = complete_stylex-font-size.
    ENDIF.
    IF complete_stylex-font-strikethrough = abap_true.
      stylemapping-complete_style-font-strikethrough = complete_style-font-strikethrough.
      stylemapping-complete_stylex-font-strikethrough = complete_stylex-font-strikethrough.
    ENDIF.
    IF complete_stylex-font-underline = abap_true.
      stylemapping-complete_style-font-underline = complete_style-font-underline.
      stylemapping-complete_stylex-font-underline = complete_stylex-font-underline.
    ENDIF.
    IF complete_stylex-font-underline_mode = abap_true.
      stylemapping-complete_style-font-underline_mode = complete_style-font-underline_mode.
      stylemapping-complete_stylex-font-underline_mode = complete_stylex-font-underline_mode.
    ENDIF.

    IF complete_stylex-fill-filltype = abap_true.
      stylemapping-complete_style-fill-filltype = complete_style-fill-filltype.
      stylemapping-complete_stylex-fill-filltype = complete_stylex-fill-filltype.
    ENDIF.
    IF complete_stylex-fill-rotation = abap_true.
      stylemapping-complete_style-fill-rotation = complete_style-fill-rotation.
      stylemapping-complete_stylex-fill-rotation = complete_stylex-fill-rotation.
    ENDIF.
    IF complete_stylex-fill-fgcolor = abap_true.
      stylemapping-complete_style-fill-fgcolor = complete_style-fill-fgcolor.
      stylemapping-complete_stylex-fill-fgcolor = complete_stylex-fill-fgcolor.
    ENDIF.
    IF complete_stylex-fill-fgcolor-rgb = abap_true.
      stylemapping-complete_style-fill-fgcolor-rgb = complete_style-fill-fgcolor-rgb.
      stylemapping-complete_stylex-fill-fgcolor-rgb = complete_stylex-fill-fgcolor-rgb.
    ENDIF.
    IF complete_stylex-fill-fgcolor-indexed = abap_true.
      stylemapping-complete_style-fill-fgcolor-indexed = complete_style-fill-fgcolor-indexed.
      stylemapping-complete_stylex-fill-fgcolor-indexed = complete_stylex-fill-fgcolor-indexed.
    ENDIF.
    IF complete_stylex-fill-fgcolor-theme = abap_true.
      stylemapping-complete_style-fill-fgcolor-theme = complete_style-fill-fgcolor-theme.
      stylemapping-complete_stylex-fill-fgcolor-theme = complete_stylex-fill-fgcolor-theme.
    ENDIF.
    IF complete_stylex-fill-fgcolor-tint = abap_true.
      stylemapping-complete_style-fill-fgcolor-tint = complete_style-fill-fgcolor-tint.
      stylemapping-complete_stylex-fill-fgcolor-tint = complete_stylex-fill-fgcolor-tint.
    ENDIF.

    IF complete_stylex-fill-bgcolor = abap_true.
      stylemapping-complete_style-fill-bgcolor = complete_style-fill-bgcolor.
      stylemapping-complete_stylex-fill-bgcolor = complete_stylex-fill-bgcolor.
    ENDIF.
    IF complete_stylex-fill-bgcolor-rgb = abap_true.
      stylemapping-complete_style-fill-bgcolor-rgb = complete_style-fill-bgcolor-rgb.
      stylemapping-complete_stylex-fill-bgcolor-rgb = complete_stylex-fill-bgcolor-rgb.
    ENDIF.
    IF complete_stylex-fill-bgcolor-indexed = abap_true.
      stylemapping-complete_style-fill-bgcolor-indexed = complete_style-fill-bgcolor-indexed.
      stylemapping-complete_stylex-fill-bgcolor-indexed = complete_stylex-fill-bgcolor-indexed.
    ENDIF.
    IF complete_stylex-fill-bgcolor-theme = abap_true.
      stylemapping-complete_style-fill-bgcolor-theme = complete_style-fill-bgcolor-theme.
      stylemapping-complete_stylex-fill-bgcolor-theme = complete_stylex-fill-bgcolor-theme.
    ENDIF.
    IF complete_stylex-fill-bgcolor-tint = abap_true.
      stylemapping-complete_style-fill-bgcolor-tint = complete_style-fill-bgcolor-tint.
      stylemapping-complete_stylex-fill-bgcolor-tint = complete_stylex-fill-bgcolor-tint.
    ENDIF.

    IF complete_stylex-fill-gradtype-type = abap_true.
      stylemapping-complete_style-fill-gradtype-type = complete_style-fill-gradtype-type.
      stylemapping-complete_stylex-fill-gradtype-type = complete_stylex-fill-gradtype-type.
    ENDIF.
    IF complete_stylex-fill-gradtype-degree = abap_true.
      stylemapping-complete_style-fill-gradtype-degree = complete_style-fill-gradtype-degree.
      stylemapping-complete_stylex-fill-gradtype-degree = complete_stylex-fill-gradtype-degree.
    ENDIF.
    IF complete_stylex-fill-gradtype-bottom = abap_true.
      stylemapping-complete_style-fill-gradtype-bottom = complete_style-fill-gradtype-bottom.
      stylemapping-complete_stylex-fill-gradtype-bottom = complete_stylex-fill-gradtype-bottom.
    ENDIF.
    IF complete_stylex-fill-gradtype-left = abap_true.
      stylemapping-complete_style-fill-gradtype-left = complete_style-fill-gradtype-left.
      stylemapping-complete_stylex-fill-gradtype-left = complete_stylex-fill-gradtype-left.
    ENDIF.
    IF complete_stylex-fill-gradtype-top = abap_true.
      stylemapping-complete_style-fill-gradtype-top = complete_style-fill-gradtype-top.
      stylemapping-complete_stylex-fill-gradtype-top = complete_stylex-fill-gradtype-top.
    ENDIF.
    IF complete_stylex-fill-gradtype-right = abap_true.
      stylemapping-complete_style-fill-gradtype-right = complete_style-fill-gradtype-right.
      stylemapping-complete_stylex-fill-gradtype-right = complete_stylex-fill-gradtype-right.
    ENDIF.
    IF complete_stylex-fill-gradtype-position1 = abap_true.
      stylemapping-complete_style-fill-gradtype-position1 = complete_style-fill-gradtype-position1.
      stylemapping-complete_stylex-fill-gradtype-position1 = complete_stylex-fill-gradtype-position1.
    ENDIF.
    IF complete_stylex-fill-gradtype-position2 = abap_true.
      stylemapping-complete_style-fill-gradtype-position2 = complete_style-fill-gradtype-position2.
      stylemapping-complete_stylex-fill-gradtype-position2 = complete_stylex-fill-gradtype-position2.
    ENDIF.
    IF complete_stylex-fill-gradtype-position3 = abap_true.
      stylemapping-complete_style-fill-gradtype-position3 = complete_style-fill-gradtype-position3.
      stylemapping-complete_stylex-fill-gradtype-position3 = complete_stylex-fill-gradtype-position3.
    ENDIF.



    IF complete_stylex-borders-diagonal_mode = abap_true.
      stylemapping-complete_style-borders-diagonal_mode = complete_style-borders-diagonal_mode.
      stylemapping-complete_stylex-borders-diagonal_mode = complete_stylex-borders-diagonal_mode.
    ENDIF.
    IF complete_stylex-alignment-horizontal = abap_true.
      stylemapping-complete_style-alignment-horizontal = complete_style-alignment-horizontal.
      stylemapping-complete_stylex-alignment-horizontal = complete_stylex-alignment-horizontal.
    ENDIF.
    IF complete_stylex-alignment-vertical = abap_true.
      stylemapping-complete_style-alignment-vertical = complete_style-alignment-vertical.
      stylemapping-complete_stylex-alignment-vertical = complete_stylex-alignment-vertical.
    ENDIF.
    IF complete_stylex-alignment-textrotation = abap_true.
      stylemapping-complete_style-alignment-textrotation = complete_style-alignment-textrotation.
      stylemapping-complete_stylex-alignment-textrotation = complete_stylex-alignment-textrotation.
    ENDIF.
    IF complete_stylex-alignment-wraptext = abap_true.
      stylemapping-complete_style-alignment-wraptext = complete_style-alignment-wraptext.
      stylemapping-complete_stylex-alignment-wraptext = complete_stylex-alignment-wraptext.
    ENDIF.
    IF complete_stylex-alignment-shrinktofit = abap_true.
      stylemapping-complete_style-alignment-shrinktofit = complete_style-alignment-shrinktofit.
      stylemapping-complete_stylex-alignment-shrinktofit = complete_stylex-alignment-shrinktofit.
    ENDIF.
    IF complete_stylex-alignment-indent = abap_true.
      stylemapping-complete_style-alignment-indent = complete_style-alignment-indent.
      stylemapping-complete_stylex-alignment-indent = complete_stylex-alignment-indent.
    ENDIF.
    IF complete_stylex-protection-hidden = abap_true.
      stylemapping-complete_style-protection-hidden = complete_style-protection-hidden.
      stylemapping-complete_stylex-protection-hidden = complete_stylex-protection-hidden.
    ENDIF.
    IF complete_stylex-protection-locked = abap_true.
      stylemapping-complete_style-protection-locked = complete_style-protection-locked.
      stylemapping-complete_stylex-protection-locked = complete_stylex-protection-locked.
    ENDIF.

    IF complete_stylex-borders-allborders-border_style = abap_true.
      stylemapping-complete_style-borders-allborders-border_style = complete_style-borders-allborders-border_style.
      stylemapping-complete_stylex-borders-allborders-border_style = complete_stylex-borders-allborders-border_style.
    ENDIF.
    IF complete_stylex-borders-allborders-border_color-rgb = abap_true.
      stylemapping-complete_style-borders-allborders-border_color-rgb = complete_style-borders-allborders-border_color-rgb.
      stylemapping-complete_stylex-borders-allborders-border_color-rgb = complete_stylex-borders-allborders-border_color-rgb.
    ENDIF.
    IF complete_stylex-borders-allborders-border_color-indexed = abap_true.
      stylemapping-complete_style-borders-allborders-border_color-indexed = complete_style-borders-allborders-border_color-indexed.
      stylemapping-complete_stylex-borders-allborders-border_color-indexed = complete_stylex-borders-allborders-border_color-indexed.
    ENDIF.
    IF complete_stylex-borders-allborders-border_color-theme = abap_true.
      stylemapping-complete_style-borders-allborders-border_color-theme = complete_style-borders-allborders-border_color-theme.
      stylemapping-complete_stylex-borders-allborders-border_color-theme = complete_stylex-borders-allborders-border_color-theme.
    ENDIF.
    IF complete_stylex-borders-allborders-border_color-tint = abap_true.
      stylemapping-complete_style-borders-allborders-border_color-tint = complete_style-borders-allborders-border_color-tint.
      stylemapping-complete_stylex-borders-allborders-border_color-tint = complete_stylex-borders-allborders-border_color-tint.
    ENDIF.

    IF complete_stylex-borders-diagonal-border_style = abap_true.
      stylemapping-complete_style-borders-diagonal-border_style = complete_style-borders-diagonal-border_style.
      stylemapping-complete_stylex-borders-diagonal-border_style = complete_stylex-borders-diagonal-border_style.
    ENDIF.
    IF complete_stylex-borders-diagonal-border_color-rgb = abap_true.
      stylemapping-complete_style-borders-diagonal-border_color-rgb = complete_style-borders-diagonal-border_color-rgb.
      stylemapping-complete_stylex-borders-diagonal-border_color-rgb = complete_stylex-borders-diagonal-border_color-rgb.
    ENDIF.
    IF complete_stylex-borders-diagonal-border_color-indexed = abap_true.
      stylemapping-complete_style-borders-diagonal-border_color-indexed = complete_style-borders-diagonal-border_color-indexed.
      stylemapping-complete_stylex-borders-diagonal-border_color-indexed = complete_stylex-borders-diagonal-border_color-indexed.
    ENDIF.
    IF complete_stylex-borders-diagonal-border_color-theme = abap_true.
      stylemapping-complete_style-borders-diagonal-border_color-theme = complete_style-borders-diagonal-border_color-theme.
      stylemapping-complete_stylex-borders-diagonal-border_color-theme = complete_stylex-borders-diagonal-border_color-theme.
    ENDIF.
    IF complete_stylex-borders-diagonal-border_color-tint = abap_true.
      stylemapping-complete_style-borders-diagonal-border_color-tint = complete_style-borders-diagonal-border_color-tint.
      stylemapping-complete_stylex-borders-diagonal-border_color-tint = complete_stylex-borders-diagonal-border_color-tint.
    ENDIF.

    IF complete_stylex-borders-down-border_style = abap_true.
      stylemapping-complete_style-borders-down-border_style = complete_style-borders-down-border_style.
      stylemapping-complete_stylex-borders-down-border_style = complete_stylex-borders-down-border_style.
    ENDIF.
    IF complete_stylex-borders-down-border_color-rgb = abap_true.
      stylemapping-complete_style-borders-down-border_color-rgb = complete_style-borders-down-border_color-rgb.
      stylemapping-complete_stylex-borders-down-border_color-rgb = complete_stylex-borders-down-border_color-rgb.
    ENDIF.
    IF complete_stylex-borders-down-border_color-indexed = abap_true.
      stylemapping-complete_style-borders-down-border_color-indexed = complete_style-borders-down-border_color-indexed.
      stylemapping-complete_stylex-borders-down-border_color-indexed = complete_stylex-borders-down-border_color-indexed.
    ENDIF.
    IF complete_stylex-borders-down-border_color-theme = abap_true.
      stylemapping-complete_style-borders-down-border_color-theme = complete_style-borders-down-border_color-theme.
      stylemapping-complete_stylex-borders-down-border_color-theme = complete_stylex-borders-down-border_color-theme.
    ENDIF.
    IF complete_stylex-borders-down-border_color-tint = abap_true.
      stylemapping-complete_style-borders-down-border_color-tint = complete_style-borders-down-border_color-tint.
      stylemapping-complete_stylex-borders-down-border_color-tint = complete_stylex-borders-down-border_color-tint.
    ENDIF.

    IF complete_stylex-borders-left-border_style = abap_true.
      stylemapping-complete_style-borders-left-border_style = complete_style-borders-left-border_style.
      stylemapping-complete_stylex-borders-left-border_style = complete_stylex-borders-left-border_style.
    ENDIF.
    IF complete_stylex-borders-left-border_color-rgb = abap_true.
      stylemapping-complete_style-borders-left-border_color-rgb = complete_style-borders-left-border_color-rgb.
      stylemapping-complete_stylex-borders-left-border_color-rgb = complete_stylex-borders-left-border_color-rgb.
    ENDIF.
    IF complete_stylex-borders-left-border_color-indexed = abap_true.
      stylemapping-complete_style-borders-left-border_color-indexed = complete_style-borders-left-border_color-indexed.
      stylemapping-complete_stylex-borders-left-border_color-indexed = complete_stylex-borders-left-border_color-indexed.
    ENDIF.
    IF complete_stylex-borders-left-border_color-theme = abap_true.
      stylemapping-complete_style-borders-left-border_color-theme = complete_style-borders-left-border_color-theme.
      stylemapping-complete_stylex-borders-left-border_color-theme = complete_stylex-borders-left-border_color-theme.
    ENDIF.
    IF complete_stylex-borders-left-border_color-tint = abap_true.
      stylemapping-complete_style-borders-left-border_color-tint = complete_style-borders-left-border_color-tint.
      stylemapping-complete_stylex-borders-left-border_color-tint = complete_stylex-borders-left-border_color-tint.
    ENDIF.

    IF complete_stylex-borders-right-border_style = abap_true.
      stylemapping-complete_style-borders-right-border_style = complete_style-borders-right-border_style.
      stylemapping-complete_stylex-borders-right-border_style = complete_stylex-borders-right-border_style.
    ENDIF.
    IF complete_stylex-borders-right-border_color-rgb = abap_true.
      stylemapping-complete_style-borders-right-border_color-rgb = complete_style-borders-right-border_color-rgb.
      stylemapping-complete_stylex-borders-right-border_color-rgb = complete_stylex-borders-right-border_color-rgb.
    ENDIF.
    IF complete_stylex-borders-right-border_color-indexed = abap_true.
      stylemapping-complete_style-borders-right-border_color-indexed = complete_style-borders-right-border_color-indexed.
      stylemapping-complete_stylex-borders-right-border_color-indexed = complete_stylex-borders-right-border_color-indexed.
    ENDIF.
    IF complete_stylex-borders-right-border_color-theme = abap_true.
      stylemapping-complete_style-borders-right-border_color-theme = complete_style-borders-right-border_color-theme.
      stylemapping-complete_stylex-borders-right-border_color-theme = complete_stylex-borders-right-border_color-theme.
    ENDIF.
    IF complete_stylex-borders-right-border_color-tint = abap_true.
      stylemapping-complete_style-borders-right-border_color-tint = complete_style-borders-right-border_color-tint.
      stylemapping-complete_stylex-borders-right-border_color-tint = complete_stylex-borders-right-border_color-tint.
    ENDIF.

    IF complete_stylex-borders-top-border_style = abap_true.
      stylemapping-complete_style-borders-top-border_style = complete_style-borders-top-border_style.
      stylemapping-complete_stylex-borders-top-border_style = complete_stylex-borders-top-border_style.
    ENDIF.
    IF complete_stylex-borders-top-border_color-rgb = abap_true.
      stylemapping-complete_style-borders-top-border_color-rgb = complete_style-borders-top-border_color-rgb.
      stylemapping-complete_stylex-borders-top-border_color-rgb = complete_stylex-borders-top-border_color-rgb.
    ENDIF.
    IF complete_stylex-borders-top-border_color-indexed = abap_true.
      stylemapping-complete_style-borders-top-border_color-indexed = complete_style-borders-top-border_color-indexed.
      stylemapping-complete_stylex-borders-top-border_color-indexed = complete_stylex-borders-top-border_color-indexed.
    ENDIF.
    IF complete_stylex-borders-top-border_color-theme = abap_true.
      stylemapping-complete_style-borders-top-border_color-theme = complete_style-borders-top-border_color-theme.
      stylemapping-complete_stylex-borders-top-border_color-theme = complete_stylex-borders-top-border_color-theme.
    ENDIF.
    IF complete_stylex-borders-top-border_color-tint = abap_true.
      stylemapping-complete_style-borders-top-border_color-tint = complete_style-borders-top-border_color-tint.
      stylemapping-complete_stylex-borders-top-border_color-tint = complete_stylex-borders-top-border_color-tint.
    ENDIF.


* Now we have a completly filled styles.
* This can be used to get the guid
* Return guid if requested.  Might be used if copy&paste of styles is requested
    ep_guid = me->excel->get_static_cellstyle_guid( ip_cstyle_complete  = stylemapping-complete_style
                                                   ip_cstylex_complete = stylemapping-complete_stylex  ).
    lo_worksheet->set_cell_style( ip_column = ip_column
                                  ip_row    = ip_row
                                  ip_style  = ep_guid ).

  ENDMETHOD.
  METHOD Lif_excel_style_changer~get_guid.

    result = excel->get_static_cellstyle_guid( ip_cstyle_complete  = complete_style
                                               ip_cstylex_complete = complete_stylex  ).

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_alignment_horizontal.

    complete_style-alignment-horizontal = value.
    complete_stylex-alignment-horizontal = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_alignment_indent.

    complete_style-alignment-indent = value.
    complete_stylex-alignment-indent = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_alignment_shrinktofit.

    complete_style-alignment-shrinktofit = value.
    complete_stylex-alignment-shrinktofit = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_alignment_textrotation.

    complete_style-alignment-textrotation = value.
    complete_stylex-alignment-textrotation = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_alignment_vertical.

    complete_style-alignment-vertical = value.
    complete_stylex-alignment-vertical = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_alignment_wraptext.

    complete_style-alignment-wraptext = value.
    complete_stylex-alignment-wraptext = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_allborders_color.

    complete_style-borders-allborders-border_color = value.
    complete_stylex-borders-allborders-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_allborders_style.

    complete_style-borders-allborders-border_style = value.
    complete_stylex-borders-allborders-border_style = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_allbo_color_indexe.

    complete_style-borders-allborders-border_color-indexed = value.
    complete_stylex-borders-allborders-border_color-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_allbo_color_rgb.

    complete_style-borders-allborders-border_color-rgb = value.
    complete_stylex-borders-allborders-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_allbo_color_theme.

    complete_style-borders-allborders-border_color-theme = value.
    complete_stylex-borders-allborders-border_color-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_allbo_color_tint.

    complete_style-borders-allborders-border_color-tint = value.
    complete_stylex-borders-allborders-border_color-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_diagonal_color.

    complete_style-borders-diagonal-border_color = value.
    complete_stylex-borders-diagonal-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_diagonal_color_ind.

    complete_style-borders-diagonal-border_color-indexed = value.
    complete_stylex-borders-diagonal-border_color-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_diagonal_color_rgb.

    complete_style-borders-diagonal-border_color-rgb = value.
    complete_stylex-borders-diagonal-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_diagonal_color_the.

    complete_style-borders-diagonal-border_color-theme = value.
    complete_stylex-borders-diagonal-border_color-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_diagonal_color_tin.

    complete_style-borders-diagonal-border_color-tint = value.
    complete_stylex-borders-diagonal-border_color-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_diagonal_mode.

    complete_style-borders-diagonal_mode = value.
    complete_stylex-borders-diagonal_mode = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_diagonal_style.

    complete_style-borders-diagonal-border_style = value.
    complete_stylex-borders-diagonal-border_style = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_down_color.

    complete_style-borders-down-border_color = value.
    complete_stylex-borders-down-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_down_color_indexed.

    complete_style-borders-down-border_color-indexed = value.
    complete_stylex-borders-down-border_color-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_down_color_rgb.

    complete_style-borders-down-border_color-rgb = value.
    complete_stylex-borders-down-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_down_color_theme.

    complete_style-borders-down-border_color-theme = value.
    complete_stylex-borders-down-border_color-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_down_color_tint.

    complete_style-borders-down-border_color-tint = value.
    complete_stylex-borders-down-border_color-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_down_style.

    complete_style-borders-down-border_style = value.
    complete_stylex-borders-down-border_style = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_left_color.

    complete_style-borders-left-border_color = value.
    complete_stylex-borders-left-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_left_color_indexed.

    complete_style-borders-left-border_color-indexed = value.
    complete_stylex-borders-left-border_color-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_left_color_rgb.

    complete_style-borders-left-border_color-rgb = value.
    complete_stylex-borders-left-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_left_color_theme.

    complete_style-borders-left-border_color-theme = value.
    complete_stylex-borders-left-border_color-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_left_color_tint.

    complete_style-borders-left-border_color-tint = value.
    complete_stylex-borders-left-border_color-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_left_style.

    complete_style-borders-left-border_style = value.
    complete_stylex-borders-left-border_style = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_right_color.

    complete_style-borders-right-border_color = value.
    complete_stylex-borders-right-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_right_color_indexe.

    complete_style-borders-right-border_color-indexed = value.
    complete_stylex-borders-right-border_color-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_right_color_rgb.

    complete_style-borders-right-border_color-rgb = value.
    complete_stylex-borders-right-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_right_color_theme.

    complete_style-borders-right-border_color-theme = value.
    complete_stylex-borders-right-border_color-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_right_color_tint.

    complete_style-borders-right-border_color-tint = value.
    complete_stylex-borders-right-border_color-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_right_style.

    complete_style-borders-right-border_style = value.
    complete_stylex-borders-right-border_style = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_top_color.

    complete_style-borders-top-border_color = value.
    complete_stylex-borders-top-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_top_color_indexed.

    complete_style-borders-top-border_color-indexed = value.
    complete_stylex-borders-top-border_color-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_top_color_rgb.

    complete_style-borders-top-border_color-rgb = value.
    complete_stylex-borders-top-border_color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_top_color_theme.

    complete_style-borders-top-border_color-theme = value.
    complete_stylex-borders-top-border_color-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_top_color_tint.

    complete_style-borders-top-border_color-tint = value.
    complete_stylex-borders-top-border_color-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_borders_top_style.

    complete_style-borders-top-border_style = value.
    complete_stylex-borders-top-border_style = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete.

    complete_style = ip_complete.
    complete_stylex = ip_xcomplete.
    multiple_change_requested-complete = abap_true.
    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_alignment.

    DATA: alignmentx LIKE ip_xalignment.

    IF ip_xalignment IS SUPPLIED.
      alignmentx = ip_xalignment.
    ELSE.
      CLEAR alignmentx WITH 'X'.
      IF ip_alignment-horizontal IS INITIAL.
        CLEAR alignmentx-horizontal.
      ENDIF.
      IF ip_alignment-vertical IS INITIAL.
        CLEAR alignmentx-vertical.
      ENDIF.
    ENDIF.

    complete_style-alignment  = ip_alignment .
    complete_stylex-alignment = alignmentx   .
    multiple_change_requested-alignment = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_borders.

    DATA: bordersx LIKE ip_xborders.
    IF ip_xborders IS SUPPLIED.
      bordersx = ip_xborders.
    ELSE.
      CLEAR bordersx WITH 'X'.
      IF ip_borders-allborders-border_style IS INITIAL.
        CLEAR bordersx-allborders-border_style.
      ENDIF.
      IF ip_borders-diagonal-border_style IS INITIAL.
        CLEAR bordersx-diagonal-border_style.
      ENDIF.
      IF ip_borders-down-border_style IS INITIAL.
        CLEAR bordersx-down-border_style.
      ENDIF.
      IF ip_borders-left-border_style IS INITIAL.
        CLEAR bordersx-left-border_style.
      ENDIF.
      IF ip_borders-right-border_style IS INITIAL.
        CLEAR bordersx-right-border_style.
      ENDIF.
      IF ip_borders-top-border_style IS INITIAL.
        CLEAR bordersx-top-border_style.
      ENDIF.

      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_borders-allborders-border_color
        CHANGING
          cs_xcolor = bordersx-allborders-border_color ).

      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_borders-diagonal-border_color
        CHANGING
          cs_xcolor = bordersx-diagonal-border_color ).

      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_borders-down-border_color
        CHANGING
          cs_xcolor = bordersx-down-border_color ).

      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_borders-left-border_color
        CHANGING
          cs_xcolor = bordersx-left-border_color ).

      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_borders-right-border_color
        CHANGING
          cs_xcolor = bordersx-right-border_color ).

      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_borders-top-border_color
        CHANGING
          cs_xcolor = bordersx-top-border_color ).

    ENDIF.

    complete_style-borders = ip_borders.
    complete_stylex-borders = bordersx.
    multiple_change_requested-borders-complete = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_borders_all.

    lv_xborder_supplied = boolc( ip_xborders_allborders IS SUPPLIED ).
    move_supplied_borders(
      EXPORTING
        iv_border_supplied        = lv_border_supplied
        is_border                 = ip_borders_allborders
        iv_xborder_supplied       = lv_xborder_supplied
        is_xborder                = ip_xborders_allborders
      CHANGING
        cs_complete_style_border  = complete_style-borders-allborders
        cs_complete_stylex_border = complete_stylex-borders-allborders ).
    multiple_change_requested-borders-allborders = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_borders_diagonal.

    lv_xborder_supplied = boolc( ip_xborders_diagonal IS SUPPLIED ).
    move_supplied_borders(
      EXPORTING
        iv_border_supplied        = lv_border_supplied
        is_border                 = ip_borders_diagonal
        iv_xborder_supplied       = lv_xborder_supplied
        is_xborder                = ip_xborders_diagonal
      CHANGING
        cs_complete_style_border  = complete_style-borders-diagonal
        cs_complete_stylex_border = complete_stylex-borders-diagonal ).
    multiple_change_requested-borders-diagonal = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_borders_down.

    lv_xborder_supplied = boolc( ip_xborders_down IS SUPPLIED ).
    move_supplied_borders(
      EXPORTING
        iv_border_supplied        = lv_border_supplied
        is_border                 = ip_borders_down
        iv_xborder_supplied       = lv_xborder_supplied
        is_xborder                = ip_xborders_down
      CHANGING
        cs_complete_style_border  = complete_style-borders-down
        cs_complete_stylex_border = complete_stylex-borders-down ).
    multiple_change_requested-borders-down = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_borders_left.

    lv_xborder_supplied = boolc( ip_xborders_left IS SUPPLIED ).
    move_supplied_borders(
      EXPORTING
        iv_border_supplied        = lv_border_supplied
        is_border                 = ip_borders_left
        iv_xborder_supplied       = lv_xborder_supplied
        is_xborder                = ip_xborders_left
      CHANGING
        cs_complete_style_border  = complete_style-borders-left
        cs_complete_stylex_border = complete_stylex-borders-left ).
    multiple_change_requested-borders-left = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_borders_right.

    lv_xborder_supplied = boolc( ip_xborders_right IS SUPPLIED ).
    move_supplied_borders(
      EXPORTING
        iv_border_supplied        = lv_border_supplied
        is_border                 = ip_borders_right
        iv_xborder_supplied       = lv_xborder_supplied
        is_xborder                = ip_xborders_right
      CHANGING
        cs_complete_style_border  = complete_style-borders-right
        cs_complete_stylex_border = complete_stylex-borders-right ).
    multiple_change_requested-borders-right = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_borders_top.

    lv_xborder_supplied = boolc( ip_xborders_top IS SUPPLIED ).
    move_supplied_borders(
      EXPORTING
        iv_border_supplied        = lv_border_supplied
        is_border                 = ip_borders_top
        iv_xborder_supplied       = lv_xborder_supplied
        is_xborder                = ip_xborders_top
      CHANGING
        cs_complete_style_border  = complete_style-borders-top
        cs_complete_stylex_border = complete_stylex-borders-top ).
    multiple_change_requested-borders-top = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_fill.

    DATA: fillx LIKE ip_xfill.
    IF ip_xfill IS SUPPLIED.
      fillx = ip_xfill.
    ELSE.
      CLEAR fillx WITH 'X'.
      IF ip_fill-filltype IS INITIAL.
        CLEAR fillx-filltype.
      ENDIF.
      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_fill-fgcolor
        CHANGING
          cs_xcolor = fillx-fgcolor ).
      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_fill-bgcolor
        CHANGING
          cs_xcolor = fillx-bgcolor ).

    ENDIF.

    complete_style-fill = ip_fill.
    complete_stylex-fill = fillx.
    multiple_change_requested-fill = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_font.

    DATA: fontx TYPE zexcel_s_cstylex_font.

    IF ip_xfont IS SUPPLIED.
      fontx = ip_xfont.
    ELSE.
* Only supplied values should be used - exception: Flags bold and italic strikethrough underline
      fontx-bold = 'X'.
      fontx-italic = 'X'.
      fontx-strikethrough = 'X'.
      fontx-underline_mode = 'X'.
      CLEAR fontx-color WITH 'X'.
      clear_initial_colorxfields(
        EXPORTING
          is_color  = ip_font-color
        CHANGING
          cs_xcolor = fontx-color ).
      IF ip_font-family IS NOT INITIAL.
        fontx-family = 'X'.
      ENDIF.
      IF ip_font-name IS NOT INITIAL.
        fontx-name = 'X'.
      ENDIF.
      IF ip_font-scheme IS NOT INITIAL.
        fontx-scheme = 'X'.
      ENDIF.
      IF ip_font-size IS NOT INITIAL.
        fontx-size = 'X'.
      ENDIF.
      IF ip_font-underline_mode IS NOT INITIAL.
        fontx-underline_mode = 'X'.
      ENDIF.
    ENDIF.

    complete_style-font = ip_font.
    complete_stylex-font = fontx.
    multiple_change_requested-font = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_complete_protection.

    MOVE-CORRESPONDING ip_protection  TO complete_style-protection.
    IF ip_xprotection IS SUPPLIED.
      MOVE-CORRESPONDING ip_xprotection TO complete_stylex-protection.
    ELSE.
      IF ip_protection-hidden IS NOT INITIAL.
        complete_stylex-protection-hidden = 'X'.
      ENDIF.
      IF ip_protection-locked IS NOT INITIAL.
        complete_stylex-protection-locked = 'X'.
      ENDIF.
    ENDIF.
    multiple_change_requested-protection = abap_true.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_bgcolor.

    complete_style-fill-bgcolor = value.
    complete_stylex-fill-bgcolor-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_bgcolor_indexed.

    complete_style-fill-bgcolor-indexed = value.
    complete_stylex-fill-bgcolor-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_bgcolor_rgb.

    complete_style-fill-bgcolor-rgb = value.
    complete_stylex-fill-bgcolor-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_bgcolor_theme.

    complete_style-fill-bgcolor-theme = value.
    complete_stylex-fill-bgcolor-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_bgcolor_tint.

    complete_style-fill-bgcolor-tint = value.
    complete_stylex-fill-bgcolor-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_fgcolor.

    complete_style-fill-fgcolor = value.
    complete_stylex-fill-fgcolor-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_fgcolor_indexed.

    complete_style-fill-fgcolor-indexed = value.
    complete_stylex-fill-fgcolor-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_fgcolor_rgb.

    complete_style-fill-fgcolor-rgb = value.
    complete_stylex-fill-fgcolor-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_fgcolor_theme.

    complete_style-fill-fgcolor-theme = value.
    complete_stylex-fill-fgcolor-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_fgcolor_tint.

    complete_style-fill-fgcolor-tint = value.
    complete_stylex-fill-fgcolor-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_filltype.

    complete_style-fill-filltype = value.
    complete_stylex-fill-filltype = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_bottom.

    complete_style-fill-gradtype-bottom = value.
    complete_stylex-fill-gradtype-bottom = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_degree.

    complete_style-fill-gradtype-degree = value.
    complete_stylex-fill-gradtype-degree = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_left.

    complete_style-fill-gradtype-left = value.
    complete_stylex-fill-gradtype-left = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_position1.

    complete_style-fill-gradtype-position1 = value.
    complete_stylex-fill-gradtype-position1 = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_position2.

    complete_style-fill-gradtype-position2 = value.
    complete_stylex-fill-gradtype-position2 = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_position3.

    complete_style-fill-gradtype-position3 = value.
    complete_stylex-fill-gradtype-position3 = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_right.

    complete_style-fill-gradtype-right = value.
    complete_stylex-fill-gradtype-right = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_top.

    complete_style-fill-gradtype-top = value.
    complete_stylex-fill-gradtype-top = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_gradtype_type.

    complete_style-fill-gradtype-type = value.
    complete_stylex-fill-gradtype-type = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_fill_rotation.

    complete_style-fill-rotation = value.
    complete_stylex-fill-rotation = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_bold.

    complete_style-font-bold = value.
    complete_stylex-font-bold = 'X'.
    single_change_requested-font-bold = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_color.

    complete_style-font-color = value.
    complete_stylex-font-color-rgb = 'X'.
    single_change_requested-font-color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_color_indexed.

    complete_style-font-color-indexed = value.
    complete_stylex-font-color-indexed = 'X'.
    single_change_requested-font-color-indexed = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_color_rgb.

    complete_style-font-color-rgb = value.
    complete_stylex-font-color-rgb = 'X'.
    single_change_requested-font-color-rgb = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_color_theme.

    complete_style-font-color-theme = value.
    complete_stylex-font-color-theme = 'X'.
    single_change_requested-font-color-theme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_color_tint.

    complete_style-font-color-tint = value.
    complete_stylex-font-color-tint = 'X'.
    single_change_requested-font-color-tint = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_family.

    complete_style-font-family = value.
    complete_stylex-font-family = 'X'.
    single_change_requested-font-family = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_italic.

    complete_style-font-italic = value.
    complete_stylex-font-italic = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_name.

    complete_style-font-name = value.
    complete_stylex-font-name = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_scheme.

    complete_style-font-scheme = value.
    complete_stylex-font-scheme = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_size.

    complete_style-font-size = value.
    complete_stylex-font-size = abap_true.
    single_change_requested-font-size = abap_true.
    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_strikethrough.

    complete_style-font-strikethrough = value.
    complete_stylex-font-strikethrough = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_underline.

    complete_style-font-underline = value.
    complete_stylex-font-underline = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_font_underline_mode.

    complete_style-font-underline_mode = value.
    complete_stylex-font-underline_mode = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_number_format.

    complete_style-number_format-format_code = value.
    complete_stylex-number_format-format_code = abap_true.
    single_change_requested-number_format-format_code = abap_true.
    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_protection_hidden.

    complete_style-protection-hidden = value.
    complete_stylex-protection-hidden = 'X'.

    result = me.

  ENDMETHOD.
  METHOD Lif_excel_style_changer~set_protection_locked.

    complete_style-protection-locked = value.
    complete_stylex-protection-locked = 'X'.

    result = me.

  ENDMETHOD.
endclass. "LCL_EXCEL_STYLE_CHANGER implementation

*>>>>>>> LCL_EXCEL_WRITER_CSV <<<<<<<*

*"* macro definitions
*include Lcl_excel_writer_csv==========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_writer_csv==========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


class LCL_EXCEL_WRITER_CSV implementation.
*"* method's implementations
*include methods.
  METHOD create.

* .csv format with ; delimiter

* Start of insertion # issue 1134 - Dateretention of cellstyles(issue #139)
    me->excel->add_static_styles( ).
* End of insertion # issue 1134 - Dateretention of cellstyles(issue #139)

    ep_excel = me->create_csv( ).

  ENDMETHOD.
  METHOD create_csv.

    TYPES: BEGIN OF lty_format,
             cmpname  TYPE seocmpname,
             attvalue TYPE seovalue,
           END OF lty_format.
    DATA: lt_format TYPE STANDARD TABLE OF lty_format,
          ls_format LIKE LINE OF lt_format,
          lv_date   TYPE d,
          lv_tmp    TYPE string,
          lv_time   TYPE c LENGTH 8.

    DATA: lo_iterator  TYPE REF TO Lcl_excel_collection_iterator,
          lo_worksheet TYPE REF TO Lcl_excel_worksheet.

    DATA: lt_cell_data TYPE zexcel_t_cell_data_unsorted,
          lv_row       TYPE i,
          lv_col       TYPE i,
          lv_string    TYPE string,
          lc_value     TYPE string,
          lv_attrname  TYPE seocmpname.

    DATA: ls_numfmt TYPE zexcel_s_style_numfmt,
          lo_style  TYPE REF TO Lcl_excel_style.

    FIELD-SYMBOLS: <fs_sheet_content> TYPE zexcel_s_cell_data.

* --- Retrieve supported cell format
    SELECT * INTO CORRESPONDING FIELDS OF TABLE lt_format
      FROM seocompodf
     WHERE clsname  = 'LCL_EXCEL_STYLE_NUMBER_FORMAT'
       AND typtype  = 1
       AND type     = 'ZEXCEL_NUMBER_FORMAT'.

* --- Retrieve SAP date format
    CLEAR ls_format.
    SELECT ddtext INTO ls_format-attvalue FROM dd07t WHERE domname    = 'XUDATFM'
                                                       AND ddlanguage = sy-langu.
      ls_format-cmpname = 'DATE'.
      CONDENSE ls_format-attvalue.
      CONCATENATE '''' ls_format-attvalue '''' INTO ls_format-attvalue.
      APPEND ls_format TO lt_format.
    ENDSELECT.


    LOOP AT lt_format INTO ls_format.
      TRANSLATE ls_format-attvalue TO UPPER CASE.
      MODIFY lt_format FROM ls_format.
    ENDLOOP.


* STEP 1: Collect strings from the first worksheet
    lo_iterator = excel->get_worksheets_iterator( ).
    DATA: current_worksheet_title TYPE zexcel_sheet_title.

    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_worksheet ?= lo_iterator->get_next( ).

      IF worksheet_name IS NOT INITIAL.
        current_worksheet_title = lo_worksheet->get_title( ).
        CHECK current_worksheet_title = worksheet_name.
      ELSE.
        IF worksheet_index IS INITIAL.
          worksheet_index = 1.
        ENDIF.
        CHECK worksheet_index = sy-index.
      ENDIF.
      APPEND LINES OF lo_worksheet->sheet_content TO lt_cell_data.
      EXIT. " Take first worksheet only
    ENDWHILE.

    DELETE lt_cell_data WHERE cell_formula IS NOT INITIAL. " delete formula content

    SORT lt_cell_data BY cell_row
                         cell_column.
    lv_row = 1.
    lv_col = 1.
    CLEAR lv_string.
    LOOP AT lt_cell_data ASSIGNING <fs_sheet_content>.

*   --- Retrieve Cell Style format and data type
      CLEAR ls_numfmt.
      IF <fs_sheet_content>-data_type IS INITIAL AND <fs_sheet_content>-cell_style IS NOT INITIAL.
        lo_iterator = excel->get_styles_iterator( ).
        WHILE lo_iterator->has_next( ) EQ abap_true.
          lo_style ?= lo_iterator->get_next( ).
          CHECK lo_style->get_guid( ) = <fs_sheet_content>-cell_style.
          ls_numfmt     = lo_style->number_format->get_structure( ).
          EXIT.
        ENDWHILE.
      ENDIF.
      IF <fs_sheet_content>-data_type IS INITIAL AND ls_numfmt IS NOT INITIAL.
        " determine data-type
        CLEAR lv_attrname.
        CONCATENATE '''' ls_numfmt-numfmt '''' INTO ls_numfmt-numfmt.
        TRANSLATE ls_numfmt-numfmt TO UPPER CASE.
        READ TABLE lt_format INTO ls_format WITH KEY attvalue = ls_numfmt-numfmt.
        IF sy-subrc = 0.
          lv_attrname = ls_format-cmpname.
        ENDIF.

        IF lv_attrname IS NOT INITIAL.
          FIND FIRST OCCURRENCE OF 'DATETIME' IN lv_attrname.
          IF sy-subrc = 0.
            <fs_sheet_content>-data_type = 'd'.
          ELSE.
            FIND FIRST OCCURRENCE OF 'TIME' IN lv_attrname.
            IF sy-subrc = 0.
              <fs_sheet_content>-data_type = 't'.
            ELSE.
              FIND FIRST OCCURRENCE OF 'DATE' IN lv_attrname.
              IF sy-subrc = 0.
                <fs_sheet_content>-data_type = 'd'.
              ELSE.
                FIND FIRST OCCURRENCE OF 'CURRENCY' IN lv_attrname.
                IF sy-subrc = 0.
                  <fs_sheet_content>-data_type = 'n'.
                ELSE.
                  FIND FIRST OCCURRENCE OF 'NUMBER' IN lv_attrname.
                  IF sy-subrc = 0.
                    <fs_sheet_content>-data_type = 'n'.
                  ELSE.
                    FIND FIRST OCCURRENCE OF 'PERCENTAGE' IN lv_attrname.
                    IF sy-subrc = 0.
                      <fs_sheet_content>-data_type = 'n'.
                    ENDIF. " Purcentage
                  ENDIF. " Number
                ENDIF. " Currency
              ENDIF. " Date
            ENDIF. " TIME
          ENDIF. " DATETIME
        ENDIF. " lv_attrname IS NOT INITIAL.
      ENDIF. " <fs_sheet_content>-data_type IS INITIAL AND ls_numfmt IS NOT INITIAL.

* --- Add empty rows
      WHILE lv_row < <fs_sheet_content>-cell_row.
        CONCATENATE lv_string Lcl_excel_writer_csv=>eol INTO lv_string.
        lv_row = lv_row + 1.
        lv_col = 1.
      ENDWHILE.

* --- Add empty columns
      WHILE lv_col < <fs_sheet_content>-cell_column.
        CONCATENATE lv_string Lcl_excel_writer_csv=>delimiter INTO lv_string.
        lv_col = lv_col + 1.
      ENDWHILE.

* ----- Use format to determine the data type and display format.
      CASE <fs_sheet_content>-data_type.

        WHEN 'd' OR 'D'.
          lc_value = Lcl_excel_common=>excel_string_to_date( ip_value = <fs_sheet_content>-cell_value ).
          TRY.
              lv_date = lc_value.
              CALL FUNCTION 'CONVERT_DATE_TO_EXTERNAL'
                EXPORTING
                  date_internal            = lv_date
                IMPORTING
                  date_external            = lv_tmp
                EXCEPTIONS
                  date_internal_is_invalid = 1
                  OTHERS                   = 2.
              IF sy-subrc = 0.
                lc_value = lv_tmp.
              ENDIF.

            CATCH cx_sy_conversion_no_number.

          ENDTRY.

        WHEN 't' OR 'T'.
          lc_value = Lcl_excel_common=>excel_string_to_time( ip_value = <fs_sheet_content>-cell_value ).
          WRITE lc_value TO lv_time USING EDIT MASK '__:__:__'.
          lc_value = lv_time.
        WHEN OTHERS.
          lc_value = <fs_sheet_content>-cell_value.

      ENDCASE.

      CONCATENATE Lcl_excel_writer_csv=>enclosure Lcl_excel_writer_csv=>enclosure INTO lv_tmp.
      CONDENSE lv_tmp.
      REPLACE ALL OCCURRENCES OF Lcl_excel_writer_csv=>enclosure IN lc_value WITH lv_tmp.

      FIND FIRST OCCURRENCE OF Lcl_excel_writer_csv=>delimiter IN lc_value.
      IF sy-subrc = 0.
        CONCATENATE lv_string Lcl_excel_writer_csv=>enclosure lc_value Lcl_excel_writer_csv=>enclosure INTO lv_string.
      ELSE.
        CONCATENATE lv_string lc_value INTO lv_string.
      ENDIF.

    ENDLOOP.

    CLEAR ep_content.

    CALL FUNCTION 'SCMS_STRING_TO_XSTRING'
      EXPORTING
        text   = lv_string
      IMPORTING
        buffer = ep_content
      EXCEPTIONS
        failed = 1
        OTHERS = 2.

  ENDMETHOD.
  METHOD set_active_sheet_index.
    CLEAR worksheet_name.
    worksheet_index = i_active_worksheet.
  ENDMETHOD.
  METHOD set_active_sheet_index_by_name.
    CLEAR worksheet_index.
    worksheet_name = i_worksheet_name.
  ENDMETHOD.
  METHOD set_delimiter.
    delimiter = ip_value.
  ENDMETHOD.
  METHOD set_enclosure.
    Lcl_excel_writer_csv=>enclosure = ip_value.
  ENDMETHOD.
  METHOD set_endofline.
    Lcl_excel_writer_csv=>eol = ip_value.
  ENDMETHOD.
  METHOD Lif_excel_writer~write_file.
    me->excel = io_excel.
    ep_file = me->create( ).
  ENDMETHOD.
endclass. "LCL_EXCEL_WRITER_CSV implementation

*>>>>>>> LCL_EXCEL_COMMON <<<<<<<*

*"* macro definitions
*include Lcl_excel_common==============ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_common==============ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


*"* test class
*include Lcl_excel_common==============ccau.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABCSE4 DEFINITION DEFERRED.
*CLASS Lcl_excel_common DEFINITION LOCAL FRIENDS SHRITEFUH64VYIPN5I4UIDBJABCSE4.

*----------------------------------------------------------------------*
*       CLASS SHRITEFUH64VYIPN5I4UIDBJABCSE4 DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*


*----------------------------------------------------------------------*
*       CLASS SHRITEFUH64VYIPN5I4UIDBJABCSE4 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*

class LCL_EXCEL_COMMON implementation.
*"* method's implementations
*include methods.
  METHOD calculate_cell_distance.

    DATA: lv_reference_row       TYPE i,
          lv_reference_col_alpha TYPE zexcel_cell_column_alpha,
          lv_reference_col       TYPE i,
          lv_current_row         TYPE i,
          lv_current_col_alpha   TYPE zexcel_cell_column_alpha,
          lv_current_col         TYPE i.

*--------------------------------------------------------------------*
* Split reference  cell into numerical row/column representation
*--------------------------------------------------------------------*
    convert_columnrow2column_a_row( EXPORTING
                                      i_columnrow = iv_reference_cell
                                    IMPORTING
                                      e_column    = lv_reference_col_alpha
                                      e_row       = lv_reference_row ).
    lv_reference_col = convert_column2int( lv_reference_col_alpha ).

*--------------------------------------------------------------------*
* Split current  cell into numerical row/column representation
*--------------------------------------------------------------------*
    convert_columnrow2column_a_row( EXPORTING
                                      i_columnrow = iv_current_cell
                                    IMPORTING
                                      e_column    = lv_current_col_alpha
                                      e_row       = lv_current_row ).
    lv_current_col = convert_column2int( lv_current_col_alpha ).

*--------------------------------------------------------------------*
* Calculate row and column difference
* Positive:   Current cell below    reference cell
*         or  Current cell right of reference cell
* Negative:   Current cell above    reference cell
*         or  Current cell left  of reference cell
*--------------------------------------------------------------------*
    ev_row_difference = lv_current_row - lv_reference_row.
    ev_col_difference = lv_current_col - lv_reference_col.

  ENDMETHOD.
  METHOD char2hex.

    IF o_conv IS NOT BOUND.
      o_conv = cl_abap_conv_out_ce=>create( endian   = 'L'
                                            ignore_cerr = abap_true
                                            replacement = '#' ).
    ENDIF.

    CALL METHOD o_conv->reset( ).
    CALL METHOD o_conv->write( data = i_char ).
    r_hex+1 = o_conv->get_buffer( ). " x'65' must be x'0065'

  ENDMETHOD.
  METHOD class_constructor.
    c_xlsx_file_filter = 'Excel Workbook (*.xlsx)|*.xlsx|'(005).
  ENDMETHOD.
  METHOD clone_ixml_with_namespaces.

    DATA: iterator    TYPE REF TO if_ixml_node_iterator,
          node        TYPE REF TO if_ixml_node,
          xmlns       TYPE ihttpnvp,
          xmlns_table TYPE TABLE OF ihttpnvp.
    FIELD-SYMBOLS:
      <xmlns> TYPE ihttpnvp.

    iterator = element->create_iterator( ).
    result ?= element->clone( ).
    node = iterator->get_next( ).
    WHILE node IS BOUND.
      xmlns-name = node->get_namespace_prefix( ).
      xmlns-value = node->get_namespace_uri( ).
      COLLECT xmlns INTO xmlns_table.
      node = iterator->get_next( ).
    ENDWHILE.

    LOOP AT xmlns_table ASSIGNING <xmlns>.
      result->set_attribute_ns( prefix = 'xmlns' name = <xmlns>-name value = <xmlns>-value ).
    ENDLOOP.

  ENDMETHOD.
  METHOD convert_column2alpha.

    DATA: lv_uccpi  TYPE i,
          lv_text   TYPE c LENGTH 2,
          lv_module TYPE int4,
          lv_column TYPE zexcel_cell_column.

* Propagate Lcx_excel if error occurs           " issue #155 - less restrictive typing for ip_column
    lv_column = convert_column2int( ip_column ).  " issue #155 - less restrictive typing for ip_column

*--------------------------------------------------------------------*
* Check whether column is in allowed range for EXCEL to handle ( 1-16384 )
*--------------------------------------------------------------------*
    IF   lv_column > 16384
      OR lv_column < 1.
      Lcx_excel=>raise_text( 'Index out of bounds' ).
    ENDIF.

*--------------------------------------------------------------------*
* Look up for previous succesfull cached result
*--------------------------------------------------------------------*
    IF lv_column = sv_prev_in1 AND sv_prev_out1 IS NOT INITIAL.
      ep_column = sv_prev_out1.
      RETURN.
    ELSE.
      CLEAR sv_prev_out1.
      sv_prev_in1 = lv_column.
    ENDIF.

*--------------------------------------------------------------------*
* Build alpha representation of column
*--------------------------------------------------------------------*
    WHILE lv_column GT 0.

      lv_module = ( lv_column - 1 ) MOD 26.
      lv_uccpi  = 65 + lv_module.

      lv_column = ( lv_column - lv_module ) / 26.

      lv_text   = cl_abap_conv_in_ce=>uccpi( lv_uccpi ).
      CONCATENATE lv_text ep_column INTO ep_column.

    ENDWHILE.

*--------------------------------------------------------------------*
* Save succesfull output into cache
*--------------------------------------------------------------------*
    sv_prev_out1 = ep_column.

  ENDMETHOD.
  METHOD convert_column2int.

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-12-29
*              - ...
* changes: renaming variables to naming conventions
*          removing unused variables
*          removing commented out code that is inactive for more then half a year
*          message made to support multilinguality
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*
* issue#246 - error converting lower case column names
*              - Stefan Schmoecker,                          2012-12-29
* changes: translating the correct variable to upper dase
*          adding missing exception if input is a number
*          that is out of bounds
*          adding missing exception if input contains
*          illegal characters like german umlauts
*--------------------------------------------------------------------*

    DATA: lv_column       TYPE zexcel_cell_column_alpha,
          lv_column_c     TYPE c LENGTH 10,
          lv_column_s     TYPE string,
          lv_errormessage TYPE string,                          " Can't pass '...'(abc) to exception-class
          lv_modulo       TYPE i.

*--------------------------------------------------------------------*
* This module tries to identify which column a user wants to access
* Numbers as input are just passed back, anything else will be converted
* using EXCEL nomenclatura A = 1, AA = 27, ..., XFD = 16384
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* Normalize input ( upper case , no gaps )
*--------------------------------------------------------------------*
    lv_column_c = ip_column.
    TRANSLATE lv_column_c TO UPPER CASE.                      " Fix #246
    CONDENSE lv_column_c NO-GAPS.
    IF lv_column_c EQ ''.
      MESSAGE e800(zabap2xlsx) INTO lv_errormessage.
      Lcx_excel=>raise_symsg( ).
    ENDIF.

*--------------------------------------------------------------------*
* Look up for previous succesfull cached result
*--------------------------------------------------------------------*
    IF lv_column_c = sv_prev_in2 AND sv_prev_out2 IS NOT INITIAL.
      ep_column = sv_prev_out2.
      RETURN.
    ELSE.
      CLEAR sv_prev_out2.
      sv_prev_in2 = lv_column_c.
    ENDIF.

*--------------------------------------------------------------------*
* If a number gets passed, just convert it to an integer and return
* the converted value
*--------------------------------------------------------------------*
    TRY.
        IF lv_column_c CO '1234567890 '.                      " Fix #164
          ep_column = lv_column_c.                            " Fix #164
*--------------------------------------------------------------------*
* Maximum column for EXCEL:  XFD = 16384    " if anyone has a reference for this information - please add here instead of this comment
*--------------------------------------------------------------------*
          IF ep_column > 16384 OR ep_column < 1.
            lv_errormessage = 'Index out of bounds'(004).
            Lcx_excel=>raise_text( lv_errormessage ).
          ENDIF.
          RETURN.
        ENDIF.
      CATCH cx_sy_conversion_no_number.                 "#EC NO_HANDLER
        " Try the character-approach if approach via number has failed
    ENDTRY.

*--------------------------------------------------------------------*
* Raise error if unexpected characters turns up
*--------------------------------------------------------------------*
    lv_column_s = lv_column_c.
    IF lv_column_s CN sy-abcde.
      MESSAGE e800(zabap2xlsx) INTO lv_errormessage.
      Lcx_excel=>raise_symsg( ).
    ENDIF.

    DO 1 TIMES. "Because of using CHECK
*--------------------------------------------------------------------*
* Interpret input as number to base 26 with A=1, ... Z=26
* Raise error if unexpected character turns up
*--------------------------------------------------------------------*
* 1st character
*--------------------------------------------------------------------*
      lv_column = lv_column_c.
      FIND lv_column+0(1) IN sy-abcde MATCH OFFSET lv_modulo.
      lv_modulo = lv_modulo + 1.
      IF lv_modulo < 1 OR lv_modulo > 26.
        MESSAGE e800(zabap2xlsx) INTO lv_errormessage.
        Lcx_excel=>raise_symsg( ).
      ENDIF.
      ep_column = lv_modulo.                    " Leftmost digit

*--------------------------------------------------------------------*
* 2nd character if present
*--------------------------------------------------------------------*
      CHECK lv_column+1(1) IS NOT INITIAL.      " No need to continue if string ended
      FIND lv_column+1(1) IN sy-abcde MATCH OFFSET lv_modulo.
      lv_modulo = lv_modulo + 1.
      IF lv_modulo < 1 OR lv_modulo > 26.
        MESSAGE e800(zabap2xlsx) INTO lv_errormessage.
        Lcx_excel=>raise_symsg( ).
      ENDIF.
      ep_column = 26 * ep_column + lv_modulo.   " if second digit is present first digit is for 26^1

*--------------------------------------------------------------------*
* 3rd character if present
*--------------------------------------------------------------------*
      CHECK lv_column+2(1) IS NOT INITIAL.      " No need to continue if string ended
      FIND lv_column+2(1) IN sy-abcde MATCH OFFSET lv_modulo.
      lv_modulo = lv_modulo + 1.
      IF lv_modulo < 1 OR lv_modulo > 26.
        MESSAGE e800(zabap2xlsx) INTO lv_errormessage.
        Lcx_excel=>raise_symsg( ).
      ENDIF.
      ep_column = 26 * ep_column + lv_modulo.   " if third digit is present first digit is for 26^2 and second digit for 26^1
    ENDDO.

*--------------------------------------------------------------------*
* Maximum column for EXCEL:  XFD = 16384    " if anyone has a reference for this information - please add here instead of this comment
*--------------------------------------------------------------------*
    IF ep_column > 16384 OR ep_column < 1.
      lv_errormessage = 'Index out of bounds'(004).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

*--------------------------------------------------------------------*
* Save succesfull output into cache
*--------------------------------------------------------------------*
    sv_prev_out2 = ep_column.

  ENDMETHOD.
  METHOD convert_columnrow2column_a_row.
*--------------------------------------------------------------------*
    "issue #256 - replacing char processing with regex
*--------------------------------------------------------------------*
* Stefan Schmoecker, 2013-08-11
*    Allow input to be CLIKE instead of STRING
*--------------------------------------------------------------------*

    DATA: pane_cell_row_a TYPE string,
          lv_columnrow    TYPE string.

    lv_columnrow = i_columnrow.    " Get rid of trailing blanks

    FIND REGEX '^(\D+)(\d+)$' IN lv_columnrow SUBMATCHES e_column
                                                         pane_cell_row_a.
    IF e_column_int IS SUPPLIED.
      e_column_int = convert_column2int( ip_column = e_column ).
    ENDIF.
    e_row = pane_cell_row_a.

  ENDMETHOD.
  METHOD convert_columnrow2column_o_row.

    DATA: row       TYPE string.
    DATA: columnrow TYPE string.

    CLEAR e_column.

    columnrow = i_columnrow.

    FIND REGEX '^(\D*)(\d*)$' IN columnrow SUBMATCHES e_column
                                                      row.

    e_row = row.

  ENDMETHOD.
  METHOD convert_column_a_row2columnrow.
    DATA: lv_row_alpha    TYPE string,
          lv_column_alpha TYPE zexcel_cell_column_alpha.

    lv_row_alpha = i_row.
    lv_column_alpha = Lcl_excel_common=>convert_column2alpha( i_column ).
    SHIFT lv_row_alpha RIGHT DELETING TRAILING space.
    SHIFT lv_row_alpha LEFT DELETING LEADING space.
    CONCATENATE lv_column_alpha lv_row_alpha INTO e_columnrow.

  ENDMETHOD.
  METHOD convert_range2column_a_row.
*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-12-07
*              - ...
* changes: renaming variables to naming conventions
*          aligning code
*          added exceptionclass
*          added errorhandling for invalid range
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*
* issue#241 - error when sheetname contains "!"
*           - sheetname should be returned unescaped
*              - Stefan Schmoecker,                          2012-12-07
* changes: changed coding to support sheetnames with "!"
*          unescaping sheetname
*--------------------------------------------------------------------*
* issue#155 - lessening restrictions of input parameters
*              - Stefan Schmoecker,                          2012-12-07
* changes: i_range changed to clike
*          e_sheet changed to clike
*--------------------------------------------------------------------*

    DATA: lv_sheet           TYPE string,
          lv_range           TYPE string,
          lv_columnrow_start TYPE string,
          lv_columnrow_end   TYPE string,
          lv_position        TYPE i,
          lv_errormessage    TYPE string.                          " Can't pass '...'(abc) to exception-class


*--------------------------------------------------------------------*
* Split input range into sheetname and Area
* 4 cases - a) input empty --> nothing to do
*         - b) sheetname existing - starts with '            example 'Sheet 1'!$B$6:$D$13
*         - c) sheetname existing - does not start with '    example Sheet1!$B$6:$D$13
*         - d) no sheetname - just area                      example $B$6:$D$13
*--------------------------------------------------------------------*
* Initialize output parameters
    CLEAR: e_column_start,
           e_column_end,
           e_row_start,
           e_row_end,
           e_sheet.

    IF i_range IS INITIAL.                                " a) input empty --> nothing to do
      RETURN.

    ELSEIF i_range(1) = `'`.                              " b) sheetname existing - starts with '
      FIND REGEX '\![^\!]*$' IN i_range MATCH OFFSET lv_position.  " Find last !
      IF sy-subrc = 0.
        lv_sheet = i_range(lv_position).
        ADD 1 TO lv_position.
        lv_range = i_range.
        SHIFT lv_range LEFT BY lv_position PLACES.
      ELSE.
        lv_errormessage = 'Invalid range'(001).
        Lcx_excel=>raise_text( lv_errormessage ).
      ENDIF.

    ELSEIF i_range CS '!'.                                " c) sheetname existing - does not start with '
      SPLIT i_range AT '!' INTO lv_sheet lv_range.
      " begin Dennis Schaaf
      IF lv_range CP '*#REF*'.
        lv_errormessage = 'Invalid range'(001).
        Lcx_excel=>raise_text( lv_errormessage ).
      ENDIF.
      " end Dennis Schaaf
    ELSE.                                                 " d) no sheetname - just area
      lv_range = i_range.
    ENDIF.

    REPLACE ALL OCCURRENCES OF '$' IN lv_range WITH ''.
    SPLIT lv_range AT ':' INTO lv_columnrow_start lv_columnrow_end.

    IF i_allow_1dim_range = abap_true.
      convert_columnrow2column_o_row( EXPORTING i_columnrow = lv_columnrow_start
                                      IMPORTING e_column    = e_column_start
                                                e_row       = e_row_start ).
      convert_columnrow2column_o_row( EXPORTING i_columnrow = lv_columnrow_end
                                      IMPORTING e_column    = e_column_end
                                                e_row       = e_row_end ).
    ELSE.
      convert_columnrow2column_a_row( EXPORTING i_columnrow = lv_columnrow_start
                                      IMPORTING e_column    = e_column_start
                                                e_row       = e_row_start ).
      convert_columnrow2column_a_row( EXPORTING i_columnrow = lv_columnrow_end
                                      IMPORTING e_column    = e_column_end
                                                e_row       = e_row_end ).
    ENDIF.

    IF e_column_start_int IS SUPPLIED AND e_column_start IS NOT INITIAL.
      e_column_start_int = convert_column2int( e_column_start ).
    ENDIF.
    IF e_column_end_int IS SUPPLIED AND e_column_end IS NOT INITIAL.
      e_column_end_int = convert_column2int( e_column_end ).
    ENDIF.

    e_sheet = unescape_string( lv_sheet ).                  " Return in unescaped form
  ENDMETHOD.
  METHOD date_to_excel_string.
    DATA: lv_date_diff         TYPE i.

    CHECK ip_value IS NOT INITIAL
      AND ip_value <> space.
    " Needed hack caused by the problem that:
    " Excel 2000 incorrectly assumes that the year 1900 is a leap year
    " http://support.microsoft.com/kb/214326/en-us
    IF ip_value > c_excel_1900_leap_year.
      lv_date_diff = ip_value - c_excel_baseline_date + 2.
    ELSE.
      lv_date_diff = ip_value - c_excel_baseline_date + 1.
    ENDIF.
    ep_value = Lcl_excel_common=>number_to_excel_string( ip_value = lv_date_diff ).
  ENDMETHOD.
  METHOD describe_structure.
    DATA: lt_components TYPE abap_component_tab,
          lt_comps      TYPE abap_component_tab,
          ls_component  TYPE abap_componentdescr,
          lo_elemdescr  TYPE REF TO cl_abap_elemdescr,
          ls_dfies      TYPE dfies,
          l_position    LIKE ls_dfies-position.

    "for DDIC structure get the info directly
    IF io_struct->is_ddic_type( ) = abap_true.
      rt_dfies = io_struct->get_ddic_field_list( ).
    ELSE.
      lt_components = io_struct->get_components( ).

      LOOP AT lt_components INTO ls_component.
        structure_case( EXPORTING is_component  = ls_component
                        CHANGING  xt_components = lt_comps   ) .
      ENDLOOP.
      LOOP AT lt_comps INTO ls_component.
        CLEAR ls_dfies.
        IF ls_component-type->kind = cl_abap_typedescr=>kind_elem. "E Elementary Type
          ADD 1 TO l_position.
          lo_elemdescr ?= ls_component-type.
          IF lo_elemdescr->is_ddic_type( ) = abap_true.
            ls_dfies           = lo_elemdescr->get_ddic_field( ).
            ls_dfies-fieldname = ls_component-name.
            ls_dfies-position  = l_position.
          ELSE.
            ls_dfies-fieldname = ls_component-name.
            ls_dfies-position  = l_position.
            ls_dfies-inttype   = lo_elemdescr->type_kind.
            ls_dfies-leng      = lo_elemdescr->length.
            ls_dfies-outputlen = lo_elemdescr->length.
            ls_dfies-decimals  = lo_elemdescr->decimals.
            ls_dfies-fieldtext = ls_component-name.
            ls_dfies-reptext   = ls_component-name.
            ls_dfies-scrtext_s = ls_component-name.
            ls_dfies-scrtext_m = ls_component-name.
            ls_dfies-scrtext_l = ls_component-name.
            ls_dfies-dynpfld   = abap_true.
          ENDIF.
          INSERT ls_dfies INTO TABLE rt_dfies.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD determine_resulting_formula.

    DATA: lv_row_difference TYPE i,
          lv_col_difference TYPE i.

*--------------------------------------------------------------------*
* Calculate distance of reference and current cell
*--------------------------------------------------------------------*
    calculate_cell_distance( EXPORTING
                               iv_reference_cell = iv_reference_cell
                               iv_current_cell   = iv_current_cell
                             IMPORTING
                               ev_row_difference = lv_row_difference
                               ev_col_difference = lv_col_difference ).

*--------------------------------------------------------------------*
* and shift formula by using the row- and columndistance
*--------------------------------------------------------------------*
    ev_resulting_formula = shift_formula( iv_reference_formula = iv_reference_formula
                                          iv_shift_rows        = lv_row_difference
                                          iv_shift_cols        = lv_col_difference ).

  ENDMETHOD.                    "determine_resulting_formula
  METHOD encrypt_password.

    DATA lv_curr_offset            TYPE i.
    DATA lv_curr_char              TYPE c LENGTH 1.
    DATA lv_curr_hex               TYPE zexcel_pwd_hash.
    DATA lv_pwd_len                TYPE zexcel_pwd_hash.
    DATA lv_pwd_hash               TYPE zexcel_pwd_hash.

    CONSTANTS:
      lv_0x7fff TYPE zexcel_pwd_hash VALUE '7FFF',
      lv_0x0001 TYPE zexcel_pwd_hash VALUE '0001',
      lv_0xce4b TYPE zexcel_pwd_hash VALUE 'CE4B'.

    DATA lv_pwd            TYPE zexcel_aes_password.

    lv_pwd = i_pwd.

    lv_pwd_len = strlen( lv_pwd ).
    lv_curr_offset = lv_pwd_len - 1.

    WHILE lv_curr_offset GE 0.

      lv_curr_char = lv_pwd+lv_curr_offset(1).
      lv_curr_hex = char2hex( lv_curr_char ).

      lv_pwd_hash = (  shr14( lv_pwd_hash ) BIT-AND lv_0x0001 ) BIT-OR ( shl01( lv_pwd_hash ) BIT-AND lv_0x7fff ).

      lv_pwd_hash = lv_pwd_hash BIT-XOR lv_curr_hex.
      SUBTRACT 1 FROM lv_curr_offset.
    ENDWHILE.

    lv_pwd_hash = (  shr14( lv_pwd_hash ) BIT-AND lv_0x0001 ) BIT-OR ( shl01( lv_pwd_hash ) BIT-AND lv_0x7fff ).
    lv_pwd_hash = lv_pwd_hash BIT-XOR lv_0xce4b.
    lv_pwd_hash = lv_pwd_hash BIT-XOR lv_pwd_len.

    WRITE lv_pwd_hash TO r_encrypted_pwd.

  ENDMETHOD.
  METHOD escape_string.
*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (done)              2012-12-08
*              - ...
* changes: aligning code
*          adding comments to explain what we are trying to achieve
*--------------------------------------------------------------------*
* issue#242 - Support escaping for white-spaces
*           - Escaping also necessary when ' encountered in input
*              - Stefan Schmoecker,                          2012-12-08
* changes: switched check if escaping is necessary to regular expression
*          and moved the "REPLACE"
*--------------------------------------------------------------------*
* issue#155 - lessening restrictions of input parameters
*              - Stefan Schmoecker,                          2012-12-08
* changes: ip_value changed to clike
*--------------------------------------------------------------------*
    DATA:       lv_value                        TYPE string.

*--------------------------------------------------------------------*
* There exist various situations when a space will be used to separate
* different parts of a string. When we have a string consisting spaces
* that will cause errors unless we "escape" the string by putting ' at
* the beginning and at the end of the string.
*--------------------------------------------------------------------*


*--------------------------------------------------------------------*
* When allowing clike-input parameters we might encounter trailing
* "real" blanks .  These are automatically eliminated when moving
* the input parameter to a string.
* Now any remaining spaces ( white-spaces or normal spaces ) should
* trigger the escaping as well as any '
*--------------------------------------------------------------------*
    lv_value = ip_value.


    FIND REGEX `\s|'|-` IN lv_value.  " \s finds regular and white spaces
    IF sy-subrc = 0.
      REPLACE ALL OCCURRENCES OF `'` IN lv_value WITH `''`.
      CONCATENATE `'` lv_value `'` INTO lv_value .
    ENDIF.

    ep_escaped_value = lv_value.

  ENDMETHOD.
  METHOD excel_string_to_date.
    DATA: lv_date_int TYPE i.

    CHECK ip_value IS NOT INITIAL AND ip_value CN ' 0'.

    TRY.
        lv_date_int = ip_value.
        IF lv_date_int NOT BETWEEN 1 AND 2958465.
          Lcx_excel=>raise_text( 'Unable to interpret date' ).
        ENDIF.
        ep_value = lv_date_int + c_excel_baseline_date - 2.
        " Needed hack caused by the problem that:
        " Excel 2000 incorrectly assumes that the year 1900 is a leap year
        " http://support.microsoft.com/kb/214326/en-us
        IF ep_value < c_excel_1900_leap_year.
          ep_value = ep_value + 1.
        ENDIF.
      CATCH cx_sy_conversion_error.
        Lcx_excel=>raise_text( 'Index out of bounds' ).
    ENDTRY.
  ENDMETHOD.
  METHOD excel_string_to_number.

* If we encounter anything more complicated in EXCEL we might have to extend this
* But currently this works fine - even for numbers in scientific notation

    ep_value = ip_value.

  ENDMETHOD.
  METHOD excel_string_to_time.
    DATA: lv_seconds_in_day TYPE i,
          lv_day_fraction   TYPE f,
          lc_seconds_in_day TYPE i VALUE 86400.

    TRY.

        lv_day_fraction = ip_value.
        lv_seconds_in_day = lv_day_fraction * lc_seconds_in_day.

        ep_value = lv_seconds_in_day.

      CATCH cx_sy_conversion_error.
        Lcx_excel=>raise_text( 'Unable to interpret time' ).
    ENDTRY.
  ENDMETHOD.
  METHOD get_fieldcatalog.
    DATA: lr_dref_tab           TYPE REF TO data,
          lo_salv_table         TYPE REF TO cl_salv_table,
          lo_salv_columns_table TYPE REF TO cl_salv_columns_table,
          lt_salv_t_column_ref  TYPE salv_t_column_ref,
          ls_salv_t_column_ref  LIKE LINE OF lt_salv_t_column_ref,
          lo_salv_column_table  TYPE REF TO cl_salv_column_table.

    FIELD-SYMBOLS: <tab>          TYPE STANDARD TABLE.
    FIELD-SYMBOLS: <fcat>         LIKE LINE OF ep_fieldcatalog.

* Get copy of IP_TABLE-structure <-- must be changeable to create salv
    CREATE DATA lr_dref_tab LIKE ip_table.
    ASSIGN lr_dref_tab->* TO <tab>.
* Create salv --> implicitly create fieldcat
    TRY.
        cl_salv_table=>factory( IMPORTING
                                  r_salv_table   = lo_salv_table
                                CHANGING
                                  t_table        = <tab>  ).
        lo_salv_columns_table = lo_salv_table->get_columns( ).
        lt_salv_t_column_ref  = lo_salv_columns_table->get( ).
      CATCH cx_root.
* maybe some errorhandling here - just haven't made up my mind yet
    ENDTRY.

* Loop through columns and set relevant fields ( fieldname, texts )
    LOOP AT lt_salv_t_column_ref INTO ls_salv_t_column_ref.

      lo_salv_column_table ?= ls_salv_t_column_ref-r_column.
      APPEND INITIAL LINE TO ep_fieldcatalog ASSIGNING <fcat>.
      <fcat>-position  = sy-tabix.
      <fcat>-fieldname = ls_salv_t_column_ref-columnname.
      <fcat>-scrtext_s = ls_salv_t_column_ref-r_column->get_short_text( ).
      <fcat>-scrtext_m = ls_salv_t_column_ref-r_column->get_medium_text( ).
      <fcat>-scrtext_l = ls_salv_t_column_ref-r_column->get_long_text( ).
      <fcat>-currency_column = ls_salv_t_column_ref-r_column->get_currency_column( ).
      " If currency column not in structure then clear the field again
      IF <fcat>-currency_column IS NOT INITIAL.
        READ TABLE lt_salv_t_column_ref WITH KEY columnname = <fcat>-currency_column TRANSPORTING NO FIELDS.
        IF sy-subrc <> 0.
          CLEAR <fcat>-currency_column.
        ENDIF.
      ENDIF.

      IF ip_conv_exit_length = abap_false.
        <fcat>-abap_type = lo_salv_column_table->get_ddic_inttype( ).
      ENDIF.

      <fcat>-dynpfld   = 'X'.  " What in the world would we exclude here?
      " except for the MANDT-field of most tables ( 1st column that is )
      IF <fcat>-position = 1 AND lo_salv_column_table->get_ddic_datatype( ) = 'CLNT' AND iv_hide_mandt = abap_true.
        CLEAR <fcat>-dynpfld.
      ENDIF.

* For fields that don't a description (  i.e. defined by  "field type i," )
* just use the fieldname as description - that is better than nothing
      IF    <fcat>-scrtext_s IS INITIAL
        AND <fcat>-scrtext_m IS INITIAL
        AND <fcat>-scrtext_l IS INITIAL.
        CONCATENATE 'Col:' <fcat>-fieldname INTO <fcat>-scrtext_l  SEPARATED BY space.
        <fcat>-scrtext_m = <fcat>-scrtext_l.
        <fcat>-scrtext_s = <fcat>-scrtext_l.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD is_cell_in_range.
    DATA lv_column_start    TYPE zexcel_cell_column_alpha.
    DATA lv_column_end      TYPE zexcel_cell_column_alpha.
    DATA lv_row_start       TYPE zexcel_cell_row.
    DATA lv_row_end         TYPE zexcel_cell_row.
    DATA lv_column_start_i  TYPE zexcel_cell_column.
    DATA lv_column_end_i    TYPE zexcel_cell_column.
    DATA lv_column_i        TYPE zexcel_cell_column.


* Split range and convert columns
    convert_range2column_a_row(
      EXPORTING
        i_range        = ip_range
      IMPORTING
        e_column_start = lv_column_start
        e_column_end   = lv_column_end
        e_row_start    = lv_row_start
        e_row_end      = lv_row_end ).

    lv_column_start_i = convert_column2int( ip_column = lv_column_start ).
    lv_column_end_i   = convert_column2int( ip_column = lv_column_end ).

    lv_column_i = convert_column2int( ip_column = ip_column ).

* Check if cell is in range
    IF lv_column_i >= lv_column_start_i AND
       lv_column_i <= lv_column_end_i   AND
       ip_row      >= lv_row_start      AND
       ip_row      <= lv_row_end.
      rp_in_range = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD number_to_excel_string.
    DATA: lv_value_c TYPE c LENGTH 100.

    IF ip_currency IS INITIAL.
      WRITE ip_value TO lv_value_c EXPONENT 0 NO-GROUPING NO-SIGN.
    ELSE.
      WRITE ip_value TO lv_value_c EXPONENT 0 NO-GROUPING NO-SIGN CURRENCY ip_currency.
    ENDIF.
    REPLACE ALL OCCURRENCES OF ',' IN lv_value_c WITH '.'.

    ep_value = lv_value_c.
    CONDENSE ep_value.

    IF ip_value < 0.
      CONCATENATE '-' ep_value INTO ep_value.
    ELSEIF ip_value EQ 0.
      ep_value = '0'.
    ENDIF.
  ENDMETHOD.
  METHOD recursive_class_to_struct.
    " # issue 139
* is working for me - but after looking through this coding I guess
* I'll rewrite this to a version w/o recursion
* This is private an no one using it so far except me, so no need to hurry
    DATA: descr          TYPE REF TO cl_abap_structdescr,
          wa_component   LIKE LINE OF descr->components,
          attribute_name LIKE wa_component-name,
          flag_class     TYPE abap_bool.

    FIELD-SYMBOLS: <field>     TYPE any,
                   <fieldx>    TYPE any,
                   <attribute> TYPE any.


    descr ?= cl_abap_structdescr=>describe_by_data( e_target ).

    LOOP AT descr->components INTO wa_component.

* Assign structure and X-structure
      ASSIGN COMPONENT wa_component-name OF STRUCTURE e_target  TO <field>.
      ASSIGN COMPONENT wa_component-name OF STRUCTURE e_targetx TO <fieldx>.
* At least one field in the structure should be marked - otherwise continue with next field
      CLEAR flag_class.
* maybe source is just a structure - try assign component...
      ASSIGN COMPONENT wa_component-name OF STRUCTURE i_source  TO <attribute>.
      IF sy-subrc <> 0.
* not - then it is an attribute of the class - use different assign then
        CONCATENATE 'i_source->' wa_component-name INTO attribute_name.
        ASSIGN (attribute_name) TO <attribute>.
        IF sy-subrc <> 0.
          EXIT.
        ENDIF.  " Should not happen if structure is built properly - otherwise just exit to create no dumps
        flag_class = abap_true.
      ENDIF.

      CASE wa_component-type_kind.
        WHEN cl_abap_structdescr=>typekind_struct1 OR cl_abap_structdescr=>typekind_struct2.  " Structure --> use recursio
          Lcl_excel_common=>recursive_class_to_struct( EXPORTING i_source  = <attribute>
                                                       CHANGING  e_target  = <field>
                                                                 e_targetx = <fieldx> ).
        WHEN OTHERS.
          <field> = <attribute>.
          <fieldx> = abap_true.

      ENDCASE.
    ENDLOOP.

  ENDMETHOD.
  METHOD recursive_struct_to_class.
    " # issue 139
* is working for me - but after looking through this coding I guess
* I'll rewrite this to a version w/o recursion
* This is private an no one using it so far except me, so no need to hurry
    DATA: descr          TYPE REF TO cl_abap_structdescr,
          wa_component   LIKE LINE OF descr->components,
          attribute_name LIKE wa_component-name,
          flag_class     TYPE abap_bool,
          o_border       TYPE REF TO Lcl_excel_style_border.

    FIELD-SYMBOLS: <field>     TYPE any,
                   <fieldx>    TYPE any,
                   <attribute> TYPE any.


    descr ?= cl_abap_structdescr=>describe_by_data( i_source ).

    LOOP AT descr->components INTO wa_component.

* Assign structure and X-structure
      ASSIGN COMPONENT wa_component-name OF STRUCTURE i_source  TO <field>.
      ASSIGN COMPONENT wa_component-name OF STRUCTURE i_sourcex TO <fieldx>.
* At least one field in the structure should be marked - otherwise continue with next field
      CHECK <fieldx> CA abap_true.
      CLEAR flag_class.
* maybe target is just a structure - try assign component...
      ASSIGN COMPONENT wa_component-name OF STRUCTURE e_target  TO <attribute>.
      IF sy-subrc <> 0.
* not - then it is an attribute of the class - use different assign then
        CONCATENATE 'E_TARGET->' wa_component-name INTO attribute_name.
        ASSIGN (attribute_name) TO <attribute>.
        IF sy-subrc <> 0.EXIT.ENDIF.  " Should not happen if structure is built properly - otherwise just exit to create no dumps
        flag_class = abap_true.
      ENDIF.

      CASE wa_component-type_kind.
        WHEN cl_abap_structdescr=>typekind_struct1 OR cl_abap_structdescr=>typekind_struct2.  " Structure --> use recursion
          " To avoid dump with attribute GRADTYPE of class LCL_EXCEL_STYLE_FILL
          " quick and really dirty fix -> check the attribute name
          " Border has to be initialized somewhere else
          IF wa_component-name EQ 'GRADTYPE'.
            flag_class = abap_false.
          ENDIF.

          IF flag_class = abap_true AND <attribute> IS INITIAL.
* Only borders will be passed as unbound references.  But since we want to set a value we have to create an instance
            CREATE OBJECT o_border.
            <attribute> = o_border.
          ENDIF.
          Lcl_excel_common=>recursive_struct_to_class( EXPORTING i_source  = <field>
                                                                 i_sourcex = <fieldx>
                                                       CHANGING  e_target  = <attribute> ).
        WHEN OTHERS.
          CHECK <fieldx> = abap_true.  " Marked for change
          <attribute> = <field>.

      ENDCASE.
    ENDLOOP.

  ENDMETHOD.
  METHOD shift_formula.

    CONSTANTS: lcv_operators            TYPE string VALUE '+-/*^%=<>&, !',
               lcv_letters              TYPE string VALUE 'ABCDEFGHIJKLMNOPQRSTUVWXYZ$',
               lcv_digits               TYPE string VALUE '0123456789',
               lcv_cell_reference_error TYPE string VALUE '#REF!'.

    DATA: lv_tcnt          TYPE i,         " Counter variable
          lv_tlen          TYPE i,         " Temp variable length
          lv_cnt           TYPE i,         " Counter variable
          lv_cnt2          TYPE i,         " Counter variable
          lv_offset1       TYPE i,         " Character offset
          lv_numchars      TYPE i,         " Number of characters counter
          lv_tchar(1)      TYPE c,         " Temp character
          lv_tchar2(1)     TYPE c,         " Temp character
          lv_cur_form      TYPE string,    " Formula for current cell
          lv_ref_cell_addr TYPE string,    " Reference cell address
          lv_tcol1         TYPE string,    " Temp column letter
          lv_tcol2         TYPE string,    " Temp column letter
          lv_tcoln         TYPE i,         " Temp column number
          lv_trow1         TYPE string,    " Temp row number
          lv_trow2         TYPE string,    " Temp row number
          lv_flen          TYPE i,         " Length of reference formula
          lv_tlen2         TYPE i,         " Temp variable length
          lv_substr1       TYPE string,    " Substring variable
          lv_abscol        TYPE string,    " Absolute column symbol
          lv_absrow        TYPE string,    " Absolute row symbol
          lv_ref_formula   TYPE string,
          lv_compare_1     TYPE string,
          lv_compare_2     TYPE string,
          lv_level         TYPE i,         " Level of groups [..[..]..] or {..}

          lv_errormessage  TYPE string.

*--------------------------------------------------------------------*
* When copying a cell in EXCEL to another cell any inherent formulas
* are copied as well.  Cell-references in the formula are being adjusted
* by the distance of the new cell to the original one
*--------------------------------------------------------------------*
* §1 Parse reference formula character by character
* §2 Identify Cell-references
* §3 Shift cell-reference
* §4 Build resulting formula
*--------------------------------------------------------------------*

    lv_ref_formula = iv_reference_formula.
*--------------------------------------------------------------------*
* No distance --> Reference = resulting cell/formula
*--------------------------------------------------------------------*
    IF    iv_shift_cols = 0
      AND iv_shift_rows = 0.
      ev_resulting_formula = lv_ref_formula.
      RETURN. " done
    ENDIF.


    lv_flen     = strlen( lv_ref_formula ).
    lv_numchars = 1.

*--------------------------------------------------------------------*
* §1 Parse reference formula character by character
*--------------------------------------------------------------------*
    DO lv_flen TIMES.

      CLEAR: lv_tchar,
             lv_substr1,
             lv_ref_cell_addr.
      lv_cnt2 = lv_cnt + 1.
      IF lv_cnt2 > lv_flen.
        EXIT. " Done
      ENDIF.

*--------------------------------------------------------------------*
* Here we have the current character in the formula
*--------------------------------------------------------------------*
      lv_tchar = lv_ref_formula+lv_cnt(1).

*--------------------------------------------------------------------*
* Operators or opening parenthesis will separate possible cellreferences
*--------------------------------------------------------------------*
      IF    (    lv_tchar CA lcv_operators
              OR lv_tchar CA '(' )
        AND lv_cnt2 = 1.
        lv_substr1  = lv_ref_formula+lv_offset1(1).
        CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
        lv_cnt      = lv_cnt + 1.
        lv_offset1  = lv_cnt.
        lv_numchars = 1.
        CONTINUE.       " --> next character in formula can be analyzed
      ENDIF.

*--------------------------------------------------------------------*
* Quoted literal text holds no cell reference --> advance to end of text
*--------------------------------------------------------------------*
      IF lv_tchar EQ '"'.
        lv_cnt      = lv_cnt + 1.
        lv_numchars = lv_numchars + 1.
        lv_tchar     = lv_ref_formula+lv_cnt(1).
        WHILE lv_tchar NE '"'.

          lv_cnt      = lv_cnt + 1.
          lv_numchars = lv_numchars + 1.
          lv_tchar    = lv_ref_formula+lv_cnt(1).

        ENDWHILE.
        lv_cnt2    = lv_cnt + 1.
        lv_substr1 = lv_ref_formula+lv_offset1(lv_numchars).
        CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
        lv_cnt     = lv_cnt + 1.
        IF lv_cnt = lv_flen.
          EXIT.
        ENDIF.
        lv_offset1  = lv_cnt.
        lv_numchars = 1.
        lv_tchar    = lv_ref_formula+lv_cnt(1).
        lv_cnt2     = lv_cnt + 1.
        CONTINUE.       " --> next character in formula can be analyzed
      ENDIF.


*--------------------------------------------------------------------*
* Groups - Ignore values inside blocks [..[..]..] and {..}
*     R1C1-Style Cell Reference: R[1]C[1]
*     Cell References: 'C:\[Source.xlsx]Sheet1'!$A$1
*     Array constants: {1,3.5,TRUE,"Hello"}
*     "Intra table reference": Flights[[#This Row],[Air fare]]
*--------------------------------------------------------------------*
      IF lv_tchar CA '[]{}' OR lv_level > 0.
        IF lv_tchar CA '[{'.
          lv_level = lv_level + 1.
        ELSEIF lv_tchar CA ']}'.
          lv_level = lv_level - 1.
        ENDIF.
        IF lv_cnt2 = lv_flen.
          lv_substr1 = iv_reference_formula+lv_offset1(lv_numchars).
          CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
          EXIT.
        ENDIF.
        lv_numchars = lv_numchars + 1.
        lv_cnt   = lv_cnt   + 1.
        lv_cnt2  = lv_cnt   + 1.
        CONTINUE.
      ENDIF.

*--------------------------------------------------------------------*
* Operators or parenthesis or last character in formula will separate possible cellreferences
*--------------------------------------------------------------------*
      IF   lv_tchar CA lcv_operators
        OR lv_tchar CA '():'
        OR lv_cnt2  =  lv_flen.
        IF lv_cnt > 0.
          lv_substr1 = lv_ref_formula+lv_offset1(lv_numchars).
*--------------------------------------------------------------------*
* Check for text concatenation and functions
*--------------------------------------------------------------------*
          IF ( lv_tchar CA lcv_operators AND lv_tchar EQ lv_substr1 ) OR lv_tchar EQ '('.
            CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
            lv_cnt = lv_cnt + 1.
            lv_offset1 = lv_cnt.
            lv_cnt2 = lv_cnt + 1.
            lv_numchars = 1.
            CONTINUE.       " --> next character in formula can be analyzed
          ENDIF.

          lv_tlen = lv_cnt2 - lv_offset1.
*--------------------------------------------------------------------*
* Exclude mathematical operators and closing parentheses
*--------------------------------------------------------------------*
          IF   lv_tchar CA lcv_operators
            OR lv_tchar CA ':)'.
            IF    lv_cnt2     = lv_flen
              AND lv_numchars = 1.
              CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
              lv_cnt      = lv_cnt + 1.
              lv_offset1  = lv_cnt.
              lv_cnt2     = lv_cnt + 1.
              lv_numchars = 1.
              CONTINUE.       " --> next character in formula can be analyzed
            ELSE.
              lv_tlen = lv_tlen - 1.
            ENDIF.
          ENDIF.
*--------------------------------------------------------------------*
* Capture reference cell address
*--------------------------------------------------------------------*
          TRY.
              lv_ref_cell_addr = lv_ref_formula+lv_offset1(lv_tlen). "Ref cell address
            CATCH cx_root.
              lv_errormessage = 'Internal error in Class LCL_EXCEL_COMMON Method SHIFT_FORMULA Spot 1 '.  " Change to messageclass if possible
              Lcx_excel=>raise_text( lv_errormessage ).
          ENDTRY.

*--------------------------------------------------------------------*
* Split cell address into characters and numbers
*--------------------------------------------------------------------*
          CLEAR: lv_tlen,
                 lv_tcnt,
                 lv_tcol1,
                 lv_trow1.
          lv_tlen = strlen( lv_ref_cell_addr ).
          IF lv_tlen <> 0.
            CLEAR: lv_tcnt.
            DO lv_tlen TIMES.
              CLEAR: lv_tchar2.
              lv_tchar2 = lv_ref_cell_addr+lv_tcnt(1).
              IF lv_tchar2 CA lcv_letters.
                CONCATENATE lv_tcol1 lv_tchar2 INTO lv_tcol1.
              ELSEIF lv_tchar2 CA lcv_digits.
                CONCATENATE lv_trow1 lv_tchar2 INTO lv_trow1.
              ENDIF.
              lv_tcnt = lv_tcnt + 1.
            ENDDO.
          ENDIF.

          " Is valid column & row ?
          IF lv_tcol1 IS NOT INITIAL AND lv_trow1 IS NOT INITIAL.
            " COLUMN + ROW
            CONCATENATE lv_tcol1 lv_trow1 INTO lv_compare_1.
            " Original condensed string
            lv_compare_2 = lv_ref_cell_addr.
            CONDENSE lv_compare_2.
            IF lv_compare_1 <> lv_compare_2.
              CLEAR: lv_trow1, lv_tchar2.
            ENDIF.
          ENDIF.

*--------------------------------------------------------------------*
* Check for invalid cell address
*--------------------------------------------------------------------*
          IF lv_tcol1 IS INITIAL OR lv_trow1 IS INITIAL.
            CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
            lv_cnt = lv_cnt + 1.
            lv_offset1 = lv_cnt.
            lv_cnt2 = lv_cnt + 1.
            lv_numchars = 1.
            CONTINUE.
          ENDIF.
*--------------------------------------------------------------------*
* Check for range names
*--------------------------------------------------------------------*
          CLEAR: lv_tlen.
          lv_tlen = strlen( lv_tcol1 ).
          IF lv_tlen GT 3.
            CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
            lv_cnt = lv_cnt + 1.
            lv_offset1 = lv_cnt.
            lv_cnt2 = lv_cnt + 1.
            lv_numchars = 1.
            CONTINUE.
          ENDIF.
*--------------------------------------------------------------------*
* Check for valid row
*--------------------------------------------------------------------*
          IF lv_trow1 GT 1048576.
            CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
            lv_cnt = lv_cnt + 1.
            lv_offset1 = lv_cnt.
            lv_cnt2 = lv_cnt + 1.
            lv_numchars = 1.
            CONTINUE.
          ENDIF.
*--------------------------------------------------------------------*
* Check for absolute column or row reference
*--------------------------------------------------------------------*
          CLEAR: lv_tcol2,
                 lv_trow2,
                 lv_abscol,
                 lv_absrow.
          lv_tlen2 = strlen( lv_tcol1 ) - 1.
          IF lv_tcol1 IS NOT INITIAL.
            lv_abscol = lv_tcol1(1).
          ENDIF.
          IF lv_tlen2 GE 0.
            lv_absrow = lv_tcol1+lv_tlen2(1).
          ENDIF.
          IF lv_abscol EQ '$' AND lv_absrow EQ '$'.
            lv_tlen2 = lv_tlen2 - 1.
            IF lv_tlen2 > 0.
              lv_tcol1 = lv_tcol1+1(lv_tlen2).
            ENDIF.
            lv_tlen2 = lv_tlen2 + 1.
          ELSEIF lv_abscol EQ '$'.
            lv_tcol1 = lv_tcol1+1(lv_tlen2).
          ELSEIF lv_absrow EQ '$'.
            lv_tcol1 = lv_tcol1(lv_tlen2).
          ENDIF.
*--------------------------------------------------------------------*
* Check for valid column
*--------------------------------------------------------------------*
          TRY.
              lv_tcoln = Lcl_excel_common=>convert_column2int( lv_tcol1 ) + iv_shift_cols.
            CATCH Lcx_excel.
              CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
              lv_cnt = lv_cnt + 1.
              lv_offset1 = lv_cnt.
              lv_cnt2 = lv_cnt + 1.
              lv_numchars = 1.
              CONTINUE.
          ENDTRY.
*--------------------------------------------------------------------*
* Check whether there is a referencing problem
*--------------------------------------------------------------------*
          lv_trow2 = lv_trow1 + iv_shift_rows.
          " Remove the space used for the sign
          CONDENSE lv_trow2.
          IF   ( lv_tcoln < 1 AND lv_abscol <> '$' )   " Maybe we should add here max-column and max row-tests as well.
            OR ( lv_trow2 < 1 AND lv_absrow <> '$' ).  " Check how EXCEL behaves in this case
*--------------------------------------------------------------------*
* Referencing problem encountered --> set error
*--------------------------------------------------------------------*
            CONCATENATE lv_cur_form lcv_cell_reference_error INTO lv_cur_form.
          ELSE.
*--------------------------------------------------------------------*
* No referencing problems --> adjust row and column
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* Adjust column
*--------------------------------------------------------------------*
            IF lv_abscol EQ '$'.
              CONCATENATE lv_cur_form lv_abscol lv_tcol1 INTO lv_cur_form.
            ELSEIF iv_shift_cols EQ 0.
              CONCATENATE lv_cur_form lv_tcol1 INTO lv_cur_form.
            ELSE.
              TRY.
                  lv_tcol2 = Lcl_excel_common=>convert_column2alpha( lv_tcoln ).
                  CONCATENATE lv_cur_form lv_tcol2 INTO lv_cur_form.
                CATCH Lcx_excel.
                  CONCATENATE lv_cur_form lv_substr1 INTO lv_cur_form.
                  lv_cnt = lv_cnt + 1.
                  lv_offset1 = lv_cnt.
                  lv_cnt2 = lv_cnt + 1.
                  lv_numchars = 1.
                  CONTINUE.
              ENDTRY.
            ENDIF.
*--------------------------------------------------------------------*
* Adjust row
*--------------------------------------------------------------------*
            IF lv_absrow EQ '$'.
              CONCATENATE lv_cur_form lv_absrow lv_trow1 INTO lv_cur_form.
            ELSEIF iv_shift_rows = 0.
              CONCATENATE lv_cur_form lv_trow1 INTO lv_cur_form.
            ELSE.
              CONCATENATE lv_cur_form lv_trow2 INTO lv_cur_form.
            ENDIF.
          ENDIF.

          lv_numchars = 0.
          IF   lv_tchar CA lcv_operators
            OR lv_tchar CA ':)'.
            CONCATENATE lv_cur_form lv_tchar INTO lv_cur_form RESPECTING BLANKS.
          ENDIF.
          lv_offset1 = lv_cnt2.
        ENDIF.
      ENDIF.
      lv_numchars = lv_numchars + 1.
      lv_cnt   = lv_cnt   + 1.
      lv_cnt2  = lv_cnt   + 1.

    ENDDO.



*--------------------------------------------------------------------*
* Return resulting formula
*--------------------------------------------------------------------*
    IF lv_cur_form IS NOT INITIAL.
      ev_resulting_formula = lv_cur_form.
    ENDIF.

  ENDMETHOD.
  METHOD shl01.

    DATA:
      lv_bit      TYPE i,
      lv_curr_pos TYPE i VALUE 2,
      lv_prev_pos TYPE i VALUE 1.

    DO 15 TIMES.
      GET BIT lv_curr_pos OF i_pwd_hash INTO lv_bit.
      SET BIT lv_prev_pos OF r_pwd_hash TO lv_bit.
      ADD 1 TO lv_curr_pos.
      ADD 1 TO lv_prev_pos.
    ENDDO.
    SET BIT 16 OF r_pwd_hash TO 0.

  ENDMETHOD.
  METHOD shr14.

    DATA:
      lv_bit      TYPE i,
      lv_curr_pos TYPE i,
      lv_next_pos TYPE i.

    r_pwd_hash = i_pwd_hash.

    DO 14 TIMES.
      lv_curr_pos = 15.
      lv_next_pos = 16.

      DO 15 TIMES.
        GET BIT lv_curr_pos OF r_pwd_hash INTO lv_bit.
        SET BIT lv_next_pos OF r_pwd_hash TO lv_bit.
        SUBTRACT 1 FROM lv_curr_pos.
        SUBTRACT 1 FROM lv_next_pos.
      ENDDO.
      SET BIT 1 OF r_pwd_hash TO 0.
    ENDDO.

  ENDMETHOD.
  METHOD split_file.

    DATA: lt_hlp TYPE TABLE OF text255,
          ls_hlp TYPE text255.

    DATA: lf_ext(10)     TYPE c,
          lf_dot_ext(10) TYPE c.
    DATA: lf_anz TYPE i,
          lf_len TYPE i.
** ---------------------------------------------------------------------

    CLEAR: lt_hlp,
           ep_file,
           ep_extension,
           ep_dotextension.

** Split the whole file at '.'
    SPLIT ip_file AT '.' INTO TABLE lt_hlp.

** get the extenstion from the last line of table
    DESCRIBE TABLE lt_hlp LINES lf_anz.
    IF lf_anz <= 1.
      ep_file = ip_file.
      RETURN.
    ENDIF.

    READ TABLE lt_hlp INTO ls_hlp INDEX lf_anz.
    ep_extension = ls_hlp.
    lf_ext =  ls_hlp.
    IF NOT lf_ext IS INITIAL.
      CONCATENATE '.' lf_ext INTO lf_dot_ext.
    ENDIF.
    ep_dotextension = lf_dot_ext.

** get only the filename
    lf_len = strlen( ip_file ) - strlen( lf_dot_ext ).
    IF lf_len > 0.
      ep_file = ip_file(lf_len).
    ENDIF.

  ENDMETHOD.
  METHOD structure_case.
    DATA: lt_comp_str        TYPE abap_component_tab.

    CASE is_component-type->kind.
      WHEN cl_abap_typedescr=>kind_elem. "E Elementary Type
        INSERT is_component INTO TABLE xt_components.
      WHEN cl_abap_typedescr=>kind_table. "T Table
        INSERT is_component INTO TABLE xt_components.
      WHEN cl_abap_typedescr=>kind_struct. "S Structure
        lt_comp_str = structure_recursive( is_component = is_component ).
        INSERT LINES OF lt_comp_str INTO TABLE xt_components.
      WHEN OTHERS. "cl_abap_typedescr=>kind_ref or  cl_abap_typedescr=>kind_class or  cl_abap_typedescr=>kind_intf.
* We skip it. for now.
    ENDCASE.
  ENDMETHOD.
  METHOD structure_recursive.
    DATA: lo_struct     TYPE REF TO cl_abap_structdescr,
          lt_components TYPE abap_component_tab,
          ls_components TYPE abap_componentdescr.

    lo_struct ?= is_component-type.
    lt_components = lo_struct->get_components( ).

    LOOP AT lt_components INTO ls_components.
      structure_case( EXPORTING is_component  = ls_components
                      CHANGING  xt_components = rt_components ) .
    ENDLOOP.

  ENDMETHOD.
  METHOD time_to_excel_string.
    DATA: lv_seconds_in_day TYPE i,
          lv_day_fraction   TYPE f,
          lc_time_baseline  TYPE t VALUE '000000',
          lc_seconds_in_day TYPE i VALUE 86400.

    lv_seconds_in_day = ip_value - lc_time_baseline.
    lv_day_fraction = lv_seconds_in_day / lc_seconds_in_day.
    ep_value = Lcl_excel_common=>number_to_excel_string( ip_value = lv_day_fraction ).
  ENDMETHOD.
  METHOD unescape_string.

    CONSTANTS   lcv_regex                       TYPE string VALUE `^'[^']`    & `|` &  " Beginning single ' OR
                                                                  `[^']'$`    & `|` &  " Trailing single '  OR
                                                                  `[^']'[^']`.         " Single ' somewhere in between


    DATA:       lv_errormessage                 TYPE string.                          " Can't pass '...'(abc) to exception-class

*--------------------------------------------------------------------*
* This method is used to extract the "real" string from an escaped string.
* An escaped string can be identified by a beginning ' which must be
* accompanied by a trailing '
* All '' in between beginning and trailing ' are treated as single '
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* When allowing clike-input parameters we might encounter trailing
* "real" blanks .  These are automatically eliminated when moving
* the input parameter to a string.
*--------------------------------------------------------------------*
    ev_unescaped_string = iv_escaped.           " Pass through if not escaped

    CHECK ev_unescaped_string IS NOT INITIAL.   " Nothing to do if empty
    CHECK ev_unescaped_string(1) = `'`.         " Nothing to do if not escaped

*--------------------------------------------------------------------*
* Remove leading and trailing '
*--------------------------------------------------------------------*
    REPLACE REGEX `^'(.*)'$` IN ev_unescaped_string WITH '$1'.
    IF sy-subrc <> 0.
      lv_errormessage = 'Input not properly escaped - &'(002).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

*--------------------------------------------------------------------*
* Any remaining single ' should not be here
*--------------------------------------------------------------------*
    FIND REGEX lcv_regex IN ev_unescaped_string.
    IF sy-subrc = 0.
      lv_errormessage = 'Input not properly escaped - &'(002).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

*--------------------------------------------------------------------*
* Replace '' with '
*--------------------------------------------------------------------*
    REPLACE ALL OCCURRENCES OF `''` IN ev_unescaped_string WITH `'`.


  ENDMETHOD.
endclass. "LCL_EXCEL_COMMON implementation

*>>>>>>> LCL_EXCEL_WORKSHEET <<<<<<<*

*"* macro definitions
*include Lcl_excel_worksheet===========ccmac.
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

*"* local class implementation
*include Lcl_excel_worksheet===========ccimp.
*"* use this source file for the definition and implementation of
*"* local helper classes, interface definitions and type
*"* declarations


*"* test class
*include Lcl_excel_worksheet===========ccau.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABESE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABJSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABKSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABFSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABLSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABGSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABHSE4 DEFINITION DEFERRED.
*CLASS SHRITEFUH64VYIPN5I4UIDBJABMSE4 DEFINITION DEFERRED.
*CLASS Lcl_excel_worksheet DEFINITION LOCAL FRIENDS
*    SHRITEFUH64VYIPN5I4UIDBJABESE4
*    SHRITEFUH64VYIPN5I4UIDBJABJSE4
*    SHRITEFUH64VYIPN5I4UIDBJABKSE4
*    SHRITEFUH64VYIPN5I4UIDBJABFSE4
*    SHRITEFUH64VYIPN5I4UIDBJABHSE4
*    SHRITEFUH64VYIPN5I4UIDBJABLSE4
*    SHRITEFUH64VYIPN5I4UIDBJABGSE4
*    SHRITEFUH64VYIPN5I4UIDBJABMSE4.



































class LCL_EXCEL_WORKSHEET implementation.
*"* method's implementations
*include methods.
  METHOD convert_to_table.

    TYPES:
      BEGIN OF ts_field_conv,
        fieldname TYPE x031l-fieldname,
        convexit  TYPE x031l-convexit,
      END OF ts_field_conv,
      BEGIN OF ts_style_conv,
        cell_style TYPE zexcel_s_cell_data-cell_style,
        abap_type  TYPE abap_typekind,
      END OF ts_style_conv.

    DATA:
      lv_row_int          TYPE zexcel_cell_row,
      lv_column_int       TYPE zexcel_cell_column,
      lv_column_alpha     TYPE zexcel_cell_column_alpha,
      lt_field_catalog    TYPE zexcel_t_fieldcatalog,
      ls_field_catalog    TYPE zexcel_s_fieldcatalog,
      lv_value            TYPE string,
      lv_maxcol           TYPE i,
      lv_maxrow           TYPE i,
      lt_field_conv       TYPE TABLE OF ts_field_conv,
      lt_comp             TYPE abap_component_tab,
      ls_comp             TYPE abap_componentdescr,
      lo_line_type        TYPE REF TO cl_abap_structdescr,
      lo_tab_type         TYPE REF TO cl_abap_tabledescr,
      lr_data             TYPE REF TO data,
      lt_comp_view        TYPE abap_component_view_tab,
      ls_comp_view        TYPE abap_simple_componentdescr,
      lt_ddic_object      TYPE dd_x031l_table,
      lt_ddic_object_comp TYPE dd_x031l_table,
      ls_ddic_object      TYPE x031l,
      lt_style_conv       TYPE TABLE OF ts_style_conv,
      ls_style_conv       TYPE ts_style_conv,
      ls_stylemapping     TYPE zexcel_s_stylemapping,
      lv_format_code      TYPE zexcel_number_format,
      lv_float            TYPE f,
      lt_map_excel_row    TYPE TABLE OF i,
      lv_index            TYPE i,
      lv_index_col        TYPE i.

    FIELD-SYMBOLS:
      <lt_data>          TYPE STANDARD TABLE,
      <ls_data>          TYPE data,
      <lv_data>          TYPE data,
      <lt_data2>         TYPE STANDARD TABLE,
      <ls_data2>         TYPE data,
      <lv_data2>         TYPE data,
      <ls_field_conv>    TYPE ts_field_conv,
      <ls_ddic_object>   TYPE x031l,
      <ls_sheet_content> TYPE zexcel_s_cell_data,
      <fs_typekind_int8> TYPE abap_typekind.

    CLEAR: et_data, er_data.

    lv_maxcol = get_highest_column( ).
    lv_maxrow = get_highest_row( ).


    " Field catalog
    lt_field_catalog = it_field_catalog.
    IF lt_field_catalog IS INITIAL.
      IF et_data IS SUPPLIED.
        lt_field_catalog = Lcl_excel_common=>get_fieldcatalog( ip_table = et_data ).
      ELSE.
        DO lv_maxcol TIMES.
          ls_field_catalog-position = sy-index.
          ls_field_catalog-fieldname = 'COL_' && sy-index.
          ls_field_catalog-dynpfld = abap_true.
          APPEND ls_field_catalog TO lt_field_catalog.
        ENDDO.
      ENDIF.
    ENDIF.

    SORT lt_field_catalog BY position.
    DELETE lt_field_catalog WHERE dynpfld NE abap_true.
    CHECK: lt_field_catalog IS NOT INITIAL.


    " Create dynamic table string columns
    ls_comp-type = cl_abap_elemdescr=>get_string( ).
    LOOP AT lt_field_catalog INTO ls_field_catalog.
      ls_comp-name = ls_field_catalog-fieldname.
      APPEND ls_comp TO lt_comp.
    ENDLOOP.
    lo_line_type = cl_abap_structdescr=>create( lt_comp ).
    lo_tab_type = cl_abap_tabledescr=>create( lo_line_type ).
    CREATE DATA er_data TYPE HANDLE lo_tab_type.
    ASSIGN er_data->* TO <lt_data>.


    " Collect field conversion rules
    IF et_data IS SUPPLIED.
*      lt_ddic_object = get_ddic_object( et_data ).
      lo_tab_type ?= cl_abap_tabledescr=>describe_by_data( et_data ).
      lo_line_type ?= lo_tab_type->get_table_line_type( ).
      lo_line_type->get_ddic_object(
        RECEIVING
          p_object = lt_ddic_object
        EXCEPTIONS
          OTHERS   = 3
      ).
      IF lt_ddic_object IS INITIAL.
        lt_comp_view = lo_line_type->get_included_view( ).
        LOOP AT lt_comp_view INTO ls_comp_view.
          ls_comp_view-type->get_ddic_object(
            RECEIVING
              p_object = lt_ddic_object_comp
            EXCEPTIONS
              OTHERS   = 3
          ).
          IF lt_ddic_object_comp IS NOT INITIAL.
            READ TABLE lt_ddic_object_comp INTO ls_ddic_object INDEX 1.
            ls_ddic_object-fieldname = ls_comp_view-name.
            APPEND ls_ddic_object TO lt_ddic_object.
          ENDIF.
        ENDLOOP.
      ENDIF.

      SORT lt_ddic_object BY fieldname.
      LOOP AT lt_field_catalog INTO ls_field_catalog.
        APPEND INITIAL LINE TO lt_field_conv ASSIGNING <ls_field_conv>.
        MOVE-CORRESPONDING ls_field_catalog TO <ls_field_conv>.
        READ TABLE lt_ddic_object ASSIGNING <ls_ddic_object> WITH KEY fieldname = <ls_field_conv>-fieldname BINARY SEARCH.
        CHECK: sy-subrc EQ 0.

        ASSIGN ('CL_ABAP_TYPEDESCR=>TYPEKIND_INT8') TO <fs_typekind_int8>.
        IF sy-subrc <> 0.
          ASSIGN space TO <fs_typekind_int8>. "not used as typekind!
        ENDIF.

        CASE <ls_ddic_object>-exid.
          WHEN cl_abap_typedescr=>typekind_int
            OR cl_abap_typedescr=>typekind_int1
            OR <fs_typekind_int8>
            OR cl_abap_typedescr=>typekind_int2
            OR cl_abap_typedescr=>typekind_packed
            OR cl_abap_typedescr=>typekind_decfloat
            OR cl_abap_typedescr=>typekind_decfloat16
            OR cl_abap_typedescr=>typekind_decfloat34
            OR cl_abap_typedescr=>typekind_float.
            " Numbers
            <ls_field_conv>-convexit = cl_abap_typedescr=>typekind_float.
          WHEN OTHERS.
            <ls_field_conv>-convexit = <ls_ddic_object>-convexit.
        ENDCASE.
      ENDLOOP.
    ENDIF.

    " Date & Time in excel style
    LOOP AT me->sheet_content ASSIGNING <ls_sheet_content> WHERE cell_style IS NOT INITIAL AND data_type IS INITIAL.
      ls_style_conv-cell_style = <ls_sheet_content>-cell_style.
      APPEND ls_style_conv TO lt_style_conv.
    ENDLOOP.
    IF lt_style_conv IS NOT INITIAL.
      SORT lt_style_conv BY cell_style.
      DELETE ADJACENT DUPLICATES FROM lt_style_conv COMPARING cell_style.

      LOOP AT lt_style_conv INTO ls_style_conv.

        ls_stylemapping = me->excel->get_style_to_guid( ls_style_conv-cell_style ).
        lv_format_code = ls_stylemapping-complete_style-number_format-format_code.
        " https://support.microsoft.com/en-us/office/number-format-codes-5026bbd6-04bc-48cd-bf33-80f18b4eae68
        IF lv_format_code CS ';'.
          lv_format_code = lv_format_code(sy-fdpos).
        ENDIF.
        CHECK: lv_format_code NA '#?'.

        " Remove color pattern
        REPLACE ALL OCCURRENCES OF REGEX '\[\L[^]]*\]' IN lv_format_code WITH ''.

        IF lv_format_code CA 'yd' OR lv_format_code EQ Lcl_excel_style_number_format=>c_format_date_std.
          " DATE = yyyymmdd
          ls_style_conv-abap_type = cl_abap_typedescr=>typekind_date.
        ELSEIF lv_format_code CA 'hs'.
          " TIME = hhmmss
          ls_style_conv-abap_type = cl_abap_typedescr=>typekind_time.
        ELSE.
          DELETE lt_style_conv.
          CONTINUE.
        ENDIF.

        MODIFY lt_style_conv FROM ls_style_conv TRANSPORTING abap_type.

      ENDLOOP.
    ENDIF.


*--------------------------------------------------------------------*
* Start of convert content
*--------------------------------------------------------------------*
    READ TABLE me->sheet_content TRANSPORTING NO FIELDS WITH KEY cell_row = iv_begin_row.
    IF sy-subrc EQ 0.
      lv_index = sy-tabix.
    ENDIF.

    LOOP AT me->sheet_content ASSIGNING <ls_sheet_content> FROM lv_index.
      AT NEW cell_row.
        IF iv_end_row <> 0
        AND <ls_sheet_content>-cell_row > iv_end_row.
          EXIT.
        ENDIF.
        " New line
        APPEND INITIAL LINE TO <lt_data> ASSIGNING <ls_data>.
        lv_index = sy-tabix.
      ENDAT.

      IF <ls_sheet_content>-cell_value IS NOT INITIAL.
        ASSIGN COMPONENT <ls_sheet_content>-cell_column OF STRUCTURE <ls_data> TO <lv_data>.
        IF sy-subrc EQ 0.
          " value
          <lv_data> = <ls_sheet_content>-cell_value.

          " field conversion
          READ TABLE lt_field_conv ASSIGNING <ls_field_conv> INDEX <ls_sheet_content>-cell_column.
          IF sy-subrc EQ 0 AND <ls_field_conv>-convexit IS NOT INITIAL.
            CASE <ls_field_conv>-convexit.
              WHEN cl_abap_typedescr=>typekind_float.
                lv_float = Lcl_excel_common=>excel_string_to_number( <ls_sheet_content>-cell_value ).
                <lv_data> = |{ lv_float NUMBER = RAW }|.
              WHEN 'ALPHA'.
                CALL FUNCTION 'CONVERSION_EXIT_ALPHA_OUTPUT'
                  EXPORTING
                    input  = <ls_sheet_content>-cell_value
                  IMPORTING
                    output = <lv_data>.
            ENDCASE.
          ENDIF.

          " style conversion
          IF <ls_sheet_content>-cell_style IS NOT INITIAL.
            READ TABLE lt_style_conv INTO ls_style_conv WITH KEY cell_style = <ls_sheet_content>-cell_style BINARY SEARCH.
            IF sy-subrc EQ 0.
              CASE ls_style_conv-abap_type.
                WHEN cl_abap_typedescr=>typekind_date.
                  <lv_data> = Lcl_excel_common=>excel_string_to_date( <ls_sheet_content>-cell_value ).
                WHEN cl_abap_typedescr=>typekind_time.
                  <lv_data> = Lcl_excel_common=>excel_string_to_time( <ls_sheet_content>-cell_value ).
              ENDCASE.
            ENDIF.
          ENDIF.

          " condense
          CONDENSE <lv_data>.
        ENDIF.
      ENDIF.

      AT END OF cell_row.
        " Delete empty line
        IF <ls_data> IS INITIAL.
          DELETE <lt_data> INDEX lv_index.
        ELSE.
          APPEND <ls_sheet_content>-cell_row TO lt_map_excel_row.
        ENDIF.
      ENDAT.
    ENDLOOP.
*--------------------------------------------------------------------*
* End of convert content
*--------------------------------------------------------------------*


    IF et_data IS SUPPLIED.
*      MOVE-CORRESPONDING <lt_data> TO et_data.
      LOOP AT <lt_data> ASSIGNING <ls_data>.
        APPEND INITIAL LINE TO et_data ASSIGNING <ls_data2>.
        MOVE-CORRESPONDING <ls_data> TO <ls_data2>.
      ENDLOOP.
    ENDIF.

    " Apply conversion exit.
    LOOP AT lt_field_conv ASSIGNING <ls_field_conv>
     WHERE convexit = 'ALPHA'.
      LOOP AT et_data ASSIGNING <ls_data>.
        ASSIGN COMPONENT <ls_field_conv>-fieldname OF STRUCTURE <ls_data> TO <lv_data>.
        CHECK: sy-subrc EQ 0 AND <lv_data> IS NOT INITIAL.
        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
          EXPORTING
            input  = <lv_data>
          IMPORTING
            output = <lv_data>.
      ENDLOOP.
    ENDLOOP.

  ENDMETHOD.
  METHOD set_table_reference.

    FIELD-SYMBOLS: <ls_sheet_content> TYPE zexcel_s_cell_data.

    READ TABLE sheet_content ASSIGNING <ls_sheet_content> WITH KEY cell_row    = ip_row
                                                                   cell_column = ip_column.
    IF sy-subrc = 0.
      <ls_sheet_content>-table           = ir_table.
      <ls_sheet_content>-table_fieldname = ip_fieldname.
      <ls_sheet_content>-table_header    = ip_header.
    ELSE.
      Lcx_excel=>raise_text( 'Cell not found' ).
    ENDIF.

  ENDMETHOD.
  METHOD add_comment.
    comments->include( ip_comment ).
  ENDMETHOD.                    "add_comment
  METHOD add_drawing.
    CASE ip_drawing->get_type( ).
      WHEN Lcl_excel_drawing=>type_image.
        drawings->include( ip_drawing ).
      WHEN Lcl_excel_drawing=>type_chart.
        charts->include( ip_drawing ).
    ENDCASE.
  ENDMETHOD.                    "ADD_DRAWING
  METHOD add_new_column.
    DATA: lv_column_alpha TYPE zexcel_cell_column_alpha.

    lv_column_alpha = Lcl_excel_common=>convert_column2alpha( ip_column ).

    CREATE OBJECT eo_column
      EXPORTING
        ip_index     = lv_column_alpha
        ip_excel     = me->excel
        ip_worksheet = me.
    columns->add( eo_column ).
  ENDMETHOD.                    "ADD_NEW_COLUMN
  METHOD add_new_data_validation.

    CREATE OBJECT eo_data_validation.
    data_validations->add( eo_data_validation ).
  ENDMETHOD.                    "ADD_NEW_DATA_VALIDATION
  METHOD add_new_range.
* Create default blank range
    CREATE OBJECT eo_range.
    ranges->add( eo_range ).
  ENDMETHOD.                    "ADD_NEW_RANGE
  METHOD add_new_row.
    CREATE OBJECT eo_row
      EXPORTING
        ip_index = ip_row.
    rows->add( eo_row ).
  ENDMETHOD.                    "ADD_NEW_ROW
  METHOD add_new_style_cond.
    CREATE OBJECT eo_style_cond EXPORTING ip_dimension_range = ip_dimension_range.
    styles_cond->add( eo_style_cond ).
  ENDMETHOD.                    "ADD_NEW_STYLE_COND
  METHOD bind_alv.
    DATA: lo_converter TYPE REF TO Lcl_excel_converter.

    CREATE OBJECT lo_converter.

    TRY.
        lo_converter->convert(
          EXPORTING
            io_alv         = io_alv
            it_table       = it_table
            i_row_int      = i_top
            i_column_int   = i_left
            i_table        = i_table
            i_style_table  = table_style
            io_worksheet   = me
          CHANGING
            co_excel       = excel ).
      CATCH Lcx_excel .
    ENDTRY.

  ENDMETHOD.                    "BIND_ALV
  METHOD bind_alv_ole2.

    CALL METHOD ('LCL_EXCEL_OLE')=>('BIND_ALV_OLE2')
      EXPORTING
        i_document_url          = i_document_url
        i_xls                   = i_xls
        i_save_path             = i_save_path
        io_alv                  = io_alv
        it_listheader           = it_listheader
        i_top                   = i_top
        i_left                  = i_left
        i_columns_header        = i_columns_header
        i_columns_autofit       = i_columns_autofit
        i_format_col_header     = i_format_col_header
        i_format_subtotal       = i_format_subtotal
        i_format_total          = i_format_total
      EXCEPTIONS
        miss_guide              = 1
        ex_transfer_kkblo_error = 2
        fatal_error             = 3
        inv_data_range          = 4
        dim_mismatch_vkey       = 5
        dim_mismatch_sema       = 6
        error_in_sema           = 7
        OTHERS                  = 8.
    IF sy-subrc <> 0.
      CASE sy-subrc.
        WHEN 1. RAISE miss_guide.
        WHEN 2. RAISE ex_transfer_kkblo_error.
        WHEN 3. RAISE fatal_error.
        WHEN 4. RAISE inv_data_range.
        WHEN 5. RAISE dim_mismatch_vkey.
        WHEN 6. RAISE dim_mismatch_sema.
        WHEN 7. RAISE error_in_sema.
      ENDCASE.
    ENDIF.

  ENDMETHOD.                    "BIND_ALV_OLE2
  METHOD bind_table.
*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmöcker,      (wi p)              2012-12-01
*              - ...
*          aligning code
*          message made to support multilinguality
*--------------------------------------------------------------------*
* issue #237   - Check if overlapping areas exist
*              - Alessandro Iannacci                        2012-12-01
* changes:     - Added raise if overlaps are detected
*--------------------------------------------------------------------*

    CONSTANTS:
      lc_top_left_column TYPE zexcel_cell_column_alpha VALUE 'A',
      lc_top_left_row    TYPE zexcel_cell_row VALUE 1,
      lc_no_currency     TYPE waers_curc VALUE IS INITIAL.

    DATA:
      lv_row_int              TYPE zexcel_cell_row,
      lv_first_row            TYPE zexcel_cell_row,
      lv_last_row             TYPE zexcel_cell_row,
      lv_column_int           TYPE zexcel_cell_column,
      lv_column_alpha         TYPE zexcel_cell_column_alpha,
      lt_field_catalog        TYPE zexcel_t_fieldcatalog,
      lv_id                   TYPE i,
      lv_formula              TYPE string,
      ls_settings             TYPE zexcel_s_table_settings,
      lo_table                TYPE REF TO Lcl_excel_table,
      lv_value_lowercase      TYPE string,
      lv_syindex              TYPE c LENGTH 3,
      lo_iterator             TYPE REF TO Lcl_excel_collection_iterator,
      lo_style_cond           TYPE REF TO Lcl_excel_style_cond,
      lo_curtable             TYPE REF TO Lcl_excel_table,
      lt_other_table_settings TYPE ty_table_settings.
    DATA: ls_column_formula TYPE mty_s_column_formula,
          lv_mincol         TYPE i.

    FIELD-SYMBOLS:
      <ls_field_catalog>        TYPE zexcel_s_fieldcatalog,
      <ls_field_catalog_custom> TYPE zexcel_s_fieldcatalog,
      <fs_table_line>           TYPE any,
      <fs_fldval>               TYPE any,
      <fs_fldval_currency>      TYPE waers.

    ls_settings = is_table_settings.

    IF ls_settings-top_left_column IS INITIAL.
      ls_settings-top_left_column = lc_top_left_column.
    ENDIF.

    IF ls_settings-table_style IS INITIAL.
      ls_settings-table_style = Lcl_excel_table=>builtinstyle_medium2.
    ENDIF.

    IF ls_settings-top_left_row IS INITIAL.
      ls_settings-top_left_row = lc_top_left_row.
    ENDIF.

    IF it_field_catalog IS NOT SUPPLIED.
      lt_field_catalog = Lcl_excel_common=>get_fieldcatalog( ip_table = ip_table
                                                             ip_conv_exit_length = ip_conv_exit_length ).
    ELSE.
      lt_field_catalog = it_field_catalog.
    ENDIF.

    SORT lt_field_catalog BY position.

    calculate_table_bottom_right(
      EXPORTING
        ip_table         = ip_table
        it_field_catalog = lt_field_catalog
      CHANGING
        cs_settings      = ls_settings ).

* Check if overlapping areas exist

    lo_iterator = me->tables->get_iterator( ).
    WHILE lo_iterator->has_next( ) EQ abap_true.
      lo_curtable ?= lo_iterator->get_next( ).
      APPEND lo_curtable->settings TO lt_other_table_settings.
    ENDWHILE.

    check_table_overlapping(
        is_table_settings       = ls_settings
        it_other_table_settings = lt_other_table_settings ).

* Start filling the table

    CREATE OBJECT lo_table.
    lo_table->settings = ls_settings.
    lo_table->set_data( ir_data = ip_table ).
    lv_id = me->excel->get_next_table_id( ).
    lo_table->set_id( iv_id = lv_id ).

    me->tables->add( lo_table ).

    lv_column_int = Lcl_excel_common=>convert_column2int( ls_settings-top_left_column ).
    lv_row_int = ls_settings-top_left_row.

    lt_field_catalog = normalize_column_heading_texts(
          iv_default_descr = iv_default_descr
          it_field_catalog = lt_field_catalog ).

* It is better to loop column by column (only visible column)
    LOOP AT lt_field_catalog ASSIGNING <ls_field_catalog> WHERE dynpfld EQ abap_true.

      lv_column_alpha = Lcl_excel_common=>convert_column2alpha( lv_column_int ).

      " First of all write column header
      IF <ls_field_catalog>-style_header IS NOT INITIAL.
        me->set_cell( ip_column = lv_column_alpha
                      ip_row    = lv_row_int
                      ip_value  = <ls_field_catalog>-column_name
                      ip_style  = <ls_field_catalog>-style_header ).
      ELSE.
        me->set_cell( ip_column = lv_column_alpha
                      ip_row    = lv_row_int
                      ip_value  = <ls_field_catalog>-column_name ).
      ENDIF.

      me->set_table_reference( ip_column    = lv_column_int
                               ip_row       = lv_row_int
                               ir_table     = lo_table
                               ip_fieldname = <ls_field_catalog>-fieldname
                               ip_header    = abap_true ).

      IF <ls_field_catalog>-column_formula IS NOT INITIAL.
        ls_column_formula-id                     = lines( column_formulas ) + 1.
        ls_column_formula-column                 = lv_column_int.
        ls_column_formula-formula                = <ls_field_catalog>-column_formula.
        ls_column_formula-table_top_left_row     = lo_table->settings-top_left_row.
        ls_column_formula-table_bottom_right_row = lo_table->settings-bottom_right_row.
        ls_column_formula-table_left_column_int  = lv_mincol.
        ls_column_formula-table_right_column_int = Lcl_excel_common=>convert_column2int( lo_table->settings-bottom_right_column ).
        INSERT ls_column_formula INTO TABLE column_formulas.
      ENDIF.

      ADD 1 TO lv_row_int.
      LOOP AT ip_table ASSIGNING <fs_table_line>.

        ASSIGN COMPONENT <ls_field_catalog>-fieldname OF STRUCTURE <fs_table_line> TO <fs_fldval>.

        " issue #290 Add formula support in table
        IF <ls_field_catalog>-formula EQ abap_true.
          IF <ls_field_catalog>-style IS NOT INITIAL.
            IF <ls_field_catalog>-abap_type IS NOT INITIAL.
              me->set_cell( ip_column   = lv_column_alpha
                          ip_row      = lv_row_int
                          ip_formula  = <fs_fldval>
                          ip_abap_type = <ls_field_catalog>-abap_type
                          ip_style    = <ls_field_catalog>-style ).
            ELSE.
              me->set_cell( ip_column   = lv_column_alpha
                            ip_row      = lv_row_int
                            ip_formula  = <fs_fldval>
                            ip_style    = <ls_field_catalog>-style ).
            ENDIF.
          ELSEIF <ls_field_catalog>-abap_type IS NOT INITIAL.
            me->set_cell( ip_column   = lv_column_alpha
                          ip_row      = lv_row_int
                          ip_formula  = <fs_fldval>
                          ip_abap_type = <ls_field_catalog>-abap_type ).
          ELSE.
            me->set_cell( ip_column   = lv_column_alpha
                          ip_row      = lv_row_int
                          ip_formula  = <fs_fldval> ).
          ENDIF.
        ELSEIF <ls_field_catalog>-column_formula IS NOT INITIAL.
          " Column formulas
          IF <ls_field_catalog>-style IS NOT INITIAL.
            IF <ls_field_catalog>-abap_type IS NOT INITIAL.
              me->set_cell( ip_column            = lv_column_alpha
                            ip_row               = lv_row_int
                            ip_column_formula_id = ls_column_formula-id
                            ip_abap_type         = <ls_field_catalog>-abap_type
                            ip_style             = <ls_field_catalog>-style ).
            ELSE.
              me->set_cell( ip_column            = lv_column_alpha
                            ip_row               = lv_row_int
                            ip_column_formula_id = ls_column_formula-id
                            ip_style             = <ls_field_catalog>-style ).
            ENDIF.
          ELSEIF <ls_field_catalog>-abap_type IS NOT INITIAL.
            me->set_cell( ip_column             = lv_column_alpha
                          ip_row                = lv_row_int
                          ip_column_formula_id  = ls_column_formula-id
                          ip_abap_type          = <ls_field_catalog>-abap_type ).
          ELSE.
            me->set_cell( ip_column            = lv_column_alpha
                          ip_row               = lv_row_int
                          ip_column_formula_id = ls_column_formula-id ).
          ENDIF.
        ELSE.
          IF <ls_field_catalog>-currency_column IS INITIAL OR ip_conv_curr_amt_ext = abap_false.
            ASSIGN lc_no_currency TO <fs_fldval_currency>.
          ELSE.
            ASSIGN COMPONENT <ls_field_catalog>-currency_column OF STRUCTURE <fs_table_line> TO <fs_fldval_currency>.
          ENDIF.

          IF <ls_field_catalog>-style IS NOT INITIAL.
            IF <ls_field_catalog>-abap_type IS NOT INITIAL.
              me->set_cell( ip_column           = lv_column_alpha
                            ip_row              = lv_row_int
                            ip_value            = <fs_fldval>
                            ip_abap_type        = <ls_field_catalog>-abap_type
                            ip_currency         = <fs_fldval_currency>
                            ip_style            = <ls_field_catalog>-style
                            ip_conv_exit_length = ip_conv_exit_length ).
            ELSE.
              me->set_cell( ip_column = lv_column_alpha
                            ip_row    = lv_row_int
                            ip_value  = <fs_fldval>
                            ip_currency = <fs_fldval_currency>
                            ip_style  = <ls_field_catalog>-style
                            ip_conv_exit_length = ip_conv_exit_length ).
            ENDIF.
          ELSE.
            IF <ls_field_catalog>-abap_type IS NOT INITIAL.
              me->set_cell( ip_column = lv_column_alpha
                          ip_row    = lv_row_int
                          ip_abap_type = <ls_field_catalog>-abap_type
                          ip_currency  = <fs_fldval_currency>
                          ip_value  = <fs_fldval>
                          ip_conv_exit_length = ip_conv_exit_length ).
            ELSE.
              me->set_cell( ip_column = lv_column_alpha
                            ip_row    = lv_row_int
                            ip_currency = <fs_fldval_currency>
                            ip_value  = <fs_fldval>
                            ip_conv_exit_length = ip_conv_exit_length ).
            ENDIF.
          ENDIF.
        ENDIF.
        ADD 1 TO lv_row_int.

      ENDLOOP.
      IF sy-subrc <> 0 AND iv_no_line_if_empty = abap_false. "create empty row if table has no data
        me->set_cell( ip_column = lv_column_alpha
                      ip_row    = lv_row_int
                      ip_value  = space ).
        ADD 1 TO lv_row_int.
      ENDIF.

*--------------------------------------------------------------------*
      " totals
*--------------------------------------------------------------------*
      IF <ls_field_catalog>-totals_function IS NOT INITIAL.
        lv_formula = lo_table->get_totals_formula( ip_column = <ls_field_catalog>-column_name ip_function = <ls_field_catalog>-totals_function ).
        IF <ls_field_catalog>-style_total IS NOT INITIAL.
          me->set_cell( ip_column   = lv_column_alpha
                        ip_row      = lv_row_int
                        ip_formula  = lv_formula
                        ip_style    = <ls_field_catalog>-style_total ).
        ELSE.
          me->set_cell( ip_column   = lv_column_alpha
                        ip_row      = lv_row_int
                        ip_formula  = lv_formula ).
        ENDIF.
      ENDIF.

      lv_row_int = ls_settings-top_left_row.
      ADD 1 TO lv_column_int.

*--------------------------------------------------------------------*
      " conditional formatting
*--------------------------------------------------------------------*
      IF <ls_field_catalog>-style_cond IS NOT INITIAL.
        lv_first_row    = ls_settings-top_left_row + 1. " +1 to exclude header
        lv_last_row     = ls_settings-bottom_right_row.
        lo_style_cond = me->get_style_cond( <ls_field_catalog>-style_cond ).
        lo_style_cond->set_range( ip_start_column  = lv_column_alpha
                                  ip_start_row     = lv_first_row
                                  ip_stop_column   = lv_column_alpha
                                  ip_stop_row      = lv_last_row ).
      ENDIF.

    ENDLOOP.

*--------------------------------------------------------------------*
    " Set field catalog
*--------------------------------------------------------------------*
    lo_table->fieldcat = lt_field_catalog[].

    es_table_settings = ls_settings.
    es_table_settings-bottom_right_column = lv_column_alpha.
    " >> Issue #291
    IF ip_table IS INITIAL.
      es_table_settings-bottom_right_row    = ls_settings-top_left_row + 2.           "Last rows
    ELSE.
      es_table_settings-bottom_right_row    = ls_settings-bottom_right_row + 1. "Last rows
    ENDIF.
    " << Issue #291

  ENDMETHOD.                    "BIND_TABLE
  METHOD calculate_cell_width.
*--------------------------------------------------------------------*
* issue #293   - Roberto Bianco
*              - Christian Assig                            2014-03-14
*
* changes: - Calculate widths using SAPscript font metrics
*            (transaction SE73)
*          - Calculate the width of dates
*          - Add additional width for auto filter buttons
*          - Add cell padding to simulate Excel behavior
*--------------------------------------------------------------------*

    DATA: ld_cell_value                TYPE zexcel_cell_value,
          ld_style_guid                TYPE zexcel_cell_style,
          ls_stylemapping              TYPE zexcel_s_stylemapping,
          lo_table_object              TYPE REF TO object,
          lo_table                     TYPE REF TO Lcl_excel_table,
          ld_table_top_left_column     TYPE zexcel_cell_column,
          ld_table_bottom_right_column TYPE zexcel_cell_column,
          ld_flag_contains_auto_filter TYPE abap_bool VALUE abap_false,
          ld_flag_bold                 TYPE abap_bool VALUE abap_false,
          ld_flag_italic               TYPE abap_bool VALUE abap_false,
          ld_date                      TYPE d,
          ld_date_char                 TYPE c LENGTH 50,
          ld_font_height               TYPE tdfontsize VALUE Lcl_excel_font=>lc_default_font_height,
          ld_font_name                 TYPE zexcel_style_font_name VALUE Lcl_excel_font=>lc_default_font_name.

    " Determine cell content and cell style
    me->get_cell( EXPORTING ip_column = ip_column
                            ip_row    = ip_row
                  IMPORTING ep_value  = ld_cell_value
                            ep_guid   = ld_style_guid ).

    " ABAP2XLSX uses tables to define areas containing headers and
    " auto-filters. Find out if the current cell is in the header
    " of one of these tables.
    LOOP AT me->tables->collection INTO lo_table_object.
      " Downcast: OBJECT -> LCL_EXCEL_TABLE
      lo_table ?= lo_table_object.

      " Convert column letters to corresponding integer values
      ld_table_top_left_column =
        Lcl_excel_common=>convert_column2int(
          lo_table->settings-top_left_column ).

      ld_table_bottom_right_column =
        Lcl_excel_common=>convert_column2int(
          lo_table->settings-bottom_right_column ).

      " Is the current cell part of the table header?
      IF ip_column BETWEEN ld_table_top_left_column AND
                           ld_table_bottom_right_column AND
         ip_row    EQ lo_table->settings-top_left_row.
        " Current cell is part of the table header
        " -> Assume that an auto filter is present and that the font is
        "    bold
        ld_flag_contains_auto_filter = abap_true.
        ld_flag_bold = abap_true.
      ENDIF.
    ENDLOOP.

    " If a style GUID is present, read style attributes
    IF ld_style_guid IS NOT INITIAL.
      TRY.
          " Read style attributes
          ls_stylemapping = me->excel->get_style_to_guid( ld_style_guid ).

          " If the current cell contains the default date format,
          " convert the cell value to a date and calculate its length
          IF ls_stylemapping-complete_style-number_format-format_code =
             Lcl_excel_style_number_format=>c_format_date_std.

            " Convert excel date to ABAP date
            ld_date =
              Lcl_excel_common=>excel_string_to_date( ld_cell_value ).

            " Format ABAP date using user's formatting settings
            WRITE ld_date TO ld_date_char.

            " Remember the formatted date to calculate the cell size
            ld_cell_value = ld_date_char.

          ENDIF.

          " Read the font size and convert it to the font height
          " used by SAPscript (multiplication by 10)
          IF ls_stylemapping-complete_stylex-font-size = abap_true.
            ld_font_height = ls_stylemapping-complete_style-font-size * 10.
          ENDIF.

          " If set, remember the font name
          IF ls_stylemapping-complete_stylex-font-name = abap_true.
            ld_font_name = ls_stylemapping-complete_style-font-name.
          ENDIF.

          " If set, remember whether font is bold and italic.
          IF ls_stylemapping-complete_stylex-font-bold = abap_true.
            ld_flag_bold = ls_stylemapping-complete_style-font-bold.
          ENDIF.

          IF ls_stylemapping-complete_stylex-font-italic = abap_true.
            ld_flag_italic = ls_stylemapping-complete_style-font-italic.
          ENDIF.

        CATCH Lcx_excel.                                "#EC NO_HANDLER
          " Style GUID is present, but style was not found
          " Continue with default values

      ENDTRY.
    ENDIF.

    ep_width = Lcl_excel_font=>calculate_text_width(
      iv_font_name   = ld_font_name
      iv_font_height = ld_font_height
      iv_flag_bold   = ld_flag_bold
      iv_flag_italic = ld_flag_italic
      iv_cell_value  = ld_cell_value ).

    " If the current cell contains an auto filter, make it a bit wider.
    " The size used by the auto filter button does not depend on the font
    " size.
    IF ld_flag_contains_auto_filter = abap_true.
      ADD 2 TO ep_width.
    ENDIF.

  ENDMETHOD.
  METHOD calculate_column_widths.
    TYPES:
      BEGIN OF t_auto_size,
        col_index TYPE int4,
        width     TYPE f,
      END   OF t_auto_size.
    TYPES: tt_auto_size TYPE TABLE OF t_auto_size.

    DATA: lo_column_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_column          TYPE REF TO Lcl_excel_column.

    DATA: auto_size   TYPE flag.
    DATA: auto_sizes  TYPE tt_auto_size.
    DATA: count       TYPE int4.
    DATA: highest_row TYPE int4.
    DATA: width       TYPE f.

    FIELD-SYMBOLS: <auto_size>        LIKE LINE OF auto_sizes.

    lo_column_iterator = me->get_columns_iterator( ).
    WHILE lo_column_iterator->has_next( ) = abap_true.
      lo_column ?= lo_column_iterator->get_next( ).
      auto_size = lo_column->get_auto_size( ).
      IF auto_size = abap_true.
        APPEND INITIAL LINE TO auto_sizes ASSIGNING <auto_size>.
        <auto_size>-col_index = lo_column->get_column_index( ).
        <auto_size>-width     = -1.
      ENDIF.
    ENDWHILE.

    " There is only something to do if there are some auto-size columns
    IF NOT auto_sizes IS INITIAL.
      highest_row = me->get_highest_row( ).
      LOOP AT auto_sizes ASSIGNING <auto_size>.
        count = 1.
        WHILE count <= highest_row.
* Do not check merged cells
          IF is_cell_merged(
              ip_column    = <auto_size>-col_index
              ip_row       = count ) = abap_false.
            width = calculate_cell_width( ip_column = <auto_size>-col_index     " issue #155 - less restrictive typing for ip_column
                                          ip_row    = count ).
            IF width > <auto_size>-width.
              <auto_size>-width = width.
            ENDIF.
          ENDIF.
          count = count + 1.
        ENDWHILE.
        lo_column = me->get_column( <auto_size>-col_index ). " issue #155 - less restrictive typing for ip_column
        lo_column->set_width( <auto_size>-width ).
      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    "CALCULATE_COLUMN_WIDTHS
  METHOD calculate_table_bottom_right.

    DATA: lv_errormessage TYPE string,
          lv_columns      TYPE i,
          lt_columns      TYPE zexcel_t_fieldcatalog,
          lv_maxrow       TYPE i,
          lo_iterator     TYPE REF TO Lcl_excel_collection_iterator,
          lo_curtable     TYPE REF TO Lcl_excel_table,
          lv_row_int      TYPE zexcel_cell_row,
          lv_column_int   TYPE zexcel_cell_column,
          lv_rows         TYPE i,
          lv_maxcol       TYPE i.

    "Get the number of columns for the current table
    lt_columns = it_field_catalog.
    DELETE lt_columns WHERE dynpfld NE abap_true.
    DESCRIBE TABLE lt_columns LINES lv_columns.

    "Calculate the top left row of the current table
    lv_column_int = Lcl_excel_common=>convert_column2int( cs_settings-top_left_column ).
    lv_row_int    = cs_settings-top_left_row.

    "Get number of row for the current table
    DESCRIBE TABLE ip_table LINES lv_rows.

    "Calculate the bottom right row for the current table
    lv_maxcol                       = lv_column_int + lv_columns - 1.
    lv_maxrow                       = lv_row_int    + lv_rows.
    cs_settings-bottom_right_column = Lcl_excel_common=>convert_column2alpha( lv_maxcol ).
    cs_settings-bottom_right_row    = lv_maxrow.

  ENDMETHOD.
  METHOD change_area_style.

    DATA: lv_row              TYPE zexcel_cell_row,
          lv_row_start        TYPE zexcel_cell_row,
          lv_row_to           TYPE zexcel_cell_row,
          lv_column_int       TYPE zexcel_cell_column,
          lv_column_start_int TYPE zexcel_cell_column,
          lv_column_end_int   TYPE zexcel_cell_column.

    normalize_range_parameter( EXPORTING ip_range        = ip_range
                                         ip_column_start = ip_column_start     ip_column_end = ip_column_end
                                         ip_row          = ip_row              ip_row_to     = ip_row_to
                               IMPORTING ep_column_start = lv_column_start_int ep_column_end = lv_column_end_int
                                         ep_row          = lv_row_start        ep_row_to     = lv_row_to ).

    lv_column_int = lv_column_start_int.
    WHILE lv_column_int <= lv_column_end_int.

      lv_row = lv_row_start.
      WHILE lv_row <= lv_row_to.

        ip_style_changer->apply( ip_worksheet = me
                                 ip_column    = lv_column_int
                                 ip_row       = lv_row ).

        ADD 1 TO lv_row.
      ENDWHILE.

      ADD 1 TO lv_column_int.
    ENDWHILE.

  ENDMETHOD.
  METHOD change_cell_style.

    DATA: changer TYPE REF TO Lif_excel_style_changer,
          column  TYPE zexcel_cell_column,
          row     TYPE zexcel_cell_row.

    normalize_columnrow_parameter( EXPORTING ip_columnrow = ip_columnrow
                                             ip_column    = ip_column
                                             ip_row       = ip_row
                                   IMPORTING ep_column    = column
                                             ep_row       = row ).

    changer = Lcl_excel_style_changer=>create( excel = excel ).


    IF ip_complete IS SUPPLIED.
      IF ip_xcomplete IS NOT SUPPLIED.
        Lcx_excel=>raise_text( 'Complete styleinfo has to be supplied with corresponding X-field' ).
      ENDIF.
      changer->set_complete( ip_complete = ip_complete ip_xcomplete = ip_xcomplete ).
    ENDIF.



    IF ip_font IS SUPPLIED.
      IF ip_xfont IS SUPPLIED.
        changer->set_complete_font( ip_font = ip_font ip_xfont = ip_xfont ).
      ELSE.
        changer->set_complete_font( ip_font = ip_font ).
      ENDIF.
    ENDIF.

    IF ip_fill IS SUPPLIED.
      IF ip_xfill IS SUPPLIED.
        changer->set_complete_fill( ip_fill = ip_fill ip_xfill = ip_xfill ).
      ELSE.
        changer->set_complete_fill( ip_fill = ip_fill ).
      ENDIF.
    ENDIF.


    IF ip_borders IS SUPPLIED.
      IF ip_xborders IS SUPPLIED.
        changer->set_complete_borders( ip_borders = ip_borders ip_xborders = ip_xborders ).
      ELSE.
        changer->set_complete_borders( ip_borders = ip_borders ).
      ENDIF.
    ENDIF.

    IF ip_alignment IS SUPPLIED.
      IF ip_xalignment IS SUPPLIED.
        changer->set_complete_alignment( ip_alignment = ip_alignment ip_xalignment = ip_xalignment ).
      ELSE.
        changer->set_complete_alignment( ip_alignment = ip_alignment ).
      ENDIF.
    ENDIF.

    IF ip_protection IS SUPPLIED.
      IF ip_xprotection IS SUPPLIED.
        changer->set_complete_protection( ip_protection = ip_protection ip_xprotection = ip_xprotection ).
      ELSE.
        changer->set_complete_protection( ip_protection = ip_protection ).
      ENDIF.
    ENDIF.


    IF ip_borders_allborders IS SUPPLIED.
      IF ip_xborders_allborders IS SUPPLIED.
        changer->set_complete_borders_all( ip_borders_allborders = ip_borders_allborders ip_xborders_allborders = ip_xborders_allborders ).
      ELSE.
        changer->set_complete_borders_all( ip_borders_allborders = ip_borders_allborders ).
      ENDIF.
    ENDIF.

    IF ip_borders_diagonal IS SUPPLIED.
      IF ip_xborders_diagonal IS SUPPLIED.
        changer->set_complete_borders_diagonal( ip_borders_diagonal = ip_borders_diagonal ip_xborders_diagonal = ip_xborders_diagonal ).
      ELSE.
        changer->set_complete_borders_diagonal( ip_borders_diagonal = ip_borders_diagonal ).
      ENDIF.
    ENDIF.

    IF ip_borders_down IS SUPPLIED.
      IF ip_xborders_down IS SUPPLIED.
        changer->set_complete_borders_down( ip_borders_down = ip_borders_down ip_xborders_down = ip_xborders_down ).
      ELSE.
        changer->set_complete_borders_down( ip_borders_down = ip_borders_down ).
      ENDIF.
    ENDIF.

    IF ip_borders_left IS SUPPLIED.
      IF ip_xborders_left IS SUPPLIED.
        changer->set_complete_borders_left( ip_borders_left = ip_borders_left ip_xborders_left = ip_xborders_left ).
      ELSE.
        changer->set_complete_borders_left( ip_borders_left = ip_borders_left ).
      ENDIF.
    ENDIF.

    IF ip_borders_right IS SUPPLIED.
      IF ip_xborders_right IS SUPPLIED.
        changer->set_complete_borders_right( ip_borders_right = ip_borders_right ip_xborders_right = ip_xborders_right ).
      ELSE.
        changer->set_complete_borders_right( ip_borders_right = ip_borders_right ).
      ENDIF.
    ENDIF.

    IF ip_borders_top IS SUPPLIED.
      IF ip_xborders_top IS SUPPLIED.
        changer->set_complete_borders_top( ip_borders_top = ip_borders_top ip_xborders_top = ip_xborders_top ).
      ELSE.
        changer->set_complete_borders_top( ip_borders_top = ip_borders_top ).
      ENDIF.
    ENDIF.

    IF ip_number_format_format_code IS SUPPLIED.
      changer->set_number_format( ip_number_format_format_code ).
    ENDIF.
    IF ip_font_bold IS SUPPLIED.
      changer->set_font_bold( ip_font_bold ).
    ENDIF.
    IF ip_font_color IS SUPPLIED.
      changer->set_font_color( ip_font_color ).
    ENDIF.
    IF ip_font_color_rgb IS SUPPLIED.
      changer->set_font_color_rgb( ip_font_color_rgb ).
    ENDIF.
    IF ip_font_color_indexed IS SUPPLIED.
      changer->set_font_color_indexed( ip_font_color_indexed ).
    ENDIF.
    IF ip_font_color_theme IS SUPPLIED.
      changer->set_font_color_theme( ip_font_color_theme ).
    ENDIF.
    IF ip_font_color_tint IS SUPPLIED.
      changer->set_font_color_tint( ip_font_color_tint ).
    ENDIF.

    IF ip_font_family IS SUPPLIED.
      changer->set_font_family( ip_font_family ).
    ENDIF.
    IF ip_font_italic IS SUPPLIED.
      changer->set_font_italic( ip_font_italic ).
    ENDIF.
    IF ip_font_name IS SUPPLIED.
      changer->set_font_name( ip_font_name ).
    ENDIF.
    IF ip_font_scheme IS SUPPLIED.
      changer->set_font_scheme( ip_font_scheme ).
    ENDIF.
    IF ip_font_size IS SUPPLIED.
      changer->set_font_size( ip_font_size ).
    ENDIF.
    IF ip_font_strikethrough IS SUPPLIED.
      changer->set_font_strikethrough( ip_font_strikethrough ).
    ENDIF.
    IF ip_font_underline IS SUPPLIED.
      changer->set_font_underline( ip_font_underline ).
    ENDIF.
    IF ip_font_underline_mode IS SUPPLIED.
      changer->set_font_underline_mode( ip_font_underline_mode ).
    ENDIF.

    IF ip_fill_filltype IS SUPPLIED.
      changer->set_fill_filltype( ip_fill_filltype ).
    ENDIF.
    IF ip_fill_rotation IS SUPPLIED.
      changer->set_fill_rotation( ip_fill_rotation ).
    ENDIF.
    IF ip_fill_fgcolor IS SUPPLIED.
      changer->set_fill_fgcolor( ip_fill_fgcolor ).
    ENDIF.
    IF ip_fill_fgcolor_rgb IS SUPPLIED.
      changer->set_fill_fgcolor_rgb( ip_fill_fgcolor_rgb ).
    ENDIF.
    IF ip_fill_fgcolor_indexed IS SUPPLIED.
      changer->set_fill_fgcolor_indexed( ip_fill_fgcolor_indexed ).
    ENDIF.
    IF ip_fill_fgcolor_theme IS SUPPLIED.
      changer->set_fill_fgcolor_theme( ip_fill_fgcolor_theme ).
    ENDIF.
    IF ip_fill_fgcolor_tint IS SUPPLIED.
      changer->set_fill_fgcolor_tint( ip_fill_fgcolor_tint ).
    ENDIF.

    IF ip_fill_bgcolor IS SUPPLIED.
      changer->set_fill_bgcolor( ip_fill_bgcolor ).
    ENDIF.
    IF ip_fill_bgcolor_rgb IS SUPPLIED.
      changer->set_fill_bgcolor_rgb( ip_fill_bgcolor_rgb ).
    ENDIF.
    IF ip_fill_bgcolor_indexed IS SUPPLIED.
      changer->set_fill_bgcolor_indexed( ip_fill_bgcolor_indexed ).
    ENDIF.
    IF ip_fill_bgcolor_theme IS SUPPLIED.
      changer->set_fill_bgcolor_theme( ip_fill_bgcolor_theme ).
    ENDIF.
    IF ip_fill_bgcolor_tint IS SUPPLIED.
      changer->set_fill_bgcolor_tint( ip_fill_bgcolor_tint ).
    ENDIF.

    IF ip_fill_gradtype_type IS SUPPLIED.
      changer->set_fill_gradtype_type( ip_fill_gradtype_type ).
    ENDIF.
    IF ip_fill_gradtype_degree IS SUPPLIED.
      changer->set_fill_gradtype_degree( ip_fill_gradtype_degree ).
    ENDIF.
    IF ip_fill_gradtype_bottom IS SUPPLIED.
      changer->set_fill_gradtype_bottom( ip_fill_gradtype_bottom ).
    ENDIF.
    IF ip_fill_gradtype_left IS SUPPLIED.
      changer->set_fill_gradtype_left( ip_fill_gradtype_left ).
    ENDIF.
    IF ip_fill_gradtype_top IS SUPPLIED.
      changer->set_fill_gradtype_top( ip_fill_gradtype_top ).
    ENDIF.
    IF ip_fill_gradtype_right IS SUPPLIED.
      changer->set_fill_gradtype_right( ip_fill_gradtype_right ).
    ENDIF.
    IF ip_fill_gradtype_position1 IS SUPPLIED.
      changer->set_fill_gradtype_position1( ip_fill_gradtype_position1 ).
    ENDIF.
    IF ip_fill_gradtype_position2 IS SUPPLIED.
      changer->set_fill_gradtype_position2( ip_fill_gradtype_position2 ).
    ENDIF.
    IF ip_fill_gradtype_position3 IS SUPPLIED.
      changer->set_fill_gradtype_position3( ip_fill_gradtype_position3 ).
    ENDIF.



    IF ip_borders_diagonal_mode IS SUPPLIED.
      changer->set_borders_diagonal_mode( ip_borders_diagonal_mode ).
    ENDIF.
    IF ip_alignment_horizontal IS SUPPLIED.
      changer->set_alignment_horizontal( ip_alignment_horizontal ).
    ENDIF.
    IF ip_alignment_vertical IS SUPPLIED.
      changer->set_alignment_vertical( ip_alignment_vertical ).
    ENDIF.
    IF ip_alignment_textrotation IS SUPPLIED.
      changer->set_alignment_textrotation( ip_alignment_textrotation ).
    ENDIF.
    IF ip_alignment_wraptext IS SUPPLIED.
      changer->set_alignment_wraptext( ip_alignment_wraptext ).
    ENDIF.
    IF ip_alignment_shrinktofit IS SUPPLIED.
      changer->set_alignment_shrinktofit( ip_alignment_shrinktofit ).
    ENDIF.
    IF ip_alignment_indent IS SUPPLIED.
      changer->set_alignment_indent( ip_alignment_indent ).
    ENDIF.
    IF ip_protection_hidden IS SUPPLIED.
      changer->set_protection_hidden( ip_protection_hidden ).
    ENDIF.
    IF ip_protection_locked IS SUPPLIED.
      changer->set_protection_locked( ip_protection_locked ).
    ENDIF.

    IF ip_borders_allborders_style IS SUPPLIED.
      changer->set_borders_allborders_style( ip_borders_allborders_style ).
    ENDIF.
    IF ip_borders_allborders_color IS SUPPLIED.
      changer->set_borders_allborders_color( ip_borders_allborders_color ).
    ENDIF.
    IF ip_borders_allbo_color_rgb IS SUPPLIED.
      changer->set_borders_allbo_color_rgb( ip_borders_allbo_color_rgb ).
    ENDIF.
    IF ip_borders_allbo_color_indexed IS SUPPLIED.
      changer->set_borders_allbo_color_indexe( ip_borders_allbo_color_indexed ).
    ENDIF.
    IF ip_borders_allbo_color_theme IS SUPPLIED.
      changer->set_borders_allbo_color_theme( ip_borders_allbo_color_theme ).
    ENDIF.
    IF ip_borders_allbo_color_tint IS SUPPLIED.
      changer->set_borders_allbo_color_tint( ip_borders_allbo_color_tint ).
    ENDIF.

    IF ip_borders_diagonal_style IS SUPPLIED.
      changer->set_borders_diagonal_style( ip_borders_diagonal_style ).
    ENDIF.
    IF ip_borders_diagonal_color IS SUPPLIED.
      changer->set_borders_diagonal_color( ip_borders_diagonal_color ).
    ENDIF.
    IF ip_borders_diagonal_color_rgb IS SUPPLIED.
      changer->set_borders_diagonal_color_rgb( ip_borders_diagonal_color_rgb ).
    ENDIF.
    IF ip_borders_diagonal_color_inde IS SUPPLIED.
      changer->set_borders_diagonal_color_ind( ip_borders_diagonal_color_inde ).
    ENDIF.
    IF ip_borders_diagonal_color_them IS SUPPLIED.
      changer->set_borders_diagonal_color_the( ip_borders_diagonal_color_them ).
    ENDIF.
    IF ip_borders_diagonal_color_tint IS SUPPLIED.
      changer->set_borders_diagonal_color_tin( ip_borders_diagonal_color_tint ).
    ENDIF.

    IF ip_borders_down_style IS SUPPLIED.
      changer->set_borders_down_style( ip_borders_down_style ).
    ENDIF.
    IF ip_borders_down_color IS SUPPLIED.
      changer->set_borders_down_color( ip_borders_down_color ).
    ENDIF.
    IF ip_borders_down_color_rgb IS SUPPLIED.
      changer->set_borders_down_color_rgb( ip_borders_down_color_rgb ).
    ENDIF.
    IF ip_borders_down_color_indexed IS SUPPLIED.
      changer->set_borders_down_color_indexed( ip_borders_down_color_indexed ).
    ENDIF.
    IF ip_borders_down_color_theme IS SUPPLIED.
      changer->set_borders_down_color_theme( ip_borders_down_color_theme ).
    ENDIF.
    IF ip_borders_down_color_tint IS SUPPLIED.
      changer->set_borders_down_color_tint( ip_borders_down_color_tint ).
    ENDIF.

    IF ip_borders_left_style IS SUPPLIED.
      changer->set_borders_left_style( ip_borders_left_style ).
    ENDIF.
    IF ip_borders_left_color IS SUPPLIED.
      changer->set_borders_left_color( ip_borders_left_color ).
    ENDIF.
    IF ip_borders_left_color_rgb IS SUPPLIED.
      changer->set_borders_left_color_rgb( ip_borders_left_color_rgb ).
    ENDIF.
    IF ip_borders_left_color_indexed IS SUPPLIED.
      changer->set_borders_left_color_indexed( ip_borders_left_color_indexed ).
    ENDIF.
    IF ip_borders_left_color_theme IS SUPPLIED.
      changer->set_borders_left_color_theme( ip_borders_left_color_theme ).
    ENDIF.
    IF ip_borders_left_color_tint IS SUPPLIED.
      changer->set_borders_left_color_tint( ip_borders_left_color_tint ).
    ENDIF.

    IF ip_borders_right_style IS SUPPLIED.
      changer->set_borders_right_style( ip_borders_right_style ).
    ENDIF.
    IF ip_borders_right_color IS SUPPLIED.
      changer->set_borders_right_color( ip_borders_right_color ).
    ENDIF.
    IF ip_borders_right_color_rgb IS SUPPLIED.
      changer->set_borders_right_color_rgb( ip_borders_right_color_rgb ).
    ENDIF.
    IF ip_borders_right_color_indexed IS SUPPLIED.
      changer->set_borders_right_color_indexe( ip_borders_right_color_indexed ).
    ENDIF.
    IF ip_borders_right_color_theme IS SUPPLIED.
      changer->set_borders_right_color_theme( ip_borders_right_color_theme ).
    ENDIF.
    IF ip_borders_right_color_tint IS SUPPLIED.
      changer->set_borders_right_color_tint( ip_borders_right_color_tint ).
    ENDIF.

    IF ip_borders_top_style IS SUPPLIED.
      changer->set_borders_top_style( ip_borders_top_style ).
    ENDIF.
    IF ip_borders_top_color IS SUPPLIED.
      changer->set_borders_top_color( ip_borders_top_color ).
    ENDIF.
    IF ip_borders_top_color_rgb IS SUPPLIED.
      changer->set_borders_top_color_rgb( ip_borders_top_color_rgb ).
    ENDIF.
    IF ip_borders_top_color_indexed IS SUPPLIED.
      changer->set_borders_top_color_indexed( ip_borders_top_color_indexed ).
    ENDIF.
    IF ip_borders_top_color_theme IS SUPPLIED.
      changer->set_borders_top_color_theme( ip_borders_top_color_theme ).
    ENDIF.
    IF ip_borders_top_color_tint IS SUPPLIED.
      changer->set_borders_top_color_tint( ip_borders_top_color_tint ).
    ENDIF.


    ep_guid = changer->apply( ip_worksheet = me
                              ip_column    = column
                              ip_row       = row ).


  ENDMETHOD.                    "CHANGE_CELL_STYLE
  METHOD check_cell_column_formula.

    FIELD-SYMBOLS <fs_column_formula> TYPE Lcl_excel_worksheet=>mty_s_column_formula.

    IF ip_value IS NOT INITIAL OR ip_formula IS NOT INITIAL.
      Lcx_excel=>raise_text( c_messages-formula_id_only_is_possible ).
    ENDIF.
    READ TABLE it_column_formulas WITH TABLE KEY id = ip_column_formula_id ASSIGNING <fs_column_formula>.
    IF sy-subrc <> 0.
      Lcx_excel=>raise_text( c_messages-column_formula_id_not_found ).
    ENDIF.
    IF ip_row < <fs_column_formula>-table_top_left_row + 1
          OR ip_row > <fs_column_formula>-table_bottom_right_row + 1
          OR ip_column < <fs_column_formula>-table_left_column_int
          OR ip_column > <fs_column_formula>-table_right_column_int.
      Lcx_excel=>raise_text( c_messages-formula_not_in_this_table ).
    ENDIF.
    IF ip_column <> <fs_column_formula>-column.
      Lcx_excel=>raise_text( c_messages-formula_in_other_column ).
    ENDIF.

  ENDMETHOD.
  METHOD check_rtf.

    DATA: lo_style           TYPE REF TO Lcl_excel_style,
          lo_iterator        TYPE REF TO Lcl_excel_collection_iterator,
          lv_next_rtf_offset TYPE i,
          lv_tabix           TYPE i,
          lv_value           TYPE string,
          lv_val_length      TYPE i,
          ls_rtf             LIKE LINE OF ct_rtf.
    FIELD-SYMBOLS: <rtf> LIKE LINE OF ct_rtf.

    IF ip_style IS NOT SUPPLIED.
      ip_style = excel->get_default_style( ).
    ENDIF.

    lo_iterator = excel->get_styles_iterator( ).
    WHILE lo_iterator->has_next( ) = abap_true.
      lo_style ?= lo_iterator->get_next( ).
      IF lo_style->get_guid( ) = ip_style.
        EXIT.
      ENDIF.
      CLEAR lo_style.
    ENDWHILE.

    lv_next_rtf_offset = 0.
    LOOP AT ct_rtf ASSIGNING <rtf>.
      lv_tabix = sy-tabix.
      IF lv_next_rtf_offset < <rtf>-offset.
        ls_rtf-offset = lv_next_rtf_offset.
        ls_rtf-length = <rtf>-offset - lv_next_rtf_offset.
        ls_rtf-font   = lo_style->font->get_structure( ).
        INSERT ls_rtf INTO ct_rtf INDEX lv_tabix.
      ELSEIF lv_next_rtf_offset > <rtf>-offset.
        RAISE EXCEPTION TYPE Lcx_excel
          EXPORTING
            error = 'Gaps or overlaps in RTF data offset/length specs'.
      ENDIF.
      lv_next_rtf_offset = <rtf>-offset + <rtf>-length.
    ENDLOOP.

    lv_value = ip_value.
    lv_val_length = strlen( lv_value ).
    IF lv_val_length > lv_next_rtf_offset.
      ls_rtf-offset = lv_next_rtf_offset.
      ls_rtf-length = lv_val_length - lv_next_rtf_offset.
      ls_rtf-font   = lo_style->font->get_structure( ).
      INSERT ls_rtf INTO TABLE ct_rtf.
    ELSEIF lv_val_length > lv_next_rtf_offset.
      RAISE EXCEPTION TYPE Lcx_excel
        EXPORTING
          error = 'RTF specs length is not equal to value length'.
    ENDIF.

  ENDMETHOD.
  METHOD check_table_overlapping.

    DATA: lv_errormessage TYPE string,
          lv_column_int   TYPE zexcel_cell_column,
          lv_maxcol       TYPE i.
    FIELD-SYMBOLS:
          <ls_table_settings> TYPE zexcel_s_table_settings.

    lv_column_int = Lcl_excel_common=>convert_column2int( is_table_settings-top_left_column ).
    lv_maxcol = Lcl_excel_common=>convert_column2int( is_table_settings-bottom_right_column ).

    LOOP AT it_other_table_settings ASSIGNING <ls_table_settings>.

      IF  (    (  is_table_settings-top_left_row     GE <ls_table_settings>-top_left_row
              AND is_table_settings-top_left_row     LE <ls_table_settings>-bottom_right_row )
            OR
               (  is_table_settings-bottom_right_row GE <ls_table_settings>-top_left_row
              AND is_table_settings-bottom_right_row LE <ls_table_settings>-bottom_right_row )
          )
        AND
          (    (  lv_column_int GE Lcl_excel_common=>convert_column2int( <ls_table_settings>-top_left_column )
              AND lv_column_int LE Lcl_excel_common=>convert_column2int( <ls_table_settings>-bottom_right_column ) )
            OR
               (  lv_maxcol     GE Lcl_excel_common=>convert_column2int( <ls_table_settings>-top_left_column )
              AND lv_maxcol     LE Lcl_excel_common=>convert_column2int( <ls_table_settings>-bottom_right_column ) )
          ).
        lv_errormessage = 'Table overlaps with previously bound table and will not be added to worksheet.'(400).
        Lcx_excel=>raise_text( lv_errormessage ).
      ENDIF.

    ENDLOOP.

  ENDMETHOD.
  METHOD class_constructor.

    c_messages-formula_id_only_is_possible = |{ 'If Formula ID is used, value and formula must be empty'(008) }|.
    c_messages-column_formula_id_not_found = |{ 'The Column Formula does not exist'(009) }|.
    c_messages-formula_not_in_this_table = |{ 'The cell uses a Column Formula which should be part of the same table'(010) }|.
    c_messages-formula_in_other_column = |{ 'The cell uses a Column Formula which is in a different column'(011) }|.

  ENDMETHOD.
  METHOD clear_initial_colorxfields.

    IF is_color-rgb IS INITIAL.
      CLEAR cs_xcolor-rgb.
    ENDIF.
    IF is_color-indexed IS INITIAL.
      CLEAR cs_xcolor-indexed.
    ENDIF.
    IF is_color-theme IS INITIAL.
      CLEAR cs_xcolor-theme.
    ENDIF.
    IF is_color-tint IS INITIAL.
      CLEAR cs_xcolor-tint.
    ENDIF.

  ENDMETHOD.
  METHOD constructor.
    DATA: lv_title TYPE zexcel_sheet_title.

    me->excel = ip_excel.

    me->guid = Lcl_excel_obsolete_func_wrap=>guid_create( ).        " ins issue #379 - replacement for outdated function call

    IF ip_title IS NOT INITIAL.
      lv_title = ip_title.
    ELSE.
      lv_title = me->generate_title( ). " ins issue #154 - Names of worksheets
    ENDIF.

    me->set_title( ip_title = lv_title ).

    CREATE OBJECT sheet_setup.
    CREATE OBJECT styles_cond.
    CREATE OBJECT data_validations.
    CREATE OBJECT tables.
    CREATE OBJECT columns.
    CREATE OBJECT rows.
    CREATE OBJECT ranges. " issue #163
    CREATE OBJECT mo_pagebreaks.
    CREATE OBJECT drawings
      EXPORTING
        ip_type = Lcl_excel_drawing=>type_image.
    CREATE OBJECT charts
      EXPORTING
        ip_type = Lcl_excel_drawing=>type_chart.
    me->Lif_excel_sheet_protection~initialize( ).
    me->Lif_excel_sheet_properties~initialize( ).
    CREATE OBJECT hyperlinks.
    CREATE OBJECT comments. " (+) Issue #180

* initialize active cell coordinates
    active_cell-cell_row = 1.
    active_cell-cell_column = 1.

* inizialize dimension range
    lower_cell-cell_row     = 1.
    lower_cell-cell_column  = 1.
    upper_cell-cell_row     = 1.
    upper_cell-cell_column  = 1.

  ENDMETHOD.                    "CONSTRUCTOR
  METHOD create_data_conv_exit_length.
    DATA: lo_addit    TYPE REF TO cl_abap_elemdescr,
          ls_dfies    TYPE dfies,
          l_function  TYPE funcname,
          l_value(50) TYPE c.

    lo_addit ?= cl_abap_typedescr=>describe_by_data( ip_value ).
    lo_addit->get_ddic_field( RECEIVING  p_flddescr   = ls_dfies
                              EXCEPTIONS not_found    = 1
                                         no_ddic_type = 2
                                         OTHERS       = 3 ) .
    IF sy-subrc = 0 AND ls_dfies-convexit IS NOT INITIAL.
      CREATE DATA ep_value TYPE c LENGTH ls_dfies-outputlen.
    ELSE.
      CREATE DATA ep_value LIKE ip_value.
    ENDIF.

  ENDMETHOD.
  METHOD delete_merge.

    DATA: lv_column TYPE i.
*--------------------------------------------------------------------*
* If cell information is passed delete merge including this cell,
* otherwise delete all merges
*--------------------------------------------------------------------*
    IF   ip_cell_column IS INITIAL
      OR ip_cell_row    IS INITIAL.
      CLEAR me->mt_merged_cells.
    ELSE.
      lv_column = Lcl_excel_common=>convert_column2int( ip_cell_column ).

      LOOP AT me->mt_merged_cells TRANSPORTING NO FIELDS
      WHERE row_from <= ip_cell_row AND row_to >= ip_cell_row
        AND col_from <= lv_column AND col_to >= lv_column.
        DELETE me->mt_merged_cells.
        EXIT.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    "DELETE_MERGE
  METHOD delete_row_outline.

    DELETE me->mt_row_outlines WHERE row_from = iv_row_from
                                 AND row_to   = iv_row_to.
    IF sy-subrc <> 0.  " didn't find outline that was to be deleted
      Lcx_excel=>raise_text( 'Row outline to be deleted does not exist' ).
    ENDIF.

  ENDMETHOD.                    "DELETE_ROW_OUTLINE
  METHOD freeze_panes.

    IF ip_num_columns IS NOT SUPPLIED AND ip_num_rows IS NOT SUPPLIED.
      Lcx_excel=>raise_text( 'Pleas provide number of rows and/or columns to freeze' ).
    ENDIF.

    IF ip_num_columns IS SUPPLIED AND ip_num_columns <= 0.
      Lcx_excel=>raise_text( 'Number of columns to freeze should be positive' ).
    ENDIF.

    IF ip_num_rows IS SUPPLIED AND ip_num_rows <= 0.
      Lcx_excel=>raise_text( 'Number of rows to freeze should be positive' ).
    ENDIF.

    freeze_pane_cell_column = ip_num_columns + 1.
    freeze_pane_cell_row = ip_num_rows + 1.
  ENDMETHOD.                    "FREEZE_PANES
  METHOD generate_title.
    DATA: lo_worksheets_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_worksheet           TYPE REF TO Lcl_excel_worksheet.

    DATA: t_titles    TYPE HASHED TABLE OF zexcel_sheet_title WITH UNIQUE KEY table_line,
          title       TYPE zexcel_sheet_title,
          sheetnumber TYPE i.

* Get list of currently used titles
    lo_worksheets_iterator = me->excel->get_worksheets_iterator( ).
    WHILE lo_worksheets_iterator->has_next( ) = abap_true.
      lo_worksheet ?= lo_worksheets_iterator->get_next( ).
      title = lo_worksheet->get_title( ).
      INSERT title INTO TABLE t_titles.
      ADD 1 TO sheetnumber.
    ENDWHILE.

* Now build sheetnumber.  Increase counter until we hit a number that is not used so far
    ADD 1 TO sheetnumber.  " Start counting with next number
    DO.
      title = sheetnumber.
      SHIFT title LEFT DELETING LEADING space.
      CONCATENATE 'Sheet'(001) title INTO ep_title.
      INSERT ep_title INTO TABLE t_titles.
      IF sy-subrc = 0.  " Title not used so far --> take it
        EXIT.
      ENDIF.

      ADD 1 TO sheetnumber.
    ENDDO.
  ENDMETHOD.                    "GENERATE_TITLE
  METHOD get_active_cell.

    DATA: lv_active_column TYPE zexcel_cell_column_alpha,
          lv_active_row    TYPE string.

    lv_active_column = Lcl_excel_common=>convert_column2alpha( active_cell-cell_column ).
    lv_active_row    = active_cell-cell_row.
    SHIFT lv_active_row RIGHT DELETING TRAILING space.
    SHIFT lv_active_row LEFT DELETING LEADING space.
    CONCATENATE lv_active_column lv_active_row INTO ep_active_cell.

  ENDMETHOD.                    "GET_ACTIVE_CELL
  METHOD get_cell.

    DATA: lv_column        TYPE zexcel_cell_column,
          lv_row           TYPE zexcel_cell_row,
          ls_sheet_content TYPE zexcel_s_cell_data.

    normalize_columnrow_parameter( EXPORTING ip_columnrow = ip_columnrow
                                             ip_column    = ip_column
                                             ip_row       = ip_row
                                   IMPORTING ep_column    = lv_column
                                             ep_row       = lv_row ).

    READ TABLE sheet_content INTO ls_sheet_content WITH TABLE KEY cell_row     = lv_row
                                                                  cell_column  = lv_column.

    ep_rc       = sy-subrc.
    ep_value    = ls_sheet_content-cell_value.
    ep_guid     = ls_sheet_content-cell_style.       " issue 139 - added this to be used for columnwidth calculation
    ep_formula  = ls_sheet_content-cell_formula.
    IF et_rtf IS SUPPLIED AND ls_sheet_content-rtf_tab IS NOT INITIAL.
      et_rtf = ls_sheet_content-rtf_tab.
    ENDIF.

    " Addition to solve issue #120, contribution by Stefan Schmöcker
    DATA: style_iterator TYPE REF TO Lcl_excel_collection_iterator,
          style          TYPE REF TO Lcl_excel_style.
    IF ep_style IS SUPPLIED.
      CLEAR ep_style.
      style_iterator = me->excel->get_styles_iterator( ).
      WHILE style_iterator->has_next( ) = abap_true.
        style ?= style_iterator->get_next( ).
        IF style->get_guid( ) = ls_sheet_content-cell_style.
          ep_style = style.
          EXIT.
        ENDIF.
      ENDWHILE.
    ENDIF.
  ENDMETHOD.                    "GET_CELL
  METHOD get_column.

    DATA: lv_column TYPE zexcel_cell_column.

    lv_column = Lcl_excel_common=>convert_column2int( ip_column ).

    eo_column = me->columns->get( ip_index = lv_column ).

    IF eo_column IS NOT BOUND.
      eo_column = me->add_new_column( ip_column ).
    ENDIF.

  ENDMETHOD.                    "GET_COLUMN
  METHOD get_columns.

    DATA: columns TYPE TABLE OF i,
          column  TYPE i.
    FIELD-SYMBOLS:
          <sheet_cell> TYPE zexcel_s_cell_data.

    LOOP AT sheet_content ASSIGNING <sheet_cell>.
      COLLECT <sheet_cell>-cell_column INTO columns.
    ENDLOOP.

    LOOP AT columns INTO column.
      " This will create the column instance if it doesn't exist
      get_column( column ).
    ENDLOOP.

    eo_columns = me->columns.
  ENDMETHOD.                    "GET_COLUMNS
  METHOD get_columns_iterator.

    get_columns( ).
    eo_iterator = me->columns->get_iterator( ).

  ENDMETHOD.                    "GET_COLUMNS_ITERATOR
  METHOD get_comments.
    DATA: lo_comment  TYPE REF TO Lcl_excel_comment,
          lo_iterator TYPE REF TO Lcl_excel_collection_iterator.

    CREATE OBJECT r_comments.

    lo_iterator = comments->get_iterator( ).
    WHILE lo_iterator->has_next( ) = abap_true.
      lo_comment ?= lo_iterator->get_next( ).
      r_comments->include( lo_comment ).
    ENDWHILE.

  ENDMETHOD.                    "get_comments
  METHOD get_comments_iterator.
    eo_iterator = comments->get_iterator( ).

  ENDMETHOD.                    "get_comments_iterator
  METHOD get_data_validations_iterator.

    eo_iterator = me->data_validations->get_iterator( ).
  ENDMETHOD.                    "GET_DATA_VALIDATIONS_ITERATOR
  METHOD get_data_validations_size.
    ep_size = me->data_validations->size( ).
  ENDMETHOD.                    "GET_DATA_VALIDATIONS_SIZE
  METHOD get_default_column.
    IF me->column_default IS NOT BOUND.
      CREATE OBJECT me->column_default
        EXPORTING
          ip_index     = 'A'         " ????
          ip_worksheet = me
          ip_excel     = me->excel.
    ENDIF.

    eo_column = me->column_default.
  ENDMETHOD.                    "GET_DEFAULT_COLUMN
  METHOD get_default_excel_date_format.
    CONSTANTS: c_lang_e TYPE lang VALUE 'E'.

    IF default_excel_date_format IS NOT INITIAL.
      ep_default_excel_date_format = default_excel_date_format.
      RETURN.
    ENDIF.

    "try to get defaults
    TRY.
        cl_abap_datfm=>get_date_format_des( EXPORTING im_langu = c_lang_e
                                            IMPORTING ex_dateformat = default_excel_date_format ).
      CATCH cx_abap_datfm_format_unknown.

    ENDTRY.

    " and fallback to fixed format
    IF default_excel_date_format IS INITIAL.
      default_excel_date_format = Lcl_excel_style_number_format=>c_format_date_ddmmyyyydot.
    ENDIF.

    ep_default_excel_date_format = default_excel_date_format.
  ENDMETHOD.                    "GET_DEFAULT_EXCEL_DATE_FORMAT
  METHOD get_default_excel_time_format.
    DATA: l_timefm TYPE xutimefm.

    IF default_excel_time_format IS NOT INITIAL.
      ep_default_excel_time_format = default_excel_time_format.
      RETURN.
    ENDIF.

* Let's get default
    l_timefm = cl_abap_timefm=>get_environment_timefm( ).
    CASE l_timefm.
      WHEN 0.
*0  24 Hour Format (Example: 12:05:10)
        default_excel_time_format = Lcl_excel_style_number_format=>c_format_date_time6.
      WHEN 1.
*1  12 Hour Format (Example: 12:05:10 PM)
        default_excel_time_format = Lcl_excel_style_number_format=>c_format_date_time2.
      WHEN 2.
*2  12 Hour Format (Example: 12:05:10 pm) for now all the same. no chnage upper lower
        default_excel_time_format = Lcl_excel_style_number_format=>c_format_date_time2.
      WHEN 3.
*3  Hours from 0 to 11 (Example: 00:05:10 PM)  for now all the same. no chnage upper lower
        default_excel_time_format = Lcl_excel_style_number_format=>c_format_date_time2.
      WHEN 4.
*4  Hours from 0 to 11 (Example: 00:05:10 pm)  for now all the same. no chnage upper lower
        default_excel_time_format = Lcl_excel_style_number_format=>c_format_date_time2.
      WHEN OTHERS.
        " and fallback to fixed format
        default_excel_time_format = Lcl_excel_style_number_format=>c_format_date_time6.
    ENDCASE.

    ep_default_excel_time_format = default_excel_time_format.
  ENDMETHOD.                    "GET_DEFAULT_EXCEL_TIME_FORMAT
  METHOD get_default_row.
    IF me->row_default IS NOT BOUND.
      CREATE OBJECT me->row_default.
    ENDIF.

    eo_row = me->row_default.
  ENDMETHOD.                    "GET_DEFAULT_ROW
  METHOD get_dimension_range.

    me->update_dimension_range( ).
    IF upper_cell EQ lower_cell. "only one cell
      " Worksheet not filled
      IF upper_cell-cell_coords IS INITIAL.
        ep_dimension_range = 'A1'.
      ELSE.
        ep_dimension_range = upper_cell-cell_coords.
      ENDIF.
    ELSE.
      CONCATENATE upper_cell-cell_coords ':' lower_cell-cell_coords INTO ep_dimension_range.
    ENDIF.

  ENDMETHOD.                    "GET_DIMENSION_RANGE
  METHOD get_drawings.

    DATA: lo_drawing  TYPE REF TO Lcl_excel_drawing,
          lo_iterator TYPE REF TO Lcl_excel_collection_iterator.

    CASE ip_type.
      WHEN Lcl_excel_drawing=>type_image.
        r_drawings = drawings.
      WHEN Lcl_excel_drawing=>type_chart.
        r_drawings = charts.
      WHEN space.
        CREATE OBJECT r_drawings
          EXPORTING
            ip_type = ''.

        lo_iterator = drawings->get_iterator( ).
        WHILE lo_iterator->has_next( ) = abap_true.
          lo_drawing ?= lo_iterator->get_next( ).
          r_drawings->include( lo_drawing ).
        ENDWHILE.
        lo_iterator = charts->get_iterator( ).
        WHILE lo_iterator->has_next( ) = abap_true.
          lo_drawing ?= lo_iterator->get_next( ).
          r_drawings->include( lo_drawing ).
        ENDWHILE.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.                    "GET_DRAWINGS
  METHOD get_drawings_iterator.
    CASE ip_type.
      WHEN Lcl_excel_drawing=>type_image.
        eo_iterator = drawings->get_iterator( ).
      WHEN Lcl_excel_drawing=>type_chart.
        eo_iterator = charts->get_iterator( ).
    ENDCASE.
  ENDMETHOD.                    "GET_DRAWINGS_ITERATOR
  METHOD get_freeze_cell.
    ep_row = me->freeze_pane_cell_row.
    ep_column = me->freeze_pane_cell_column.
  ENDMETHOD.                    "GET_FREEZE_CELL
  METHOD get_guid.

    ep_guid = me->guid.

  ENDMETHOD.                    "GET_GUID
  METHOD get_header_footer_drawings.
    DATA: ls_odd_header  TYPE zexcel_s_worksheet_head_foot,
          ls_odd_footer  TYPE zexcel_s_worksheet_head_foot,
          ls_even_header TYPE zexcel_s_worksheet_head_foot,
          ls_even_footer TYPE zexcel_s_worksheet_head_foot,
          ls_hd_ft       TYPE zexcel_s_worksheet_head_foot.

    FIELD-SYMBOLS: <fs_drawings> TYPE zexcel_s_drawings.

    me->sheet_setup->get_header_footer( IMPORTING ep_odd_header = ls_odd_header
                                                  ep_odd_footer = ls_odd_footer
                                                  ep_even_header = ls_even_header
                                                  ep_even_footer = ls_even_footer ).

**********************************************************************
*** Odd header
    ls_hd_ft = ls_odd_header.
    IF ls_hd_ft-left_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-left_image.
    ENDIF.
    IF ls_hd_ft-right_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-right_image.
    ENDIF.
    IF ls_hd_ft-center_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-center_image.
    ENDIF.

**********************************************************************
*** Odd footer
    ls_hd_ft = ls_odd_footer.
    IF ls_hd_ft-left_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-left_image.
    ENDIF.
    IF ls_hd_ft-right_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-right_image.
    ENDIF.
    IF ls_hd_ft-center_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-center_image.
    ENDIF.

**********************************************************************
*** Even header
    ls_hd_ft = ls_even_header.
    IF ls_hd_ft-left_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-left_image.
    ENDIF.
    IF ls_hd_ft-right_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-right_image.
    ENDIF.
    IF ls_hd_ft-center_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-center_image.
    ENDIF.

**********************************************************************
*** Even footer
    ls_hd_ft = ls_even_footer.
    IF ls_hd_ft-left_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-left_image.
    ENDIF.
    IF ls_hd_ft-right_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-right_image.
    ENDIF.
    IF ls_hd_ft-center_image IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_drawings ASSIGNING <fs_drawings>.
      <fs_drawings>-drawing = ls_hd_ft-center_image.
    ENDIF.

  ENDMETHOD.                    "get_header_footer_drawings
  METHOD get_highest_column.
    me->update_dimension_range( ).
    r_highest_column = me->lower_cell-cell_column.
  ENDMETHOD.                    "GET_HIGHEST_COLUMN
  METHOD get_highest_row.
    me->update_dimension_range( ).
    r_highest_row = me->lower_cell-cell_row.
  ENDMETHOD.                    "GET_HIGHEST_ROW
  METHOD get_hyperlinks_iterator.
    eo_iterator = hyperlinks->get_iterator( ).
  ENDMETHOD.                    "GET_HYPERLINKS_ITERATOR
  METHOD get_hyperlinks_size.
    ep_size = hyperlinks->size( ).
  ENDMETHOD.                    "GET_HYPERLINKS_SIZE
  METHOD get_ignored_errors.
    rt_ignored_errors = mt_ignored_errors.
  ENDMETHOD.
  METHOD get_merge.

    FIELD-SYMBOLS: <ls_merged_cell> LIKE LINE OF me->mt_merged_cells.

    DATA: lv_col_from    TYPE string,
          lv_col_to      TYPE string,
          lv_row_from    TYPE string,
          lv_row_to      TYPE string,
          lv_merge_range TYPE string.

    LOOP AT me->mt_merged_cells ASSIGNING <ls_merged_cell>.

      lv_col_from = Lcl_excel_common=>convert_column2alpha( <ls_merged_cell>-col_from ).
      lv_col_to   = Lcl_excel_common=>convert_column2alpha( <ls_merged_cell>-col_to   ).
      lv_row_from = <ls_merged_cell>-row_from.
      lv_row_to   = <ls_merged_cell>-row_to  .
      CONCATENATE lv_col_from lv_row_from ':' lv_col_to lv_row_to
         INTO lv_merge_range.
      CONDENSE lv_merge_range NO-GAPS.
      APPEND lv_merge_range TO merge_range.

    ENDLOOP.

  ENDMETHOD.                    "GET_MERGE
  METHOD get_pagebreaks.
    ro_pagebreaks = mo_pagebreaks.
  ENDMETHOD.                    "GET_PAGEBREAKS
  METHOD get_ranges_iterator.

    eo_iterator = me->ranges->get_iterator( ).

  ENDMETHOD.                    "GET_RANGES_ITERATOR
  METHOD get_row.
    eo_row = me->rows->get( ip_index = ip_row ).

    IF eo_row IS NOT BOUND.
      eo_row = me->add_new_row( ip_row ).
    ENDIF.
  ENDMETHOD.                    "GET_ROW
  METHOD get_rows.

    DATA: row TYPE i.
    FIELD-SYMBOLS: <sheet_cell> TYPE zexcel_s_cell_data.

    IF sheet_content IS NOT INITIAL.

      row = 0.
      DO.
        " Find the next row
        READ TABLE sheet_content ASSIGNING <sheet_cell> WITH KEY cell_row = row.
        CASE sy-subrc.
          WHEN 4.
            " row doesn't exist, but it exists another row, SY-TABIX points to the first cell in this row.
            READ TABLE sheet_content ASSIGNING <sheet_cell> INDEX sy-tabix.
            ASSERT sy-subrc = 0.
            row = <sheet_cell>-cell_row.
          WHEN 8.
            " it was the last available row
            EXIT.
        ENDCASE.
        " This will create the row instance if it doesn't exist
        get_row( row ).
        row = row + 1.
      ENDDO.

    ENDIF.

    eo_rows = me->rows.
  ENDMETHOD.                    "GET_ROWS
  METHOD get_rows_iterator.

    get_rows( ).
    eo_iterator = me->rows->get_iterator( ).

  ENDMETHOD.                    "GET_ROWS_ITERATOR
  METHOD get_row_outlines.

    rt_row_outlines = me->mt_row_outlines.

  ENDMETHOD.                    "GET_ROW_OUTLINES
  METHOD get_style_cond.

    DATA: lo_style_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_style_cond     TYPE REF TO Lcl_excel_style_cond.

    lo_style_iterator = me->get_style_cond_iterator( ).
    WHILE lo_style_iterator->has_next( ) = abap_true.
      lo_style_cond ?= lo_style_iterator->get_next( ).
      IF lo_style_cond->get_guid( ) = ip_guid.
        eo_style_cond = lo_style_cond.
        EXIT.
      ENDIF.
    ENDWHILE.

  ENDMETHOD.                    "GET_STYLE_COND
  METHOD get_style_cond_iterator.

    eo_iterator = styles_cond->get_iterator( ).
  ENDMETHOD.                    "GET_STYLE_COND_ITERATOR
  METHOD get_tabcolor.
    ev_tabcolor = me->tabcolor.
  ENDMETHOD.                    "GET_TABCOLOR
  METHOD get_table.
*--------------------------------------------------------------------*
* Comment D. Rauchenstein
* With this method, we get a fully functional Excel Upload, which solves
* a few issues of the other excel upload tools
* ZBCABA_ALSM_EXCEL_UPLOAD_EXT: Reads only up to 50 signs per Cell, Limit
* in row-Numbers. Other have Limitations of Lines, or you are not able
* to ignore filters or choosing the right tab.
*
* To get a fully functional XLSX Upload, you can use it e.g. with method
* CL_EXCEL_READER_2007->LIF_EXCEL_READER~LOAD_FILE()
*--------------------------------------------------------------------*

    FIELD-SYMBOLS: <ls_line> TYPE data.
    FIELD-SYMBOLS: <lv_value> TYPE data.

    DATA lv_actual_row TYPE int4.
    DATA lv_actual_row_string TYPE string.
    DATA lv_actual_col TYPE int4.
    DATA lv_actual_col_string TYPE string.
    DATA lv_errormessage TYPE string.
    DATA lv_max_col TYPE zexcel_cell_column.
    DATA lv_max_row TYPE int4.
    DATA lv_delta_col TYPE int4.
    DATA lv_value  TYPE zexcel_cell_value.
    DATA lv_rc  TYPE sysubrc.
    DATA lx_conversion_error TYPE REF TO cx_sy_conversion_error.
    DATA lv_float TYPE f.
    DATA lv_type.
    DATA lv_tabix TYPE i.

    lv_max_col =  me->get_highest_column( ).
    IF iv_max_col IS SUPPLIED AND iv_max_col < lv_max_col.
      lv_max_col = iv_max_col.
    ENDIF.
    lv_max_row =  me->get_highest_row( ).
    IF iv_max_row IS SUPPLIED AND iv_max_row < lv_max_row.
      lv_max_row = iv_max_row.
    ENDIF.

*--------------------------------------------------------------------*
* The row counter begins with 1 and should be corrected with the skips
*--------------------------------------------------------------------*
    lv_actual_row =  iv_skipped_rows + 1.
    lv_actual_col =  iv_skipped_cols + 1.


    TRY.
*--------------------------------------------------------------------*
* Check if we the basic features are possible with given "any table"
*--------------------------------------------------------------------*
        APPEND INITIAL LINE TO et_table ASSIGNING <ls_line>.
        IF sy-subrc <> 0 OR <ls_line> IS NOT ASSIGNED.

          lv_errormessage = 'Error at inserting new Line to internal Table'(002).
          Lcx_excel=>raise_text( lv_errormessage ).

        ELSE.
          lv_delta_col = lv_max_col - iv_skipped_cols.
          ASSIGN COMPONENT lv_delta_col OF STRUCTURE <ls_line> TO <lv_value>.
          IF sy-subrc <> 0 OR <lv_value> IS NOT ASSIGNED.
            lv_errormessage = 'Internal table has less columns than excel'(003).
            Lcx_excel=>raise_text( lv_errormessage ).
          ELSE.
*--------------------------------------------------------------------*
*now we are ready for handle the table data
*--------------------------------------------------------------------*
            CLEAR et_table.
*--------------------------------------------------------------------*
* Handle each Row until end on right side
*--------------------------------------------------------------------*
            WHILE lv_actual_row <= lv_max_row .

*--------------------------------------------------------------------*
* Handle each Column until end on bottom
* First step is to step back on first column
*--------------------------------------------------------------------*
              lv_actual_col =  iv_skipped_cols + 1.

              UNASSIGN <ls_line>.
              APPEND INITIAL LINE TO et_table ASSIGNING <ls_line>.
              IF sy-subrc <> 0 OR <ls_line> IS NOT ASSIGNED.
                lv_errormessage = 'Error at inserting new Line to internal Table'(002).
                Lcx_excel=>raise_text( lv_errormessage ).
              ENDIF.
              WHILE lv_actual_col <= lv_max_col.

                lv_delta_col = lv_actual_col - iv_skipped_cols.
                ASSIGN COMPONENT lv_delta_col OF STRUCTURE <ls_line> TO <lv_value>.
                IF sy-subrc <> 0.
                  lv_actual_col_string = lv_actual_col.
                  lv_actual_row_string = lv_actual_row.
                  CONCATENATE 'Error at assigning field (Col:'(004) lv_actual_col_string ' Row:'(005) lv_actual_row_string INTO lv_errormessage.
                  Lcx_excel=>raise_text( lv_errormessage ).
                ENDIF.

                me->get_cell(
                  EXPORTING
                    ip_column  = lv_actual_col    " Cell Column
                    ip_row     = lv_actual_row    " Cell Row
                  IMPORTING
                    ep_value   = lv_value    " Cell Value
                    ep_rc      = lv_rc    " Return Value of ABAP Statements
                ).
                IF lv_rc <> 0
                  AND lv_rc <> 4                                                   "No found error means, zero/no value in cell
                  AND lv_rc <> 8. "rc is 8 when the last row contains cells with zero / no values
                  lv_actual_col_string = lv_actual_col.
                  lv_actual_row_string = lv_actual_row.
                  CONCATENATE 'Error at reading field value (Col:'(007) lv_actual_col_string ' Row:'(005) lv_actual_row_string INTO lv_errormessage.
                  Lcx_excel=>raise_text( lv_errormessage ).
                ENDIF.

                TRY.
                    DESCRIBE FIELD <lv_value> TYPE lv_type.
                    IF lv_type = 'D'.
                      <lv_value> = Lcl_excel_common=>excel_string_to_date( ip_value = lv_value ).
                    ELSE.
                      <lv_value> = lv_value. "Will raise exception if data type of <lv_value> is not float (or decfloat16/34) and excel delivers exponential number e.g. -2.9398924194538267E-2
                    ENDIF.
                  CATCH cx_sy_conversion_error INTO lx_conversion_error.
                    "Another try with conversion to float...
                    IF lv_type = 'P'.
                      <lv_value> = lv_float = lv_value.
                    ELSE.
                      RAISE EXCEPTION lx_conversion_error. "Pass on original exception
                    ENDIF.
                ENDTRY.

*  CATCH Lcx_excel.    "
                ADD 1 TO lv_actual_col.
              ENDWHILE.
              ADD 1 TO lv_actual_row.
            ENDWHILE.

            IF iv_skip_bottom_empty_rows = abap_true.
              lv_tabix = lines( et_table ).
              WHILE lv_tabix >= 1.
                READ TABLE et_table INDEX lv_tabix ASSIGNING <ls_line>.
                ASSERT sy-subrc = 0.
                IF <ls_line> IS NOT INITIAL.
                  EXIT.
                ENDIF.
                DELETE et_table INDEX lv_tabix.
                lv_tabix = lv_tabix - 1.
              ENDWHILE.
            ENDIF.

          ENDIF.


        ENDIF.

      CATCH cx_sy_assign_cast_illegal_cast.
        lv_actual_col_string = lv_actual_col.
        lv_actual_row_string = lv_actual_row.
        CONCATENATE 'Error at assigning field (Col:'(004) lv_actual_col_string ' Row:'(005) lv_actual_row_string INTO lv_errormessage.
        Lcx_excel=>raise_text( lv_errormessage ).
      CATCH cx_sy_assign_cast_unknown_type.
        lv_actual_col_string = lv_actual_col.
        lv_actual_row_string = lv_actual_row.
        CONCATENATE 'Error at assigning field (Col:'(004) lv_actual_col_string ' Row:'(005) lv_actual_row_string INTO lv_errormessage.
        Lcx_excel=>raise_text( lv_errormessage ).
      CATCH cx_sy_assign_out_of_range.
        lv_errormessage = 'Internal table has less columns than excel'(003).
        Lcx_excel=>raise_text( lv_errormessage ).
      CATCH cx_sy_conversion_error.
        lv_actual_col_string = lv_actual_col.
        lv_actual_row_string = lv_actual_row.
        CONCATENATE 'Error at converting field value (Col:'(006) lv_actual_col_string ' Row:'(005) lv_actual_row_string INTO lv_errormessage.
        Lcx_excel=>raise_text( lv_errormessage ).

    ENDTRY.
  ENDMETHOD.                    "get_table
  METHOD get_tables_iterator.
    eo_iterator = tables->get_iterator( ).
  ENDMETHOD.                    "GET_TABLES_ITERATOR
  METHOD get_tables_size.
    ep_size = tables->size( ).
  ENDMETHOD.                    "GET_TABLES_SIZE
  METHOD get_title.
    DATA lv_value TYPE string.
    IF ip_escaped EQ abap_true.
      lv_value = me->title.
      ep_title = Lcl_excel_common=>escape_string( lv_value ).
    ELSE.
      ep_title = me->title.
    ENDIF.
  ENDMETHOD.                    "GET_TITLE
  METHOD get_value_type.
    DATA: lo_addit    TYPE REF TO cl_abap_elemdescr,
          ls_dfies    TYPE dfies,
          l_function  TYPE funcname,
          l_value(50) TYPE c.

    ep_value = ip_value.
    ep_value_type = cl_abap_typedescr=>typekind_string. " Thats our default if something goes wrong.

    TRY.
        lo_addit            ?= cl_abap_typedescr=>describe_by_data( ip_value ).
      CATCH cx_sy_move_cast_error.
        CLEAR lo_addit.
    ENDTRY.
    IF lo_addit IS BOUND.
      lo_addit->get_ddic_field( RECEIVING  p_flddescr   = ls_dfies
                                EXCEPTIONS not_found    = 1
                                           no_ddic_type = 2
                                           OTHERS       = 3 ) .
      IF sy-subrc = 0.
        ep_value_type = ls_dfies-inttype.

        IF ls_dfies-convexit IS NOT INITIAL.
* We need to convert with output conversion function
          CONCATENATE 'CONVERSION_EXIT_' ls_dfies-convexit '_OUTPUT' INTO l_function.
          SELECT SINGLE funcname INTO l_function
                FROM tfdir
                WHERE funcname = l_function.
          IF sy-subrc = 0.
            CALL FUNCTION l_function
              EXPORTING
                input  = ip_value
              IMPORTING
                output = l_value
              EXCEPTIONS
                OTHERS = 1.
            IF sy-subrc <> 0.
            ELSE.
              TRY.
                  ep_value = l_value.
                CATCH cx_root.
                  ep_value = ip_value.
              ENDTRY.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        ep_value_type = lo_addit->get_data_type_kind( ip_value ).
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "GET_VALUE_TYPE
  METHOD is_cell_merged.

    DATA: lv_column TYPE i.

    FIELD-SYMBOLS: <ls_merged_cell> LIKE LINE OF me->mt_merged_cells.

    lv_column = Lcl_excel_common=>convert_column2int( ip_column ).

    rp_is_merged = abap_false.                                        " Assume not in merged area

    LOOP AT me->mt_merged_cells ASSIGNING <ls_merged_cell>.

      IF    <ls_merged_cell>-col_from <= lv_column
        AND <ls_merged_cell>-col_to   >= lv_column
        AND <ls_merged_cell>-row_from <= ip_row
        AND <ls_merged_cell>-row_to   >= ip_row.
        rp_is_merged = abap_true.                                     " until we are proven different
        RETURN.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.                    "IS_CELL_MERGED
  METHOD move_supplied_borders.

    DATA: ls_borderx TYPE zexcel_s_cstylex_border.

    IF iv_border_supplied = abap_true.  " only act if parameter was supplied
      IF iv_xborder_supplied = abap_true. "
        ls_borderx = is_xborder.             " use supplied x-parameter
      ELSE.
        CLEAR ls_borderx WITH 'X'. " <============================== DDIC structure enh. category to set?
        " clear in a way that would be expected to work easily
        IF is_border-border_style IS  INITIAL.
          CLEAR ls_borderx-border_style.
        ENDIF.
        clear_initial_colorxfields(
          EXPORTING
            is_color  = is_border-border_color
          CHANGING
            cs_xcolor = ls_borderx-border_color ).
      ENDIF.
      MOVE-CORRESPONDING is_border  TO cs_complete_style_border.
      MOVE-CORRESPONDING ls_borderx TO cs_complete_stylex_border.
    ENDIF.

  ENDMETHOD.
  METHOD normalize_columnrow_parameter.

    IF ( ( ip_column IS NOT INITIAL OR ip_row IS NOT INITIAL ) AND ip_columnrow IS NOT INITIAL )
        OR ( ip_column IS INITIAL AND ip_row IS INITIAL AND ip_columnrow IS INITIAL ).
      RAISE EXCEPTION TYPE Lcx_excel
        EXPORTING
          error = 'Please provide either row and column, or cell reference'.
    ENDIF.

    IF ip_columnrow IS NOT INITIAL.
      Lcl_excel_common=>convert_columnrow2column_a_row(
        EXPORTING
          i_columnrow  = ip_columnrow
        IMPORTING
          e_column_int = ep_column
          e_row        = ep_row ).
    ELSE.
      ep_column = Lcl_excel_common=>convert_column2int( ip_column ).
      ep_row    = ip_row.
    ENDIF.

  ENDMETHOD.
  METHOD normalize_column_heading_texts.

    DATA: lt_field_catalog      TYPE zexcel_t_fieldcatalog,
          lv_value_lowercase    TYPE string,
          lv_scrtext_l_initial  TYPE zexcel_column_name,
          lv_long_text          TYPE string,
          lv_max_length         TYPE i,
          lv_temp_length        TYPE i,
          lv_syindex            TYPE c LENGTH 3,
          lt_column_name_buffer TYPE SORTED TABLE OF string WITH UNIQUE KEY table_line.
    FIELD-SYMBOLS: <ls_field_catalog> TYPE zexcel_s_fieldcatalog,
                   <scrtxt1>          TYPE any,
                   <scrtxt2>          TYPE any,
                   <scrtxt3>          TYPE any.

    " Due to restrictions in new table object we cannot have two columns with the same name
    " Check if a column with the same name exists, if exists add a counter
    " If no medium description is provided we try to use small or long

    lt_field_catalog = it_field_catalog.

    LOOP AT lt_field_catalog ASSIGNING <ls_field_catalog> WHERE dynpfld EQ abap_true.

      IF <ls_field_catalog>-column_name IS INITIAL.

        CASE iv_default_descr.
          WHEN 'M'.
            ASSIGN <ls_field_catalog>-scrtext_m TO <scrtxt1>.
            ASSIGN <ls_field_catalog>-scrtext_s TO <scrtxt2>.
            ASSIGN <ls_field_catalog>-scrtext_l TO <scrtxt3>.
          WHEN 'S'.
            ASSIGN <ls_field_catalog>-scrtext_s TO <scrtxt1>.
            ASSIGN <ls_field_catalog>-scrtext_m TO <scrtxt2>.
            ASSIGN <ls_field_catalog>-scrtext_l TO <scrtxt3>.
          WHEN 'L'.
            ASSIGN <ls_field_catalog>-scrtext_l TO <scrtxt1>.
            ASSIGN <ls_field_catalog>-scrtext_m TO <scrtxt2>.
            ASSIGN <ls_field_catalog>-scrtext_s TO <scrtxt3>.
          WHEN OTHERS.
            ASSIGN <ls_field_catalog>-scrtext_m TO <scrtxt1>.
            ASSIGN <ls_field_catalog>-scrtext_s TO <scrtxt2>.
            ASSIGN <ls_field_catalog>-scrtext_l TO <scrtxt3>.
        ENDCASE.

        IF <scrtxt1> IS NOT INITIAL.
          <ls_field_catalog>-column_name = <scrtxt1>.
        ELSEIF <scrtxt2> IS NOT INITIAL.
          <ls_field_catalog>-column_name = <scrtxt2>.
        ELSEIF <scrtxt3> IS NOT INITIAL.
          <ls_field_catalog>-column_name = <scrtxt3>.
        ELSE.
          <ls_field_catalog>-column_name = 'Column'.  " default value as Excel does
        ENDIF.
      ENDIF.

      lv_scrtext_l_initial = <ls_field_catalog>-column_name.
      DESCRIBE FIELD <ls_field_catalog>-column_name LENGTH lv_max_length IN CHARACTER MODE.
      DO.
        lv_value_lowercase = <ls_field_catalog>-column_name.
        TRANSLATE lv_value_lowercase TO LOWER CASE.
        READ TABLE lt_column_name_buffer TRANSPORTING NO FIELDS WITH KEY table_line = lv_value_lowercase BINARY SEARCH.
        IF sy-subrc <> 0.
          INSERT lv_value_lowercase INTO TABLE lt_column_name_buffer.
          EXIT.
        ELSE.
          lv_syindex = sy-index.
          CONCATENATE lv_scrtext_l_initial lv_syindex INTO lv_long_text.
          IF strlen( lv_long_text ) <= lv_max_length.
            <ls_field_catalog>-column_name = lv_long_text.
          ELSE.
            lv_temp_length = strlen( lv_scrtext_l_initial ) - 1.
            lv_scrtext_l_initial = substring( val = lv_scrtext_l_initial len = lv_temp_length ).
            CONCATENATE lv_scrtext_l_initial lv_syindex INTO <ls_field_catalog>-column_name.
          ENDIF.
        ENDIF.
      ENDDO.

    ENDLOOP.

    result = lt_field_catalog.

  ENDMETHOD.
  METHOD normalize_range_parameter.

    DATA: lv_errormessage TYPE string.

    IF ( ( ip_column_start IS NOT INITIAL OR ip_column_end IS NOT INITIAL
            OR ip_row IS NOT INITIAL OR ip_row_to IS NOT INITIAL ) AND ip_range IS NOT INITIAL )
        OR ( ip_column_start IS INITIAL AND ip_column_end IS INITIAL
            AND ip_row IS INITIAL AND ip_row_to IS INITIAL AND ip_range IS INITIAL ).
      RAISE EXCEPTION TYPE Lcx_excel
        EXPORTING
          error = 'Please provide either row and column interval, or range reference'.
    ENDIF.

    IF ip_range IS NOT INITIAL.
      Lcl_excel_common=>convert_range2column_a_row(
        EXPORTING
          i_range            = ip_range
        IMPORTING
          e_column_start_int = ep_column_start
          e_column_end_int   = ep_column_end
          e_row_start        = ep_row
          e_row_end          = ep_row_to ).
    ELSE.
      IF ip_column_start IS INITIAL.
        ep_column_start = Lcl_excel_common=>c_excel_sheet_min_col.
      ELSE.
        ep_column_start = Lcl_excel_common=>convert_column2int( ip_column_start ).
      ENDIF.
      IF ip_column_end IS INITIAL.
        ep_column_end = ep_column_start.
      ELSE.
        ep_column_end = Lcl_excel_common=>convert_column2int( ip_column_end ).
      ENDIF.
      ep_row = ip_row.
      IF ep_row IS INITIAL.
        ep_row = Lcl_excel_common=>c_excel_sheet_min_row.
      ENDIF.
      ep_row_to = ip_row_to.
      IF ep_row_to IS INITIAL.
        ep_row_to = ep_row.
      ENDIF.
    ENDIF.

    IF ep_row > ep_row_to.
      lv_errormessage = 'First row larger than last row'(405).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

    IF ep_column_start > ep_column_end.
      lv_errormessage = 'First column larger than last column'(406).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

  ENDMETHOD.
  METHOD normalize_style_parameter.

    DATA: lo_style_type TYPE REF TO cl_abap_typedescr.
    FIELD-SYMBOLS:
      <style> TYPE REF TO Lcl_excel_style.

    CHECK ip_style_or_guid IS NOT INITIAL.

    lo_style_type = cl_abap_typedescr=>describe_by_data( ip_style_or_guid ).
    IF lo_style_type->type_kind = lo_style_type->typekind_oref.
      lo_style_type = cl_abap_typedescr=>describe_by_object_ref( ip_style_or_guid ).
      IF lo_style_type->absolute_name = '\CLASS=LCL_EXCEL_STYLE'.
        ASSIGN ip_style_or_guid TO <style>.
        rv_guid = <style>->get_guid( ).
      ENDIF.

    ELSEIF lo_style_type->absolute_name = '\TYPE=ZEXCEL_CELL_STYLE'.
      rv_guid = ip_style_or_guid.

    ELSEIF lo_style_type->type_kind = lo_style_type->typekind_hex.
      rv_guid = ip_style_or_guid.

    ELSE.
      RAISE EXCEPTION TYPE Lcx_excel EXPORTING error = 'IP_GUID type must be either REF TO Lcl_excel_style or zexcel_cell_style'.
    ENDIF.

  ENDMETHOD.
  METHOD print_title_set_range.
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns
*           - Stefan Schmoecker,                            2012-12-02
*--------------------------------------------------------------------*


    DATA: lo_range_iterator         TYPE REF TO Lcl_excel_collection_iterator,
          lo_range                  TYPE REF TO Lcl_excel_range,
          lv_repeat_range_sheetname TYPE string,
          lv_repeat_range_col       TYPE string,
          lv_row_char_from          TYPE char10,
          lv_row_char_to            TYPE char10,
          lv_repeat_range_row       TYPE string,
          lv_repeat_range           TYPE string.


*--------------------------------------------------------------------*
* Get range that represents printarea
* if non-existant, create it
*--------------------------------------------------------------------*
    lo_range_iterator = me->get_ranges_iterator( ).
    WHILE lo_range_iterator->has_next( ) = abap_true.

      lo_range ?= lo_range_iterator->get_next( ).
      IF lo_range->name = Lif_excel_sheet_printsettings=>gcv_print_title_name.
        EXIT.  " Found it
      ENDIF.
      CLEAR lo_range.

    ENDWHILE.


    IF me->print_title_col_from IS INITIAL AND
       me->print_title_row_from IS INITIAL.
*--------------------------------------------------------------------*
* No print titles are present,
*--------------------------------------------------------------------*
      IF lo_range IS BOUND.
        me->ranges->remove( lo_range ).
      ENDIF.
    ELSE.
*--------------------------------------------------------------------*
* Print titles are present,
*--------------------------------------------------------------------*
      IF lo_range IS NOT BOUND.
        lo_range =  me->add_new_range( ).
        lo_range->name = Lif_excel_sheet_printsettings=>gcv_print_title_name.
      ENDIF.

      lv_repeat_range_sheetname = me->get_title( ).
      lv_repeat_range_sheetname = Lcl_excel_common=>escape_string( lv_repeat_range_sheetname ).

*--------------------------------------------------------------------*
* Repeat-columns
*--------------------------------------------------------------------*
      IF me->print_title_col_from IS NOT INITIAL.
        CONCATENATE lv_repeat_range_sheetname
                    '!$' me->print_title_col_from
                    ':$' me->print_title_col_to
            INTO lv_repeat_range_col.
      ENDIF.

*--------------------------------------------------------------------*
* Repeat-rows
*--------------------------------------------------------------------*
      IF me->print_title_row_from IS NOT INITIAL.
        lv_row_char_from = me->print_title_row_from.
        lv_row_char_to   = me->print_title_row_to.
        CONCATENATE '!$' lv_row_char_from
                    ':$' lv_row_char_to
            INTO lv_repeat_range_row.
        CONDENSE lv_repeat_range_row NO-GAPS.
        CONCATENATE lv_repeat_range_sheetname
                    lv_repeat_range_row
            INTO lv_repeat_range_row.
      ENDIF.

*--------------------------------------------------------------------*
* Concatenate repeat-rows and columns
*--------------------------------------------------------------------*
      IF lv_repeat_range_col IS INITIAL.
        lv_repeat_range = lv_repeat_range_row.
      ELSEIF lv_repeat_range_row IS INITIAL.
        lv_repeat_range = lv_repeat_range_col.
      ELSE.
        CONCATENATE lv_repeat_range_col lv_repeat_range_row
            INTO lv_repeat_range SEPARATED BY ','.
      ENDIF.


      lo_range->set_range_value( lv_repeat_range ).
    ENDIF.



  ENDMETHOD.                    "PRINT_TITLE_SET_RANGE
  METHOD set_area.

    DATA: lv_row              TYPE zexcel_cell_row,
          lv_row_start        TYPE zexcel_cell_row,
          lv_row_end          TYPE zexcel_cell_row,
          lv_column_int       TYPE zexcel_cell_column,
          lv_column           TYPE zexcel_cell_column_alpha,
          lv_column_start_int TYPE zexcel_cell_column,
          lv_column_end_int   TYPE zexcel_cell_column.

    normalize_range_parameter( EXPORTING ip_range        = ip_range
                                         ip_column_start = ip_column_start     ip_column_end = ip_column_end
                                         ip_row          = ip_row              ip_row_to     = ip_row_to
                               IMPORTING ep_column_start = lv_column_start_int ep_column_end = lv_column_end_int
                                         ep_row          = lv_row_start        ep_row_to     = lv_row_end ).

    " IP_AREA has been added to maintain ascending compatibility (see discussion in PR 869)
    IF ip_merge = abap_true OR ip_area = c_area-topleft.

      IF ip_data_type IS SUPPLIED OR
         ip_abap_type IS SUPPLIED.

        me->set_cell( ip_column    = lv_column_start_int
                      ip_row       = lv_row_start
                      ip_value     = ip_value
                      ip_formula   = ip_formula
                      ip_style     = ip_style
                      ip_hyperlink = ip_hyperlink
                      ip_data_type = ip_data_type
                      ip_abap_type = ip_abap_type ).

      ELSE.

        me->set_cell( ip_column    = lv_column_start_int
                      ip_row       = lv_row_start
                      ip_value     = ip_value
                      ip_formula   = ip_formula
                      ip_style     = ip_style
                      ip_hyperlink = ip_hyperlink ).

      ENDIF.

    ELSE.

      lv_column_int = lv_column_start_int.
      WHILE lv_column_int <= lv_column_end_int.

        lv_column = Lcl_excel_common=>convert_column2alpha( lv_column_int ).
        lv_row = lv_row_start.

        WHILE lv_row <= lv_row_end.

          IF ip_data_type IS SUPPLIED OR
             ip_abap_type IS SUPPLIED.

            me->set_cell( ip_column    = lv_column
                          ip_row       = lv_row
                          ip_value     = ip_value
                          ip_formula   = ip_formula
                          ip_style     = ip_style
                          ip_hyperlink = ip_hyperlink
                          ip_data_type = ip_data_type
                          ip_abap_type = ip_abap_type ).

          ELSE.

            me->set_cell( ip_column    = lv_column
                          ip_row       = lv_row
                          ip_value     = ip_value
                          ip_formula   = ip_formula
                          ip_style     = ip_style
                          ip_hyperlink = ip_hyperlink ).

          ENDIF.

          ADD 1 TO lv_row.
        ENDWHILE.

        ADD 1 TO lv_column_int.
      ENDWHILE.

    ENDIF.

    IF ip_style IS SUPPLIED.

      me->set_area_style( ip_column_start = lv_column_start_int
                          ip_column_end   = lv_column_end_int
                          ip_row          = lv_row_start
                          ip_row_to       = lv_row_end
                          ip_style        = ip_style ).
    ENDIF.

    IF ip_merge IS SUPPLIED AND ip_merge = abap_true.

      me->set_merge( ip_column_start = lv_column_start_int
                     ip_column_end   = lv_column_end_int
                     ip_row          = lv_row_start
                     ip_row_to       = lv_row_end ).

    ENDIF.

  ENDMETHOD.                    "set_area
  METHOD set_area_formula.
    DATA: ld_row              TYPE zexcel_cell_row,
          ld_row_start        TYPE zexcel_cell_row,
          ld_row_end          TYPE zexcel_cell_row,
          ld_column           TYPE zexcel_cell_column_alpha,
          ld_column_int       TYPE zexcel_cell_column,
          ld_column_start_int TYPE zexcel_cell_column,
          ld_column_end_int   TYPE zexcel_cell_column.

    normalize_range_parameter( EXPORTING ip_range        = ip_range
                                         ip_column_start = ip_column_start      ip_column_end = ip_column_end
                                         ip_row          = ip_row               ip_row_to     = ip_row_to
                               IMPORTING ep_column_start = ld_column_start_int  ep_column_end = ld_column_end_int
                                         ep_row          = ld_row_start         ep_row_to     = ld_row_end ).

    " IP_AREA has been added to maintain ascending compatibility (see discussion in PR 869)
    IF ip_merge = abap_true OR ip_area = c_area-topleft.

      me->set_cell_formula( ip_column = ld_column_start_int ip_row = ld_row_start
                            ip_formula = ip_formula ).

    ELSE.

      ld_column_int = ld_column_start_int.
      WHILE ld_column_int <= ld_column_end_int.

        ld_column = Lcl_excel_common=>convert_column2alpha( ld_column_int ).
        ld_row = ld_row_start.
        WHILE ld_row <= ld_row_end.

          me->set_cell_formula( ip_column = ld_column ip_row = ld_row
                                ip_formula = ip_formula ).

          ADD 1 TO ld_row.
        ENDWHILE.

        ADD 1 TO ld_column_int.
      ENDWHILE.

    ENDIF.

    IF ip_merge IS SUPPLIED AND ip_merge = abap_true.
      me->set_merge( ip_column_start = ld_column_start_int ip_row = ld_row_start
                     ip_column_end   = ld_column_end_int   ip_row_to = ld_row_end ).
    ENDIF.
  ENDMETHOD.                    "set_area_formula
  METHOD set_area_hyperlink.
    DATA: ld_row_start        TYPE zexcel_cell_row,
          ld_row_end          TYPE zexcel_cell_row,
          ld_column_int       TYPE zexcel_cell_column,
          ld_column_start_int TYPE zexcel_cell_column,
          ld_column_end_int   TYPE zexcel_cell_column,
          ld_current_column   TYPE zexcel_cell_column_alpha,
          ld_current_row      TYPE zexcel_cell_row,
          ld_value            TYPE string,
          ld_formula          TYPE string.
    DATA: lo_hyperlink TYPE REF TO Lcl_excel_hyperlink.

    normalize_range_parameter( EXPORTING ip_range        = ip_range
                                         ip_column_start = ip_column_start      ip_column_end = ip_column_end
                                         ip_row          = ip_row               ip_row_to     = ip_row_to
                               IMPORTING ep_column_start = ld_column_start_int  ep_column_end = ld_column_end_int
                                         ep_row          = ld_row_start         ep_row_to     = ld_row_end ).

    ld_column_int = ld_column_start_int.
    WHILE ld_column_int <= ld_column_end_int.
      ld_current_column = Lcl_excel_common=>convert_column2alpha( ld_column_int ).
      ld_current_row = ld_row_start.
      WHILE ld_current_row <= ld_row_end.

        me->get_cell( EXPORTING ip_column  = ld_current_column ip_row = ld_current_row
                      IMPORTING ep_value   = ld_value
                                ep_formula = ld_formula ).

        IF ip_is_internal = abap_true.
          lo_hyperlink = Lcl_excel_hyperlink=>create_internal_link( iv_location = ip_url ).
        ELSE.
          lo_hyperlink = Lcl_excel_hyperlink=>create_external_link( iv_url = ip_url ).
        ENDIF.

        me->set_cell( ip_column = ld_current_column ip_row = ld_current_row ip_value = ld_value ip_formula = ld_formula ip_hyperlink = lo_hyperlink ).

        ADD 1 TO ld_current_row.
      ENDWHILE.
      ADD 1 TO ld_column_int.
    ENDWHILE.

  ENDMETHOD.                    "SET_AREA_HYPERLINK
  METHOD set_area_style.
    DATA: ld_row_start        TYPE zexcel_cell_row,
          ld_row_end          TYPE zexcel_cell_row,
          ld_column_int       TYPE zexcel_cell_column,
          ld_column_start_int TYPE zexcel_cell_column,
          ld_column_end_int   TYPE zexcel_cell_column,
          ld_current_column   TYPE zexcel_cell_column_alpha,
          ld_current_row      TYPE zexcel_cell_row.

    normalize_range_parameter( EXPORTING ip_range        = ip_range
                                         ip_column_start = ip_column_start      ip_column_end = ip_column_end
                                         ip_row          = ip_row               ip_row_to     = ip_row_to
                               IMPORTING ep_column_start = ld_column_start_int  ep_column_end = ld_column_end_int
                                         ep_row          = ld_row_start         ep_row_to     = ld_row_end ).

    ld_column_int = ld_column_start_int.
    WHILE ld_column_int <= ld_column_end_int.
      ld_current_column = Lcl_excel_common=>convert_column2alpha( ld_column_int ).
      ld_current_row = ld_row_start.
      WHILE ld_current_row <= ld_row_end.
        me->set_cell_style( ip_row = ld_current_row ip_column = ld_current_column
                            ip_style = ip_style ).
        ADD 1 TO ld_current_row.
      ENDWHILE.
      ADD 1 TO ld_column_int.
    ENDWHILE.
    IF ip_merge IS SUPPLIED AND ip_merge = abap_true.
      me->set_merge( ip_column_start = ld_column_start_int ip_row = ld_row_start
                     ip_column_end   = ld_column_end_int   ip_row_to = ld_row_end ).
    ENDIF.
  ENDMETHOD.                    "SET_AREA_STYLE
  METHOD set_cell.

    DATA: lv_column        TYPE zexcel_cell_column,
          ls_sheet_content TYPE zexcel_s_cell_data,
          lv_row           TYPE zexcel_cell_row,
          lv_value         TYPE zexcel_cell_value,
          lv_data_type     TYPE zexcel_cell_data_type,
          lv_value_type    TYPE abap_typekind,
          lv_style_guid    TYPE zexcel_cell_style,
          lo_addit         TYPE REF TO cl_abap_elemdescr,
          lt_rtf           TYPE zexcel_t_rtf,
          lo_value         TYPE REF TO data,
          lo_value_new     TYPE REF TO data.

    FIELD-SYMBOLS: <fs_sheet_content> TYPE zexcel_s_cell_data,
                   <fs_numeric>       TYPE numeric,
                   <fs_date>          TYPE d,
                   <fs_time>          TYPE t,
                   <fs_value>         TYPE simple,
                   <fs_typekind_int8> TYPE abap_typekind.
    FIELD-SYMBOLS: <fs_column_formula> TYPE mty_s_column_formula.
    FIELD-SYMBOLS: <ls_fieldcat>       TYPE zexcel_s_fieldcatalog.

    IF ip_value  IS NOT SUPPLIED
        AND ip_formula IS NOT SUPPLIED
        AND ip_column_formula_id = 0.
      Lcx_excel=>raise_text( 'Please provide the value or formula' ).
    ENDIF.

    normalize_columnrow_parameter( EXPORTING ip_columnrow = ip_columnrow
                                             ip_column    = ip_column
                                             ip_row       = ip_row
                                   IMPORTING ep_column    = lv_column
                                             ep_row       = lv_row ).

* Begin of change issue #152 - don't touch exisiting style if only value is passed
    IF ip_column_formula_id <> 0.
      check_cell_column_formula(
          it_column_formulas   = column_formulas
          ip_column_formula_id = ip_column_formula_id
          ip_formula           = ip_formula
          ip_value             = ip_value
          ip_row               = lv_row
          ip_column            = lv_column ).
    ENDIF.
    READ TABLE sheet_content ASSIGNING <fs_sheet_content> WITH TABLE KEY cell_row    = lv_row      " Changed to access via table key , Stefan Schmöcker, 2013-08-03
                                                                         cell_column = lv_column.
    IF sy-subrc = 0.
      IF ip_style IS INITIAL.
        " If no style is provided as method-parameter and cell is found use cell's current style
        lv_style_guid = <fs_sheet_content>-cell_style.
      ELSE.
        " Style provided as method-parameter --> use this
        lv_style_guid = normalize_style_parameter( ip_style ).
      ENDIF.
    ELSE.
      " No cell found --> use supplied style even if empty
      lv_style_guid = normalize_style_parameter( ip_style ).
    ENDIF.
* End of change issue #152 - don't touch exisiting style if only value is passed

    IF ip_value IS SUPPLIED.
      "if data type is passed just write the value. Otherwise map abap type to excel and perform conversion
      "IP_DATA_TYPE is passed by excel reader so source types are preserved
*First we get reference into local var.
      IF ip_conv_exit_length = abap_true.
        lo_value = create_data_conv_exit_length( ip_value ).
      ELSE.
        CREATE DATA lo_value LIKE ip_value.
      ENDIF.
      ASSIGN lo_value->* TO <fs_value>.
      <fs_value> = ip_value.
      IF ip_data_type IS SUPPLIED.
        IF ip_abap_type IS NOT SUPPLIED.
          get_value_type( EXPORTING ip_value      = ip_value
                          IMPORTING ep_value      = <fs_value> ) .
        ENDIF.
        lv_value = <fs_value>.
        lv_data_type = ip_data_type.
      ELSE.
        IF ip_abap_type IS SUPPLIED.
          lv_value_type = ip_abap_type.
        ELSE.
          get_value_type( EXPORTING ip_value      = ip_value
                          IMPORTING ep_value      = <fs_value>
                                    ep_value_type = lv_value_type ).
        ENDIF.

        ASSIGN ('CL_ABAP_TYPEDESCR=>TYPEKIND_INT8') TO <fs_typekind_int8>.
        IF sy-subrc <> 0.
          ASSIGN space TO <fs_typekind_int8>. "not used as typekind!
        ENDIF.

        CASE lv_value_type.
          WHEN cl_abap_typedescr=>typekind_int OR cl_abap_typedescr=>typekind_int1 OR cl_abap_typedescr=>typekind_int2
            OR <fs_typekind_int8>. "Allow INT8 types columns
            IF lv_value_type = <fs_typekind_int8>.
              CALL METHOD cl_abap_elemdescr=>('GET_INT8') RECEIVING p_result = lo_addit.
            ELSE.
              lo_addit = cl_abap_elemdescr=>get_i( ).
            ENDIF.
            CREATE DATA lo_value_new TYPE HANDLE lo_addit.
            ASSIGN lo_value_new->* TO <fs_numeric>.
            IF sy-subrc = 0.
              <fs_numeric> = <fs_value>.
              lv_value = Lcl_excel_common=>number_to_excel_string( ip_value = <fs_numeric> ).
            ENDIF.

          WHEN cl_abap_typedescr=>typekind_float OR cl_abap_typedescr=>typekind_packed OR
               cl_abap_typedescr=>typekind_decfloat OR
               cl_abap_typedescr=>typekind_decfloat16 OR
               cl_abap_typedescr=>typekind_decfloat34.
            IF lv_value_type = cl_abap_typedescr=>typekind_packed
                AND ip_currency IS NOT INITIAL.
              lv_value = Lcl_excel_common=>number_to_excel_string( ip_value    = <fs_value>
                                                                   ip_currency = ip_currency ).
            ELSE.
              lo_addit = cl_abap_elemdescr=>get_f( ).
              CREATE DATA lo_value_new TYPE HANDLE lo_addit.
              ASSIGN lo_value_new->* TO <fs_numeric>.
              IF sy-subrc = 0.
                <fs_numeric> = <fs_value>.
                lv_value = Lcl_excel_common=>number_to_excel_string( ip_value = <fs_numeric> ).
              ENDIF.
            ENDIF.

          WHEN cl_abap_typedescr=>typekind_char OR cl_abap_typedescr=>typekind_string OR cl_abap_typedescr=>typekind_num OR
               cl_abap_typedescr=>typekind_hex.
            lv_value = <fs_value>.
            lv_data_type = 's'.

          WHEN cl_abap_typedescr=>typekind_date.
            lo_addit = cl_abap_elemdescr=>get_d( ).
            CREATE DATA lo_value_new TYPE HANDLE lo_addit.
            ASSIGN lo_value_new->* TO <fs_date>.
            IF sy-subrc = 0.
              <fs_date> = <fs_value>.
              lv_value = Lcl_excel_common=>date_to_excel_string( ip_value = <fs_date> ) .
            ENDIF.
* Begin of change issue #152 - don't touch exisiting style if only value is passed
* Moved to end of routine - apply date-format even if other styleinformation is passed
*          IF ip_style IS NOT SUPPLIED. "get default date format in case parameter is initial
*            lo_style = excel->add_new_style( ).
*            lo_style->number_format->format_code = get_default_excel_date_format( ).
*            lv_style_guid = lo_style->get_guid( ).
*          ENDIF.
* End of change issue #152 - don't touch exisiting style if only value is passed

          WHEN cl_abap_typedescr=>typekind_time.
            lo_addit = cl_abap_elemdescr=>get_t( ).
            CREATE DATA lo_value_new TYPE HANDLE lo_addit.
            ASSIGN lo_value_new->* TO <fs_time>.
            IF sy-subrc = 0.
              <fs_time> = <fs_value>.
              lv_value = Lcl_excel_common=>time_to_excel_string( ip_value = <fs_time> ).
            ENDIF.
* Begin of change issue #152 - don't touch exisiting style if only value is passed
* Moved to end of routine - apply time-format even if other styleinformation is passed
*          IF ip_style IS NOT SUPPLIED. "get default time format for user in case parameter is initial
*            lo_style = excel->add_new_style( ).
*            lo_style->number_format->format_code = Lcl_excel_style_number_format=>c_format_date_time6.
*            lv_style_guid = lo_style->get_guid( ).
*          ENDIF.
* End of change issue #152 - don't touch exisiting style if only value is passed

          WHEN OTHERS.
            Lcx_excel=>raise_text( 'Invalid data type of input value' ).
        ENDCASE.
      ENDIF.

      IF <fs_sheet_content> IS ASSIGNED AND <fs_sheet_content>-table_header IS NOT INITIAL AND lv_value IS NOT INITIAL.
        READ TABLE <fs_sheet_content>-table->fieldcat ASSIGNING <ls_fieldcat> WITH KEY fieldname = <fs_sheet_content>-table_fieldname.
        IF sy-subrc = 0.
          <ls_fieldcat>-column_name = lv_value.
          IF <ls_fieldcat>-column_name <> lv_value.
            Lcx_excel=>raise_text( 'Cell is table column header - this value is not allowed' ).
          ENDIF.
        ENDIF.
      ENDIF.

    ENDIF.

    IF ip_hyperlink IS BOUND.
      ip_hyperlink->set_cell_reference( ip_column = lv_column
                                        ip_row = lv_row ).
      me->hyperlinks->add( ip_hyperlink ).
    ENDIF.

    IF lv_value CS '_x'.
      " Issue #761 value "_x0041_" rendered as "A".
      " "_x...._", where "." is 0-9 a-f or A-F (case insensitive), is an internal value in sharedStrings.xml
      " that Excel uses to store special characters, it's interpreted like Unicode character U+....
      " for instance "_x0041_" is U+0041 which is "A".
      " To not interpret such text, the first underscore is replaced with "_x005f_".
      " The value "_x0041_" is to be stored internally "_x005f_x0041_" so that it's rendered like "_x0041_".
      " Note that REGEX is time consuming, it's why "CS" is used above to improve the performance.
      REPLACE ALL OCCURRENCES OF REGEX '_(x[0-9a-fA-F]{4}_)' IN lv_value WITH '_x005f_$1' RESPECTING CASE.
    ENDIF.

* Begin of change issue #152 - don't touch exisiting style if only value is passed
* Read table moved up, so that current style may be evaluated

    IF <fs_sheet_content> IS ASSIGNED.
* End of change issue #152 - don't touch exisiting style if only value is passed
      <fs_sheet_content>-cell_value   = lv_value.
      <fs_sheet_content>-cell_formula = ip_formula.
      <fs_sheet_content>-column_formula_id = ip_column_formula_id.
      <fs_sheet_content>-cell_style   = lv_style_guid.
      <fs_sheet_content>-data_type    = lv_data_type.
    ELSE.
      ls_sheet_content-cell_row     = lv_row.
      ls_sheet_content-cell_column  = lv_column.
      ls_sheet_content-cell_value   = lv_value.
      ls_sheet_content-cell_formula = ip_formula.
      ls_sheet_content-column_formula_id = ip_column_formula_id.
      ls_sheet_content-cell_style   = lv_style_guid.
      ls_sheet_content-data_type    = lv_data_type.
      ls_sheet_content-cell_coords  = Lcl_excel_common=>convert_column_a_row2columnrow( i_column = lv_column i_row = lv_row ).
      INSERT ls_sheet_content INTO TABLE sheet_content ASSIGNING <fs_sheet_content>. "ins #152 - Now <fs_sheet_content> always holds the data

    ENDIF.

    IF ip_formula IS INITIAL AND lv_value IS NOT INITIAL AND it_rtf IS NOT INITIAL.
      lt_rtf = it_rtf.
      check_rtf( EXPORTING ip_value = lv_value
                           ip_style = lv_style_guid
                 CHANGING  ct_rtf   = lt_rtf ).
      <fs_sheet_content>-rtf_tab = lt_rtf.
    ENDIF.

* Begin of change issue #152 - don't touch exisiting style if only value is passed
* For Date- or Timefields change the formatcode if nothing is set yet
* Enhancement option:  Check if existing formatcode is a date/ or timeformat
*                      If not, use default
    DATA: lo_format_code_datetime TYPE zexcel_number_format.
    DATA: stylemapping    TYPE zexcel_s_stylemapping.
    IF <fs_sheet_content>-cell_style IS INITIAL.
      <fs_sheet_content>-cell_style = me->excel->get_default_style( ).
    ENDIF.
    CASE lv_value_type.
      WHEN cl_abap_typedescr=>typekind_date.
        TRY.
            stylemapping = me->excel->get_style_to_guid( <fs_sheet_content>-cell_style ).
          CATCH Lcx_excel .
        ENDTRY.
        IF stylemapping-complete_stylex-number_format-format_code IS INITIAL OR
           stylemapping-complete_style-number_format-format_code IS INITIAL.
          lo_format_code_datetime = Lcl_excel_style_number_format=>c_format_date_std.
        ELSE.
          lo_format_code_datetime = stylemapping-complete_style-number_format-format_code.
        ENDIF.
        me->change_cell_style( ip_column                      = lv_column
                               ip_row                         = lv_row
                               ip_number_format_format_code   = lo_format_code_datetime ).

      WHEN cl_abap_typedescr=>typekind_time.
        TRY.
            stylemapping = me->excel->get_style_to_guid( <fs_sheet_content>-cell_style ).
          CATCH Lcx_excel .
        ENDTRY.
        IF stylemapping-complete_stylex-number_format-format_code IS INITIAL OR
           stylemapping-complete_style-number_format-format_code IS INITIAL.
          lo_format_code_datetime = Lcl_excel_style_number_format=>c_format_date_time6.
        ELSE.
          lo_format_code_datetime = stylemapping-complete_style-number_format-format_code.
        ENDIF.
        me->change_cell_style( ip_column                      = lv_column
                               ip_row                         = lv_row
                               ip_number_format_format_code   = lo_format_code_datetime ).

    ENDCASE.
* End of change issue #152 - don't touch exisiting style if only value is passed

* Fix issue #162
    lv_value = ip_value.
    IF lv_value CS cl_abap_char_utilities=>cr_lf.
      me->change_cell_style( ip_column               = lv_column
                             ip_row                  = lv_row
                             ip_alignment_wraptext   = abap_true ).
    ENDIF.
* End of Fix issue #162

  ENDMETHOD.                    "SET_CELL
  METHOD set_cell_formula.
    DATA:
      lv_column        TYPE zexcel_cell_column,
      lv_row           TYPE zexcel_cell_row,
      ls_sheet_content LIKE LINE OF me->sheet_content.

    FIELD-SYMBOLS:
                <sheet_content>                 LIKE LINE OF me->sheet_content.

*--------------------------------------------------------------------*
* Get cell to set formula into
*--------------------------------------------------------------------*
    normalize_columnrow_parameter( EXPORTING ip_columnrow = ip_columnrow
                                             ip_column    = ip_column
                                             ip_row       = ip_row
                                   IMPORTING ep_column    = lv_column
                                             ep_row       = lv_row ).

    READ TABLE me->sheet_content ASSIGNING <sheet_content> WITH TABLE KEY cell_row    = lv_row
                                                                          cell_column = lv_column.
    IF sy-subrc <> 0.                   " Create new entry in sheet_content if necessary
      CHECK ip_formula IS NOT INITIAL.  " only create new entry in sheet_content when a formula is passed
      ls_sheet_content-cell_row    = lv_row.
      ls_sheet_content-cell_column = lv_column.
      ls_sheet_content-cell_coords = Lcl_excel_common=>convert_column_a_row2columnrow( i_column = lv_column i_row = lv_row ).
      INSERT ls_sheet_content INTO TABLE me->sheet_content ASSIGNING <sheet_content>.
    ENDIF.

*--------------------------------------------------------------------*
* Fieldsymbol now holds the relevant cell
*--------------------------------------------------------------------*
    <sheet_content>-cell_formula = ip_formula.


  ENDMETHOD.                    "SET_CELL_FORMULA
  METHOD set_cell_style.

    DATA: lv_column     TYPE zexcel_cell_column,
          lv_row        TYPE zexcel_cell_row,
          lv_style_guid TYPE zexcel_cell_style.

    FIELD-SYMBOLS: <fs_sheet_content> TYPE zexcel_s_cell_data.

    lv_style_guid = normalize_style_parameter( ip_style ).

    normalize_columnrow_parameter( EXPORTING ip_columnrow = ip_columnrow
                                             ip_column    = ip_column
                                             ip_row       = ip_row
                                   IMPORTING ep_column    = lv_column
                                             ep_row       = lv_row ).

    READ TABLE sheet_content ASSIGNING <fs_sheet_content> WITH KEY cell_row    = lv_row
                                                                   cell_column = lv_column.

    IF sy-subrc EQ 0.
      <fs_sheet_content>-cell_style   = lv_style_guid.
    ELSE.
      set_cell( ip_column = ip_column ip_row = ip_row ip_value = '' ip_style = ip_style ).
    ENDIF.

  ENDMETHOD.                    "SET_CELL_STYLE
  METHOD set_column_width.
    DATA: lo_column  TYPE REF TO Lcl_excel_column.
    DATA: width             TYPE f.

    lo_column = me->get_column( ip_column ).

* if a fix size is supplied use this
    IF ip_width_fix IS SUPPLIED.
      TRY.
          width = ip_width_fix.
          IF width <= 0.
            Lcx_excel=>raise_text( 'Please supply a positive number as column-width' ).
          ENDIF.
          lo_column->set_width( width ).
          RETURN.
        CATCH cx_sy_conversion_no_number.
* Strange stuff passed --> raise error
          Lcx_excel=>raise_text( 'Unable to interpret supplied input as number' ).
      ENDTRY.
    ENDIF.

* If we get down to here, we have to use whatever is found in autosize.
    lo_column->set_auto_size( ip_width_autosize ).


  ENDMETHOD.                    "SET_COLUMN_WIDTH
  METHOD set_default_excel_date_format.

    IF ip_default_excel_date_format IS INITIAL.
      Lcx_excel=>raise_text( 'Default date format cannot be blank' ).
    ENDIF.

    default_excel_date_format = ip_default_excel_date_format.
  ENDMETHOD.                    "SET_DEFAULT_EXCEL_DATE_FORMAT
  METHOD set_ignored_errors.
    mt_ignored_errors = it_ignored_errors.
  ENDMETHOD.
  METHOD set_merge.

    DATA: ls_merge        TYPE mty_merge,
          lv_column_start TYPE zexcel_cell_column,
          lv_column_end   TYPE zexcel_cell_column,
          lv_row          TYPE zexcel_cell_row,
          lv_row_to       TYPE zexcel_cell_row,
          lv_errormessage TYPE string.

    normalize_range_parameter( EXPORTING ip_range        = ip_range
                                         ip_column_start = ip_column_start ip_column_end = ip_column_end
                                         ip_row          = ip_row          ip_row_to     = ip_row_to
                               IMPORTING ep_column_start = lv_column_start ep_column_end = lv_column_end
                                         ep_row          = lv_row          ep_row_to     = lv_row_to ).

    IF ip_value IS SUPPLIED OR ip_formula IS SUPPLIED.
      " if there is a value or formula set the value to the top-left cell
      "maybe it is necessary to support other paramters for set_cell
      IF ip_value IS SUPPLIED.
        me->set_cell( ip_row = lv_row ip_column = lv_column_start
                      ip_value = ip_value ).
      ENDIF.
      IF ip_formula IS SUPPLIED.
        me->set_cell( ip_row = lv_row ip_column = lv_column_start
                      ip_value = ip_formula ).
      ENDIF.
    ENDIF.
    "call to set_merge_style to apply the style to all cells at the matrix
    IF ip_style IS SUPPLIED.
      me->set_merge_style( ip_row = lv_row ip_column_start = lv_column_start
                           ip_row_to = lv_row_to ip_column_end = lv_column_end
                           ip_style = ip_style ).
    ENDIF.
    ...
*--------------------------------------------------------------------*
* Build new range area to insert into range table
*--------------------------------------------------------------------*
    ls_merge-row_from = lv_row.
    ls_merge-row_to   = lv_row_to.
    ls_merge-col_from = lv_column_start.
    ls_merge-col_to   = lv_column_end.

*--------------------------------------------------------------------*
* Check merge not overlapping with existing merges
*--------------------------------------------------------------------*
    LOOP AT me->mt_merged_cells TRANSPORTING NO FIELDS WHERE NOT (    row_from > ls_merge-row_to
                                                                   OR row_to   < ls_merge-row_from
                                                                   OR col_from > ls_merge-col_to
                                                                   OR col_to   < ls_merge-col_from ).
      lv_errormessage = 'Overlapping merges'(404).
      Lcx_excel=>raise_text( lv_errormessage ).

    ENDLOOP.

*--------------------------------------------------------------------*
* Everything seems ok --> add to merge table
*--------------------------------------------------------------------*
    INSERT ls_merge INTO TABLE me->mt_merged_cells.

  ENDMETHOD.                    "SET_MERGE
  METHOD set_merge_style.
    DATA: ld_row_start      TYPE zexcel_cell_row,
          ld_row_end        TYPE zexcel_cell_row,
          ld_column_int     TYPE zexcel_cell_column,
          ld_column_start   TYPE zexcel_cell_column,
          ld_column_end     TYPE zexcel_cell_column,
          ld_current_column TYPE zexcel_cell_column_alpha,
          ld_current_row    TYPE zexcel_cell_row.

    normalize_range_parameter( EXPORTING ip_range        = ip_range
                                         ip_column_start = ip_column_start ip_column_end = ip_column_end
                                         ip_row          = ip_row          ip_row_to     = ip_row_to
                               IMPORTING ep_column_start = ld_column_start ep_column_end = ld_column_end
                                         ep_row          = ld_row_start    ep_row_to     = ld_row_end ).

    "set the style cell by cell
    ld_column_int = ld_column_start.
    WHILE ld_column_int <= ld_column_end.
      ld_current_column = Lcl_excel_common=>convert_column2alpha( ld_column_int ).
      ld_current_row = ld_row_start.
      WHILE ld_current_row <= ld_row_end.
        me->set_cell_style( ip_row = ld_current_row ip_column = ld_current_column
                            ip_style = ip_style ).
        ADD 1 TO ld_current_row.
      ENDWHILE.
      ADD 1 TO ld_column_int.
    ENDWHILE.
  ENDMETHOD.                    "set_merge_style
  METHOD set_print_gridlines.
    me->print_gridlines = i_print_gridlines.
  ENDMETHOD.                    "SET_PRINT_GRIDLINES
  METHOD set_row_height.
    DATA: lo_row  TYPE REF TO Lcl_excel_row.
    DATA: height  TYPE f.

    lo_row = me->get_row( ip_row ).

* if a fix size is supplied use this
    TRY.
        height = ip_height_fix.
        lo_row->set_row_height( height ).
        RETURN.
      CATCH cx_sy_conversion_no_number.
* Strange stuff passed --> raise error
        Lcx_excel=>raise_text( 'Unable to interpret supplied input as number' ).
    ENDTRY.

  ENDMETHOD.                    "SET_ROW_HEIGHT
  METHOD set_row_outline.

    DATA: ls_row_outline LIKE LINE OF me->mt_row_outlines.
    FIELD-SYMBOLS: <ls_row_outline> LIKE LINE OF me->mt_row_outlines.

    READ TABLE me->mt_row_outlines ASSIGNING <ls_row_outline> WITH TABLE KEY row_from = iv_row_from
                                                                             row_to   = iv_row_to.
    IF sy-subrc <> 0.
      IF iv_row_from <= 0.
        Lcx_excel=>raise_text( 'First row of outline must be a positive number' ).
      ENDIF.
      IF iv_row_to < iv_row_from.
        Lcx_excel=>raise_text( 'Last row of outline may not be less than first line of outline' ).
      ENDIF.
      ls_row_outline-row_from = iv_row_from.
      ls_row_outline-row_to   = iv_row_to.
      INSERT ls_row_outline INTO TABLE me->mt_row_outlines ASSIGNING <ls_row_outline>.
    ENDIF.

    CASE iv_collapsed.

      WHEN abap_true
        OR abap_false.
        <ls_row_outline>-collapsed = iv_collapsed.

      WHEN OTHERS.
        Lcx_excel=>raise_text( 'Unknown collapse state' ).

    ENDCASE.
  ENDMETHOD.                    "SET_ROW_OUTLINE
  METHOD set_show_gridlines.
    me->show_gridlines = i_show_gridlines.
  ENDMETHOD.                    "SET_SHOW_GRIDLINES
  METHOD set_show_rowcolheaders.
    me->show_rowcolheaders = i_show_rowcolheaders.
  ENDMETHOD.                    "SET_SHOW_ROWCOLHEADERS
  METHOD set_tabcolor.
    me->tabcolor = iv_tabcolor.
  ENDMETHOD.                    "SET_TABCOLOR
  METHOD set_table.

    DATA: lo_tabdescr     TYPE REF TO cl_abap_structdescr,
          lr_data         TYPE REF TO data,
          lt_dfies        TYPE ddfields,
          lv_row_int      TYPE zexcel_cell_row,
          lv_column_int   TYPE zexcel_cell_column,
          lv_column_alpha TYPE zexcel_cell_column_alpha,
          lv_cell_value   TYPE zexcel_cell_value.


    FIELD-SYMBOLS: <fs_table_line> TYPE any,
                   <fs_fldval>     TYPE any,
                   <fs_dfies>      TYPE dfies.

    lv_column_int = Lcl_excel_common=>convert_column2int( ip_top_left_column ).
    lv_row_int    = ip_top_left_row.

    CREATE DATA lr_data LIKE LINE OF ip_table.

    lo_tabdescr ?= cl_abap_structdescr=>describe_by_data_ref( lr_data ).

    lt_dfies = lo_tabdescr->get_ddic_field_list( ).

* It is better to loop column by column
    LOOP AT lt_dfies ASSIGNING <fs_dfies>.
      lv_column_alpha = Lcl_excel_common=>convert_column2alpha( lv_column_int ).

      IF ip_no_header = abap_false.
        " First of all write column header
        lv_cell_value = <fs_dfies>-scrtext_m.
        me->set_cell( ip_column = lv_column_alpha
                      ip_row    = lv_row_int
                      ip_value  = lv_cell_value
                      ip_style  = ip_hdr_style ).
        IF ip_transpose = abap_true.
          ADD 1 TO lv_column_int.
        ELSE.
          ADD 1 TO lv_row_int.
        ENDIF.
      ENDIF.

      LOOP AT ip_table ASSIGNING <fs_table_line>.
        lv_column_alpha = Lcl_excel_common=>convert_column2alpha( lv_column_int ).
        ASSIGN COMPONENT <fs_dfies>-fieldname OF STRUCTURE <fs_table_line> TO <fs_fldval>.
        lv_cell_value = <fs_fldval>.
        me->set_cell( ip_column = lv_column_alpha
                      ip_row    = lv_row_int
                      ip_value  = <fs_fldval>   "lv_cell_value
                      ip_style  = ip_body_style ).
        IF ip_transpose = abap_true.
          ADD 1 TO lv_column_int.
        ELSE.
          ADD 1 TO lv_row_int.
        ENDIF.
      ENDLOOP.
      IF ip_transpose = abap_true.
        lv_column_int = Lcl_excel_common=>convert_column2int( ip_top_left_column ).
        ADD 1 TO lv_row_int.
      ELSE.
        lv_row_int = ip_top_left_row.
        ADD 1 TO lv_column_int.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "SET_TABLE
  METHOD set_title.
*--------------------------------------------------------------------*
* ToDos:
*        2do §1  The current coding for replacing a named ranges name
*                after renaming a sheet should be checked if it is
*                really working if sheetname should be escaped
*--------------------------------------------------------------------*

*--------------------------------------------------------------------*
* issue #230   - Pimp my Code
*              - Stefan Schmoecker,      (wip )              2012-12-08
*              - ...
* changes: aligning code
*          message made to support multilinguality
*--------------------------------------------------------------------*
* issue#243 - ' is not allowed as first character in sheet title
*              - Stefan Schmoecker,                          2012-12-02
* changes: added additional check for ' as first character
*--------------------------------------------------------------------*
    DATA: lo_worksheets_iterator TYPE REF TO Lcl_excel_collection_iterator,
          lo_worksheet           TYPE REF TO Lcl_excel_worksheet,
          errormessage           TYPE string,
          lv_rangesheetname_old  TYPE string,
          lv_rangesheetname_new  TYPE string,
          lo_ranges_iterator     TYPE REF TO Lcl_excel_collection_iterator,
          lo_range               TYPE REF TO Lcl_excel_range,
          lv_range_value         TYPE zexcel_range_value,
          lv_errormessage        TYPE string.                          " Can't pass '...'(abc) to exception-class


*--------------------------------------------------------------------*
* Check whether title consists only of allowed characters
* Illegal characters are: / \ [ ] * ? : --> http://msdn.microsoft.com/en-us/library/ff837411.aspx
* Illegal characters not in documentation:   ' as first character
*--------------------------------------------------------------------*
    IF ip_title CA '/\[]*?:'.
      lv_errormessage = 'Found illegal character in sheetname. List of forbidden characters: /\[]*?:'(402).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

    IF ip_title IS NOT INITIAL AND ip_title(1) = `'`.
      lv_errormessage = 'Sheetname may not start with &'(403).   " & used instead of ' to allow fallbacklanguage
      REPLACE '&' IN lv_errormessage WITH `'`.
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.


*--------------------------------------------------------------------*
* Check whether title is unique in workbook
*--------------------------------------------------------------------*
    lo_worksheets_iterator = me->excel->get_worksheets_iterator( ).
    WHILE lo_worksheets_iterator->has_next( ) = 'X'.

      lo_worksheet ?= lo_worksheets_iterator->get_next( ).
      CHECK me->guid <> lo_worksheet->get_guid( ).  " Don't check against itself
      IF ip_title = lo_worksheet->get_title( ).  " Not unique --> raise exception
        errormessage = 'Duplicate sheetname &'.
        REPLACE '&' IN errormessage WITH ip_title.
        Lcx_excel=>raise_text( errormessage ).
      ENDIF.

    ENDWHILE.

*--------------------------------------------------------------------*
* Remember old sheetname and rename sheet to desired name
*--------------------------------------------------------------------*
    CONCATENATE me->title '!' INTO lv_rangesheetname_old.
    me->title = ip_title.

*--------------------------------------------------------------------*
* After changing this worksheet's title we have to adjust
* all ranges that are referring to this worksheet.
*--------------------------------------------------------------------*
* 2do §1  -  Check if the following quickfix is solid
*           I fear it isn't - but this implementation is better then
*           nothing at all since it handles a supposed majority of cases
*--------------------------------------------------------------------*
    CONCATENATE me->title '!' INTO lv_rangesheetname_new.

    lo_ranges_iterator = me->excel->get_ranges_iterator( ).
    WHILE lo_ranges_iterator->has_next( ) = 'X'.

      lo_range ?= lo_ranges_iterator->get_next( ).
      lv_range_value = lo_range->get_value( ).
      REPLACE ALL OCCURRENCES OF lv_rangesheetname_old IN lv_range_value WITH lv_rangesheetname_new.
      IF sy-subrc = 0.
        lo_range->set_range_value( lv_range_value ).
      ENDIF.

    ENDWHILE.


  ENDMETHOD.                    "SET_TITLE
  METHOD update_dimension_range.

    DATA: ls_sheet_content TYPE zexcel_s_cell_data,
          lv_row_alpha     TYPE string,
          lv_column_alpha  TYPE zexcel_cell_column_alpha.

    CHECK sheet_content IS NOT INITIAL.

    upper_cell-cell_row = rows->get_min_index( ).
    IF upper_cell-cell_row = 0.
      upper_cell-cell_row = Lcl_excel_common=>c_excel_sheet_max_row.
    ENDIF.
    upper_cell-cell_column = Lcl_excel_common=>c_excel_sheet_max_col.

    lower_cell-cell_row = rows->get_max_index( ).
    IF lower_cell-cell_row = 0.
      lower_cell-cell_row = Lcl_excel_common=>c_excel_sheet_min_row.
    ENDIF.
    lower_cell-cell_column = Lcl_excel_common=>c_excel_sheet_min_col.

    LOOP AT sheet_content INTO ls_sheet_content.
      IF upper_cell-cell_row > ls_sheet_content-cell_row.
        upper_cell-cell_row = ls_sheet_content-cell_row.
      ENDIF.
      IF upper_cell-cell_column > ls_sheet_content-cell_column.
        upper_cell-cell_column = ls_sheet_content-cell_column.
      ENDIF.
      IF lower_cell-cell_row < ls_sheet_content-cell_row.
        lower_cell-cell_row = ls_sheet_content-cell_row.
      ENDIF.
      IF lower_cell-cell_column < ls_sheet_content-cell_column.
        lower_cell-cell_column = ls_sheet_content-cell_column.
      ENDIF.
    ENDLOOP.

    upper_cell-cell_coords = Lcl_excel_common=>convert_column_a_row2columnrow( i_column = upper_cell-cell_column i_row = upper_cell-cell_row ).

    lower_cell-cell_coords = Lcl_excel_common=>convert_column_a_row2columnrow( i_column = lower_cell-cell_column i_row = lower_cell-cell_row ).

  ENDMETHOD.                    "UPDATE_DIMENSION_RANGE
  METHOD Lif_excel_sheet_printsettings~clear_print_repeat_columns.

*--------------------------------------------------------------------*
* adjust internal representation
*--------------------------------------------------------------------*
    CLEAR:  me->print_title_col_from,
            me->print_title_col_to  .


*--------------------------------------------------------------------*
* adjust corresponding range
*--------------------------------------------------------------------*
    me->print_title_set_range( ).


  ENDMETHOD.                    "LIF_EXCEL_SHEET_PRINTSETTINGS~CLEAR_PRINT_REPEAT_COLUMNS
  METHOD Lif_excel_sheet_printsettings~clear_print_repeat_rows.

*--------------------------------------------------------------------*
* adjust internal representation
*--------------------------------------------------------------------*
    CLEAR:  me->print_title_row_from,
            me->print_title_row_to  .


*--------------------------------------------------------------------*
* adjust corresponding range
*--------------------------------------------------------------------*
    me->print_title_set_range( ).


  ENDMETHOD.                    "LIF_EXCEL_SHEET_PRINTSETTINGS~CLEAR_PRINT_REPEAT_ROWS
  METHOD Lif_excel_sheet_printsettings~get_print_repeat_columns.
    ev_columns_from = me->print_title_col_from.
    ev_columns_to   = me->print_title_col_to.
  ENDMETHOD.                    "LIF_EXCEL_SHEET_PRINTSETTINGS~GET_PRINT_REPEAT_COLUMNS
  METHOD Lif_excel_sheet_printsettings~get_print_repeat_rows.
    ev_rows_from = me->print_title_row_from.
    ev_rows_to   = me->print_title_row_to.
  ENDMETHOD.                    "LIF_EXCEL_SHEET_PRINTSETTINGS~GET_PRINT_REPEAT_ROWS
  METHOD Lif_excel_sheet_printsettings~set_print_repeat_columns.
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns
*           - Stefan Schmöcker,                             2012-12-02
*--------------------------------------------------------------------*

    DATA: lv_col_from_int TYPE i,
          lv_col_to_int   TYPE i,
          lv_errormessage TYPE string.


    lv_col_from_int = Lcl_excel_common=>convert_column2int( iv_columns_from ).
    lv_col_to_int   = Lcl_excel_common=>convert_column2int( iv_columns_to ).

*--------------------------------------------------------------------*
* Check if valid range is supplied
*--------------------------------------------------------------------*
    IF lv_col_from_int < 1.
      lv_errormessage = 'Invalid range supplied for print-title repeatable columns'(401).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

    IF  lv_col_from_int > lv_col_to_int.
      lv_errormessage = 'Invalid range supplied for print-title repeatable columns'(401).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

*--------------------------------------------------------------------*
* adjust internal representation
*--------------------------------------------------------------------*
    me->print_title_col_from = iv_columns_from.
    me->print_title_col_to   = iv_columns_to.


*--------------------------------------------------------------------*
* adjust corresponding range
*--------------------------------------------------------------------*
    me->print_title_set_range( ).

  ENDMETHOD.                    "LIF_EXCEL_SHEET_PRINTSETTINGS~SET_PRINT_REPEAT_COLUMNS
  METHOD Lif_excel_sheet_printsettings~set_print_repeat_rows.
*--------------------------------------------------------------------*
* issue#235 - repeat rows/columns
*           - Stefan Schmöcker,                             2012-12-02
*--------------------------------------------------------------------*

    DATA:     lv_errormessage                 TYPE string.


*--------------------------------------------------------------------*
* Check if valid range is supplied
*--------------------------------------------------------------------*
    IF iv_rows_from < 1.
      lv_errormessage = 'Invalid range supplied for print-title repeatable rowumns'(401).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

    IF  iv_rows_from > iv_rows_to.
      lv_errormessage = 'Invalid range supplied for print-title repeatable rowumns'(401).
      Lcx_excel=>raise_text( lv_errormessage ).
    ENDIF.

*--------------------------------------------------------------------*
* adjust internal representation
*--------------------------------------------------------------------*
    me->print_title_row_from = iv_rows_from.
    me->print_title_row_to   = iv_rows_to.


*--------------------------------------------------------------------*
* adjust corresponding range
*--------------------------------------------------------------------*
    me->print_title_set_range( ).


  ENDMETHOD.                    "LIF_EXCEL_SHEET_PRINTSETTINGS~SET_PRINT_REPEAT_ROWS
  METHOD Lif_excel_sheet_properties~get_right_to_left.
    result = right_to_left.
  ENDMETHOD.
  METHOD Lif_excel_sheet_properties~get_style.
    IF Lif_excel_sheet_properties~style IS NOT INITIAL.
      ep_style = Lif_excel_sheet_properties~style.
    ELSE.
      ep_style = me->excel->get_default_style( ).
    ENDIF.
  ENDMETHOD.                    "LIF_EXCEL_SHEET_PROPERTIES~GET_STYLE
  METHOD Lif_excel_sheet_properties~initialize.

    Lif_excel_sheet_properties~show_zeros   = Lif_excel_sheet_properties=>c_showzero.
    Lif_excel_sheet_properties~summarybelow = Lif_excel_sheet_properties=>c_below_on.
    Lif_excel_sheet_properties~summaryright = Lif_excel_sheet_properties=>c_right_on.

* inizialize zoomscale values
    Lif_excel_sheet_properties~zoomscale = 100.
    Lif_excel_sheet_properties~zoomscale_normal = 100.
    Lif_excel_sheet_properties~zoomscale_pagelayoutview = 100 .
    Lif_excel_sheet_properties~zoomscale_sheetlayoutview = 100 .
  ENDMETHOD.                    "LIF_EXCEL_SHEET_PROPERTIES~INITIALIZE
  METHOD Lif_excel_sheet_properties~set_right_to_left.
    me->right_to_left = right_to_left.
  ENDMETHOD.
  METHOD Lif_excel_sheet_properties~set_style.
    Lif_excel_sheet_properties~style = ip_style.
  ENDMETHOD.                    "LIF_EXCEL_SHEET_PROPERTIES~SET_STYLE
  METHOD Lif_excel_sheet_protection~initialize.

    me->Lif_excel_sheet_protection~protected = Lif_excel_sheet_protection=>c_unprotected.
    CLEAR me->Lif_excel_sheet_protection~password.
    me->Lif_excel_sheet_protection~auto_filter            = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~delete_columns         = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~delete_rows            = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~format_cells           = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~format_columns         = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~format_rows            = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~insert_columns         = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~insert_hyperlinks      = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~insert_rows            = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~objects                = Lif_excel_sheet_protection=>c_noactive.
*  me->Lif_excel_sheet_protection~password               = Lif_excel_sheet_protection=>c_noactive. "issue #68
    me->Lif_excel_sheet_protection~pivot_tables           = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~protected              = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~scenarios              = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~select_locked_cells    = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~select_unlocked_cells  = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~sheet                  = Lif_excel_sheet_protection=>c_noactive.
    me->Lif_excel_sheet_protection~sort                   = Lif_excel_sheet_protection=>c_noactive.

  ENDMETHOD.                    "LIF_EXCEL_SHEET_PROTECTION~INITIALIZE
  METHOD Lif_excel_sheet_vba_project~set_codename.
    me->Lif_excel_sheet_vba_project~codename = ip_codename.
  ENDMETHOD.                    "LIF_EXCEL_SHEET_VBA_PROJECT~SET_CODENAME
  METHOD Lif_excel_sheet_vba_project~set_codename_pr.
    me->Lif_excel_sheet_vba_project~codename_pr = ip_codename_pr.
  ENDMETHOD.                    "LIF_EXCEL_SHEET_VBA_PROJECT~SET_CODENAME_PR
endclass. "LCL_EXCEL_WORKSHEET implementation

